


<!DOCTYPE html>
	<!-- Chrome, Edge, Vivaldi  OK, firefox OK now. 2129

ezzel megy tökéletesen:
$1 QuickEdit-Pro-v1.10.2 build 206-Mod.apk

rendszer - nyelvek és bevitel - speciális - szövegfelolvasás - fogaskerék ikon - google angol egyesült államok seup-hangadatok telepítése - IV 4

modecom volcano home+A
(maradjon a képernyőn:)
nyelvek és bevitel - fizikai billentyűzet - képernyő billentyűzet használata

egész könyv konvertálása convertio-val online (pl. txt-be)
    majd fordítás 3 részre osztva html-be ágyazva egyenként a chrome-ban
    könyvek, magyar is:
    libgen.rs

ha nem menne a clipboardos szöveg betöltése, akkor játsszunk ennek a ki be kommentelésével kicsit az 1933 sorban:
//alert(origcontent);

ez már nemhttps://gregrutor.000webhostapp.com/hanfel/hanfel.html
 -->
		
		<!-- 
		hud be-ki kapcsolás itt a scriptkódban:
		" itt jól működik a hud osd fadeout! "
			
		mozgó képek be-ki kapcsolás itt a scriptkódban:
		    showAnimation();
		
		háttérkép
		/* background   */
		(.jpg legyen és a picture mappában és total commander-vágólapra másolás)
		
		/* background   */  !!?!erre Failed to read clipboard content
		background-image
		
		Failed to read clipboard content: NotAllowedError: Document is not focused.
at p.value (http://localhost:2435/eruda.min.js:2:17644)
		
		
		 -->
		
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>reader b</title>
       <script src="./js/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <link rel="stylesheet" href="./style/style.css">
    <script src="./js/etc.js"></script>
     <script src="./js/universal 1.js"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR&display=swap" rel="stylesheet">

    <body>
  <div id="background-image"></div>
</body>


    <style>
    	    :root {
            color-scheme: light dark; /* Specify color scheme for light and dark mode */
        }
        body {
        	opacity: 1; /* 50% átlátszóság */
            padding: 10px;
            border-radius: 10px; /* Kerekített sarkok hozzáadása */
            color-scheme: light dark; /* Színválasztás a világos és sötét módhoz */
            background-color: rgba(25, 35, 75, 0.8); /* Alapértelmezett háttérszín */
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
     #popup {
        	z-index: 10200; /* A popup ablak rétegezése, minden más fölött */
            margin-top: 50px;
            padding: 20px;
            background-color: rgb(255, 255, 255);

            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            width: 500px; /* Szélesség beállítása */
        }

        #fileInput, #bigInput {
            margin-bottom: 10px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            width: 150px; /* Szélesség beállítása */
        }
  

        
  .kor-gomb {
    position: absolute;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background-color: blue;
    color: white;
    opacity: 0.5;
    border: none;
    z-index: 11000;
    
    
  cursor: grab;


}

.kor-gomb:hover {
    opacity: 1;
}





         #selectedtextblock {
         	font-size: 19px;
	
	z-index: 10; /* Nagyobb z-index */
    position: fixed;
    top: 20%; /* A képernyő felső szélétől számított középpont */
    left: 50%; /* A képernyő bal szélétől számított középpont */
    transform: translate(-50%, -50%); /* A blokk középre igazítása */
}

#contextblock {
	font-size: 16px;
	z-index: -1; /* A contentblock rétegezése, minden más alatt */
	z-index: 10100; /* Nagyobb z-index */
    position: fixed;
    bottom: 10%; /* A képernyő aljától számított pozíció */
    left: 50%; /* A képernyő bal szélétől számított középpont */
    transform: translateX(-50%); /* A blokk középre igazítása vízszintesen */
    color: rgba(128, 128, 128, 0.8); /* Szürke karakterek 80%-os átlátszósággal */
}

.custom-button {
	position: relative;
	top: 300px;
	border-radius: 5px;
  width: 100px; /* Állítsd be a kívánt szélesség értékét px-ben */
  height: 50px; /* Állítsd be a kívánt magasság értékét px-ben */
  z-index: 899; /* Nagyobb z-index */
}

.customKjk2-button {
  position: relative;
  top: 300px;
  width: 100px; /* Állítsd be a kívánt szélesség értékét px-ben */
  height: 50px; /* Állítsd be a kívánt magasság értékét px-ben */
  z-index: 899; /* Nagyobb z-index */
  background-color: rgba(0, 128, 128, 0.5); /* Kékeszöld szín */
  border: none;
  border-radius: 10px;
  padding: 15px;
  color: #fff;
  text-align: center;
  cursor: pointer;
}

.customKjk2-button:hover {
  background-color: rgba(0, 128, 128, 0.7); /* Kékeszöld szín */
}

.customKjk2-button:active {
  background-color: rgba(0, 128, 128, 0.9); /* Kékeszöld szín */
}



#translated {
	z-index: 10; /* Nagyobb z-index */
	font-size: 16px;
    position: fixed;
    bottom: 61%; /* A képernyő aljától számított pozíció */
    left: 50%; /* A képernyő bal szélétől számított középpont */
    transform: translateX(-50%); /* A blokk középre igazítása vízszintesen */
    color: rgba(228, 228, 228, 0.8); /* Szürke karakterek 80%-os átlátszósággal */
}
#translateBtn {
    opacity: 0; /* Átlátszóság beállítása 0-ra */
}
      @keyframes backgroundSlideIn {
    from {
        background-position: 100% 0;
    }
    to {
        background-position: 0 0;
    }
}


    @keyframes backgroundSlideOut {
    from {
        background-position: 0 0;
    }
    to {
        background-position: 100% 0;
    }
}




#counter {
  font-size: 16px;
  position: fixed;
  top: 8px; /* Felső margó */
  right: 10px; /* Jobb margó */
  background: rgb(107, 205, 0, 1);
  color: rgba(255, 255, 255, 1); /* Szövegszín */
  padding: 5px 10px; /* Belső tér */
  border-radius: 5px; /* Kerekített sarkok */
  z-index: 1000; /* Z-index beállítása a megfelelő rétegrendezéshez */
}

#sentence-number {
  position: fixed;
  top: 60px;
  right: 14px;
  font-size: 12px;
  color: rgba(155, 155, 55, 0.6); /* Szövegszín */
  text-align: right;
  z-index: 1000;
}
            
     .scroll-left {
     	opacity: 0.85;
     	font-size: 35px;
     	position: fixed; /* Fix pozíció */
    	top: 3px;
    display: flex; /* Use flexbox for vertical centering */
    align-items: center; /* Align items vertically center */
    justify-content: center; /* Align items horizontally center */
    border-radius: 3px;
    height: 40px;
    width: 90%;
    overflow: hidden;
    position: relative;
    background: rgba(5, 15, 25, 0.8); 
    color: white;
    border: 1px solid rgba(95, 115, 225, 0.8); /* Corrected border declaration */
}
        .scroll-left p {
        	font-size: 16px;
            position: absolute;
            top: -2px;
            width: 100%;
            height: 100%;
            margin: 0;
            line-height: 40px;
            text-align: center;
            /* Starting position */
            transform: translateX(100%);
            /* Apply animation to this element */
            animation: scroll-left 15s linear infinite;
        }
        /* Move it (define the animation) */
        @keyframes scroll-left {
            0% {
                transform: translateX(100%);
            }
            100% {
                transform: translateX(-100%);
            }
        }
        
    /*  a gombok elrendezése, csak akkor kerüljenek új sorba, ha 4 button már egymás mellett van.   */    
.container {
  display: flex;
  flex-wrap: wrap;
}

button {
  flex: 1 0 16.666%; /* Hat gomb esetén a konténer 16.666%-át foglalja el mindegyik gomb */
  margin: 5px;
}
/* Médialekérdezés, ami akkor aktiválódik, ha a képernyő szélessége 600px-nél kisebb */
@media (max-width: 600px) {
  button {
    flex-basis: 100%; /* Ekkor minden gomb saját sorban lesz */
  }
}

    /*  a gombok megjelenítése  */    
      button {
  padding: 8px 15px;
  background-color: rgba(0, 123, 255, 1);
  color: rgb(255, 255, 255);
  border: none;
  border-radius: 3px;
  cursor: pointer;
  box-sizing: border-box; /* Új tulajdonság */
}

button:hover {
  background-color: #0056b3;
}


/* type best stílusai */
#divId {
  position: fixed; /* Fix pozícióban lesz a képernyőn */
  top: 10%; /* Középre helyezzük függőlegesen */
  left: 10%; /* Középre helyezzük vízszintesen */
  //transform: translate(-50%, -50%); /* Középre igazítjuk a div-et */
  text-align: center; /* Szöveg középre igazítása */
}

#paragraphId {
  
  color: #32CD32; /* Világoszöld szín, mint a régi terminálok */
  font-size: 2.5em; /* Nagyobb betűméret */
  font-weight: bold; /* Félkövér betűstílus */
  text-shadow: 0 0 5px #32CD32; /* Halvány zöld árnyék a szöveg mögött */
}



#TheSlider {
    margin-top: 55px; /* A korábbi 50px-ről módosítva */
    left: 18px;
    position: fixed; /* Rögzített pozíció */
    width: 75%; /* A teljes szélesség kihasználása */
    z-index: 500; /* Biztosítja, hogy a görgető sáv fölött legyen */
    background: linear-gradient(to right, #6dd5ed, #2193b0); /* Színátmenetes háttér */
    border-radius: 8px; /* Lekerekített sarkok */
    box-shadow: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23); /* Árnyék hozzáadása */
    transition: all 0.5s ease; /* Sima átmenetek */
}

#TheSlider:hover {
    transform: scale(1.05); /* Nagyítás amikor ráviszik az egeret */
}

/* SLider glow stílusai */
.glow {
    z-index: 900;
    position: fixed;
    top: 15px;
    left: 155px;
    --c: rgb(0, 255, 255, calc(0.25 + var(--val) / 125));
    --c: hsl(160deg 80% 50% / calc(0.25 + var(--val) / 125));
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    background: transparent;
    cursor: pointer;
    width: 15rem;
    position: relative;
}

.glow::before {
    z-index: 900;
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    width: calc((var(--val) - 1) * 1%);
    min-width: 100%;
    height: 100%;
    background: var(--c);
    box-shadow: 
        0 0 0.2em 0 hsl(0 0% 0%) inset, 
        -0.1em 0.1em 0.1em -0.1em hsl(0 0% 100% / 0.5),
        0 0 calc(1em + 0.001em * var(--val)) calc(0.1em + 0.00025em * var(--val)) var(--c);
    border-radius: 1em 0 0 1em;
    opacity: calc(20% + var(--val) * 1%);
}

.glow::-webkit-slider-runnable-track {
    z-index: 900;
    box-shadow: 
        0 0 0.2em 0 hsl(0 0% 0%) inset, 
        -0.1em 0.1em 0.1em -0.1em hsl(0 0% 100% / 0.5);
    background: 
        linear-gradient(to bottom right, #0001, #0000),
        #343133;
    border-radius: 1em;
    height: 1em;
}



.glow::-webkit-slider-thumb {
    
}

.glow::-webkit-slider-thumb {
    z-index: 900;
    --d: var(--c);
    --d: rgb(from var(--c) r g b / calc(0.35 * var(--val) * 1%));
    -webkit-appearance: none;
    appearance: none;
    background-color: #5cd5eb;
    transform: translateY(calc(-50% + 0.5em));
    width: 4em;
    aspect-ratio: 1;
    background: red;
    border-radius: 50%;
    background: 
        radial-gradient(farthest-side, #0000 22.5%, var(--d) 0, #0000 calc(var(--val) * 0.75%)) 50% 50% / 100% 100% no-repeat,
        radial-gradient(#0000  15%, #343133 16%, #545153 20%),
        repeating-linear-gradient(#0000 0 10%, #0002 0 20%) 50% 50% / 25% 25% no-repeat,
        repeating-linear-gradient(90deg, #0000 0 10%, #0002 0 20%) 50% 50% / 25% 25% no-repeat,
        radial-gradient(var(--c) 17%, #0000 0),
        #545153;
    box-shadow:
        inset -0.15em -0.15em 0.2em #0008,
        inset 0.15em 0.15em 0.2em #ffffff22,
        inset calc(var(--val) * 1em / 500) 0em calc(var(--val) * 1em / 500) calc(var(--val) * -1em / 700) var(--c),
        0.25em 0.25em 0.5em #0006,
        calc(0.0125em * var(--val)) calc(0.005em * var(--val)) calc(0.02em * var(--val)) calc(-0.01em * var(--val)) #000a;
    border-radius: 50%;
    /* ... egyéb stílusok ... */
    
   // font-size: 13px; // méret thumb
    
}

/* hangfelismerés */
   #recognizedText {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }


/* CSS */
#volume-slider-container {
  position: absolute;
  top: 70%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 10000;
}

#volume-slider {
  width: 200px;
}

#contextSwipeArea {
  position: fixed;
  bottom: 300;
  left: 0;
  width: 100%;
  height: 40%;
}

.readpercentagehtml {
    position: fixed;
    right: 30px; /* Állítsd be a kívánt bal oldali pozíciót */
    bottom: 130px; /* Állítsd be a kívánt alsó pozíciót */
    font-size: 10px;
    font-weight: bold;
    color: rgba(255, 255, 255, 0.5); /* Fehér szín, 80% átlátszóság */
    background-color: rgba(0, 0, 0, 0.1); /* Fekete háttér, 50% átlátszóság */
    padding: 5px 10px;
    border-radius: 5px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); /* Szövegárnyék hozzáadása */
}




/* background   */

#background-image {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-size: cover;
  background-position: center;
  animation: fadeInOut 30s infinite linear;
}

@keyframes fadeInOut {
  0% {
    opacity: 0;
  }
  50% {
    opacity: 0.6;
  }
  100% {
    opacity: 0;
  }
}


#favoritInput {
  width: calc(100% - 320px);
  height: calc(100% - 70px);
  margin-bottom: 10px;
  background-color: rgba(15, 15, 25, 0.71); /* Fehér szín 50%-os átlátszósággal */
  /*opacity: 0.65;  Vagy használhatod az opacity tulajdonságot is */
  color: rgba(245, 215, 215, 1); / Fehér szín a szöveghez /
font-size: 12px; / 16 pixeles betűméret */
}

#favoritPopupButton {
    padding: 8px 15px;
  background-color: rgba(0, 143, 255, 0.51);
  color: rgb(255, 255, 255);
  border-radius: 33px;
  box-sizing: border-box; /* Új tulajdonság */
  
    border: none; /* Nincs keret */
    padding: 10px 20px; /* Párnázás */
    font-size: 14px; /* Betűméret */
    cursor: pointer; /* Mutató kéz */
    transition: background-color 0.3s; /* Áttűnés animáció 
width: 100px;  Fix szélesség 
    height: 43px;  Fix magasság
    #favoritPopupButton:hover {
    background-color: rgba(5, 0, 10, 0.8); 
}
*/
    
}

     
     
     
     #kalandlapInput {
  width: calc(100% - 320px);
  height: calc(100% - 70px);
  margin-bottom: 10px;
  background-color: rgba(15, 15, 25, 0.71); /* Fehér szín 50%-os átlátszósággal */
  /*opacity: 0.65;  Vagy használhatod az opacity tulajdonságot is */
  color: rgba(245, 215, 215, 1); / Fehér szín a szöveghez /
font-size: 12px; / 16 pixeles betűméret */
}

#kalandlapPopupButton {
    padding: 8px 15px;
  background-color: rgba(190, 143, 255, 0.51);
  color: rgb(255, 255, 255);
  border-radius: 33px;
  box-sizing: border-box; /* Új tulajdonság */
  
    border: none; /* Nincs keret */
    padding: 10px 20px; /* Párnázás */
    font-size: 14px; /* Betűméret */
    cursor: pointer; /* Mutató kéz */
    transition: background-color 0.3s; /* Áttűnés animáció 
width: 100px;  Fix szélesség 
    height: 43px;  Fix magasság
    #favoritPopupButton:hover {
    background-color: rgba(5, 0, 10, 0.8); 
}
*/
    
}
        
        
        


button[id^="button-"] {
  width: 110px;       /* Szélesebb */
  height: 60px;       /* Magasabb */
  font-size: 20px;    /* Nagyobb szöveg */
  padding: 12px 24px; /* Több belső térköz */
  border-radius: 25px;      /* Lekerekített sarkok */
}

    </style>
</head>
<body>
   

   
<input type="range" id="TheSlider" min="1" max="100000" value="40000" class="glow" style="--val: 50" />
<span id="readpercentagehtml" class="readpercentagehtml"></span>




    <span id="counter"></span>
    <span id="sentence-number"></span>
        <div class="scroll-left">
        <p>
            
        </p>
     </div>
     
     
<button id="gomb1" class="kor-gomb" style="left: calc(50% - 250px); top: calc(50% + 50px);">1</button>
<button id="gomb2" class="kor-gomb" style="left: calc(50% - 200px); top: calc(50% + 50px);">2</button>
<button id="gomb3" class="kor-gomb" style="left: calc(50% - 150px); top: calc(50% + 50px);">3</button>
<button id="gomb4" class="kor-gomb" style="left: calc(50% - 100px); top: calc(50% + 50px);">4</button>
<button id="gomb5" class="kor-gomb" style="left: calc(50% - 50px); top: calc(50% + 50px);">5</button>
<button id="gomb6" class="kor-gomb" style="left: calc(50%); top: calc(50% + 50px);">6</button>
<button id="gomb7" class="kor-gomb" style="left: calc(50% + 50px); top: calc(50% + 50px);">7</button>
<button id="gomb8" class="kor-gomb" style="left: calc(50% + 100px); top: calc(50% + 50px);">8</button>
<button id="gomb9" class="kor-gomb" style="left: calc(50% + 150px); top: calc(50% + 50px);">9</button>
<button id="gomb10" class="kor-gomb" style="left: calc(50% + 200px); top: calc(50% + 50px);">10</button>

<button id="gomb11" class="kor-gomb" style="left: calc(50% - 250px); top: calc(50% + 110px);">11</button>
<button id="gomb12" class="kor-gomb" style="left: calc(50% - 200px); top: calc(50% + 110px);">12</button>
<button id="gomb13" class="kor-gomb" style="left: calc(50% - 150px); top: calc(50% + 110px);">13</button>
<button id="gomb14" class="kor-gomb" style="left: calc(50% - 100px); top: calc(50% + 110px);">14</button>
<button id="gomb15" class="kor-gomb" style="left: calc(50% - 50px); top: calc(50% + 110px);">15</button>
<button id="gomb16" class="kor-gomb" style="left: calc(50%); top: calc(50% + 110px);">16</button>
<button id="gomb17" class="kor-gomb" style="left: calc(50% + 50px); top: calc(50% + 110px);">17</button>
<button id="gomb18" class="kor-gomb" style="left: calc(50% + 100px); top: calc(50% + 110px);">18</button>
<button id="gomb19" class="kor-gomb" style="left: calc(50% + 150px); top: calc(50% + 110px);">19</button>
<button id="gomb20" class="kor-gomb" style="left: calc(50% + 200px); top: calc(50% + 110px);">20</button>

    
    
    
    
    
    
    
     
     
             	<!-- HTML -->
<div id="volume-slider-container">
  <input id="volume-slider" type="range" min="0" max="100" value="50">
</div>

     <!-- bookname -->
     <p1 id="wordContainer" style="position: relative; left: 10px; top: 246px; color: rgba(128, 120, 128, 0.51); font-size: 12px;"></p1>

      
        <div id="recognizedText"></div>
        
        <p id="current-letter" style="position: absolute; top: 450px; left: 50%; transform: translateX(-50%); font-size: 120px; text-align: center;"></p>
        
     <div id="popup" style="display: none; position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%); padding: 20px; border-radius: 10px; background-color: rgba(255, 155, 55, 0.8); box-shadow: 0 0 50px rgba(220, 0, 0, 0.9);">
     	
     
     
     
     <div id="searchPopup" style="display: none; position: fixed; top: 0; left: -75px; width: 152%; height: 100%; padding: 10px; box-sizing: border-box; border-radius: 10px; background-color: rgba(155, 255, 55, 0.8); box-shadow: 0 0 50px rgba(0, 220, 0, 0.9);">
    <textarea id="searchInput" placeholder="Search..." style="width: calc(100% - 20px); height: calc(100% - 70px); margin-bottom: 10px; font-size: 24px;"></textarea>
    <!-- Az új gombok sorrendje -->
    <button onclick="search()" style="width: 150px; font-size: 18px; font-weight: bold; background-color: #4CAF50; color: #fff; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer;">Search</button>
    <button onclick="searchpaste()" style="width: 100px;">Paste</button>
    
    <button onclick="searchclose()" style="width: 100px;">Close</button>
</div>









<div id="cleanPopup" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px; border-radius: 10px; background-color: rgba(155, 255, 55, 0.8); box-shadow: 0 0 50px rgba(0, 220, 0, 0.9);">
    <!-- clean input field -->
    <input type="text" id="cleanInput" placeholder="Clean...">
    <button onclick="confirmClean()">Confirm</button>
</div>

<div id="favoritPopup" style="display: none; position: fixed; top: -130px; left: -75px; width: calc(100% + 150px); height: 120%; padding: 10px; box-sizing: border-box; border-radius: 10px; background-color: rgba(155, 255, 55, 0.8); box-shadow: 0 0 50px rgba(0, 220, 0, 0.9);">
   <textarea id="favoritInput" placeholder="Favorit..." 
          style="
                 width: calc(100% - 250px); 
                 height: calc(100% + 60px); 
                 margin-bottom: 10px; 
                 font-size: 8px; 
                 color: rgba(15, 45, 15, 0.95); 
                 background-color: rgba(215, 215, 25, 0.85); 
                 border-radius: 5px;">
   </textarea>
   <!-- Button container with Flexbox -->
   <div style="display: flex; flex-wrap: wrap; justify-content: space-between;">
       <button onclick="favoritadd()" style="width: 100px; margin-bottom: 10px;">Paste</button>
       <button onclick="favoritsave()" style="width: 100px; margin-bottom: 10px;">Save</button>
       <button onclick="favoritsavetofile()" style="width: 100px; margin-bottom: 10px;">Save to File</button>
       
           <button onclick="editAndDownloadPaths()" style="width: 100px; margin-bottom: 10px;">Save to File edit paths</button>
       
       <button onclick="favoritloadfile()" style="width: 100px; margin-bottom: 10px;">Load File</button>
       <button onclick="favoritclean()" style="width: 100px; margin-bottom: 10px;">Clear</button>
       <button onclick="favoritclose()" style="width: 100px;">Close</button>
   </div>
</div>




<div id="kalandlapPopup" style="display: none; position: fixed; top: -130px; left: -75px; width: calc(100% + 110px); height: 120%; padding: 10px; box-sizing: border-box; border-radius: 10px; background-color: rgba(195, 25, 215, 0.8); box-shadow: 0 0 50px rgba(200, 20, 190, 0.9);">
   <textarea id="kalandlapInput" placeholder="kalandlap..." 
          style="
                 width: calc(100% + 50px); 
                 height: calc(100% + 60px); 
                 margin-bottom: 10px; 
                 font-size: 16px; 
                 color: rgba(225, 215, 205, 0.95); 
                 background-color: rgba(218, 50, 210, 0.4); 
                 border-radius: 10px;">
   </textarea>
   <!-- Button container with Flexbox -->
   <div style="display: flex; justify-content: space-between; margin-top: 10px;">
       <button onclick="kalandlapsave()" style="width: 100px;">Save</button>
       <button onclick="kalandlapsavetofile()" style="width: 100px;">Save to File</button>
       <button onclick="kalandlapclean()" style="width: 100px;">Clear</button>
       <button onclick="kalandlapclose()" style="width: 100px;">Close</button>
              <button onclick="kjkhistoryshow()" style="width: 100px;">naplózás</button>
   </div>
</div>





<div id="favoritLoadPopup" style="display: none; position: fixed; top: 0; left: -40px; width: 128%; height: 100%; padding: 10px; box-sizing: border-box; border-radius: 10px; background-color: rgba(155, 255, 55, 0.8); box-shadow: 0 0 50px rgba(0, 220, 0, 0.9);">
    <!--  -->
    <button onclick="up()" style="width: 100px;">Save</button>
    <button onclick="down()" style="width: 100px;">Paste</button>
    <button onclick="select()" style="width: 100px;">Close</button>
</div>


        <input type="file" id="fileInput"> 
       <input type="text" id="bigInput">
<button id="okButton">OK</button>
<button onclick="playrefreshSound()">Restart</button>
        <button onclick="pasteFromClipboard()">Paste Text</button>
        
           <button onclick="randombooknewmenube()">Random Book</button>
        
        <button onclick="saveToFile()">save to file</button>
        
        <button onclick="saveToFileBookmarks()">save bookmarks</button>
        
        <button onclick="toggleFullscreen()">fullScreen</button>
        
        <button onclick="bookmarkdeleteall()">delete bookmarks</button>
        <button onclick="fileBookmarkBetolt()">load bookmarks</button>
        <button onclick="bookmarkallshow()">show bookmarks</button>
        
        

    <button onclick="showarchivesentencestorage()">show archivessentences</button>
     <button onclick="deletearchivesentencestorage()">delete archivessentences</button>
     <button onclick="contentarchive()">add archivessentences</button>
     <button onclick="downloadarchivesentencestorage()">download archivessentences</button>



        <button id="searchPopupButton" onclick="toggleSearchPopup()">Search</button>
        
        <button id="cleanerPopupButton" onclick="togglecleanPopup()">Open Clean</button>
        
          <button id="favoriteditPopupButton" onclick="togglefavoritPopup()">Favorit Edit</button>
          <button id="favoritPopupButton" onclick="nomusic = 1; togglefavoritLoadPopup();">Favorit</button>

           <button onclick="instanTTranslate()">Instant Translate</button>
        
       
           
        
                <button id="InputWindow" onclick="joyonscreen2()">Nincs Joypad</button>
        
        
        <button id="toggleGombok" >onscreen gombok ki/be</button>

        
        
        
<button id="manualbuttlang">Language</button>

<button id="colorfulbuttonid"onclick="toggleColor()">color</button>


<button id="randomwordotbuttonid" onclick="randomwordotbutton(); isClickHandlingActive = false;">random word</button>


<button id="kalandlapbuttonid"onclick="kalandlap()">kalandlap</button>

<button id="olvassebességid"onclick="olvasseb()">olvas sebesség</button>

<button id="bulletinid"onclick="ujsag()">bulletin</button>

<button id="googlebulletinid"onclick="ujsaggoogle()">google bulletin</button>

<button id="toggleFuncBtn" onclick="toggleFunc()">Szurt ON</button>



<button id="info"onclick="inditKetto()">info</button>
        
        

        
        
    </div>
    <div id="selectedtextblock" style="text-align: center;">Welcome</div> <!-- Dinamikusan változtatható szöveges terület a képernyő közepén -->
    <div id="contextblock" style="text-align: center;">Context Block</div> <!-- Dinamikusan változtatható szöveges terület a képernyő alján -->
    <div id="translated" style="text-align: center;">Translate Block</div> <!-- Dinamikusan változtatható szöveges terület a képernyő alján -->
    	<button id="translateBtn">Fordítás</button>
        
    <!-- type best -->
    	<!-- Audio element for playing the sound -->
  <audio id="background_audio" src="snd/type sound.mp3"></audio>
 
  
      <div id="divId">
         <p id="paragraphId" style="font-family: 'Orbitron', sans-serif;"></p>
    </div>
    
    
      <div id="contextSwipeArea" style="z-index: 5999;"></div>


<div id="radio-panel" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(128, 128, 128, 0.5); z-index: 10101;">
    <div id="radio-list" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(128, 128, 128, 0.5); padding: 20px; border-radius: 10px; color: orange; font-size: 20px; font-weight: bold; max-height: 80vh; overflow-y: auto;">
        <!-- Itt jelennek meg a rádióadók -->
    </div>
</div>


        <!-- Itt jelennek meg a rádióadók -->
    </div>
</div>

        <!-- Itt jelennek meg a rádióadók -->
    </div>
</div>



          <!--  -->
          	
    <script>
        let origcontent;
        let ezinputbeiras;
        let allsentencenumber;
        let currentsentencenumber;
        let displaysentence;
        let contextblock = document.getElementById('contextblock');
        let legorigabbcontent;
        let numberreminder;
        let sentencesaveslot1;
        let booknameWords;
        bookname = "empty";
        let keyPressCount1 = 0; // Move this outside the event listener
        let keyPressCount3 = 0; // Move this outside the event listener
        var currentSound = null; // Globális változó az aktuálisan játszott hang számára
        let radioCounter = 0;
        let firstdomload = 1;
        let firstdomloadforTyping = 1;
        let jumpcount = 1;
        let instanttranslate = 0;
        let favpopuploadwide = 0; 
// joypad 2 favoritload miatt kell
        favpopuploadForJoy1 = 0;
        let currentfilePath;
        let srtContent;
        //let text;
        let isSrt;
        let nyuszino = 1; // alapból kikapcsolva a kjk zagor naplózása
        let torpedoTimeoutId; // globális változó a setTimeout ID-jének tárolására hogy ne akadjon ki tőlük
        let ezkjkkonyv = 0;
        let lapozzSzavakSzama = 0;
        let commands;
        
       //let nativelanguage = 'hu-HUN';
       // let readpath;
        
	// FOLYTATOM! content helye scriptből
//	document.getElementById('content').style.position = 'relative'; // Vagy 'absolute' vagy 'fixed'
//  document.getElementById('content').style.top = '300px'; // Beállítja a top pozíciót 100 pixelre
// document.getElementById('content').style.left = '100px'; // Beállítja a top pozíciót 100 pixelre

   // type divld helye scriptből
//document.getElementById('divId').style.position = 'fixed'; // Vagy 'absolute' vagy 'fixed'
//document.getElementById('divId').style.top = '300px'; // Beállítja a top pozícióját 100 pixelre



// clipboardváltozásfigyelés automatika programfutás alatt folyamatosan, van egy másik is itt ami csak domcontentloadkor aktiválódik

// Clipboard content monitoring


let previousClipboardContent = null; // Global variable to store the previous clipboard content
let monitoringInterval;
let timeout;
let fetchedData;
let uvdata;
let manuallanguage = "native"; // default value
let winner;
let favoritlistopen = 0;
let kjkNumjump;
let first4shot = 1;
let rndWord;
let randomwordot = 0;
var speed;
let firsttogglefullscreee = 1;
let nomusic = 1;
var olvassebesseg = parseFloat(localStorage.getItem('olvassebesseg')) || 0.8;
let toggleolvassebessegon = 0;
let randomwordsearch = 0;
let newfavoritbookfirst =0;
var actualsentence;
let sState = 0;
let radioplayer = 0;
let radioado;
let holdopened = 0;
let labelText;
let bookfavoritindex;
let newsflag = 0;

let muteSounds = JSON.parse(localStorage.getItem("muteSounds"));
//let translatedText;



	// Görgetés letiltása
document.body.style.overflow = 'hidden';

	// Görgetés engedélyezése
//document.body.style.overflow = 'auto';

document.getElementById("volume-slider-container").style.display = "none";

//ha első indításszerűt akarunk
//localStorage.removeItem("bookmarkrapid");

      





// ezt nem tudom hova rakjam de most nem is fontos hangjelzés
      //   playany(['snd/button/war of stealth click 1.mp3'], 1);
   // startTypingAnimation('paragraphId', 'divId', 'enterFullscreen');
   

// Az egész HTML oldal, amely teljes képernyős módba kerül
const elem = document.documentElement;

function isFullscreen() {
    return document.fullscreenElement || 
           document.mozFullScreenElement || 
           document.webkitFullscreenElement || 
           document.msFullscreenElement;
}

function enterFullscreen() {
    if (elem.requestFullscreen) {
        elem.requestFullscreen();
    } else if (elem.mozRequestFullScreen) { // Firefox
        elem.mozRequestFullScreen();
    } else if (elem.webkitRequestFullscreen) { // Chrome, Safari és Opera
        elem.webkitRequestFullscreen();
    } else if (elem.msRequestFullscreen) { // IE/Edge
        elem.msRequestFullscreen();
    }
}

function exitFullscreen() {
    if (document.exitFullscreen) {
        document.exitFullscreen();
    } else if (document.mozCancelFullScreen) { // Firefox
        document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) { // Chrome, Safari és Opera
        document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) { // IE/Edge
        document.msExitFullscreen();
    }
}

function toggleFullscreen() {
    if (!isFullscreen()) {
        playany(['snd/You searched for notify ZapSplat - Download free sound effects_1744032239933.mp3'], 1);
        enterFullscreen();
    } else {
        playany(['snd/button/war of stealth click 1.mp3'], 1);
        exitFullscreen();
    }
}










function monitorClipboard() {
    let counter = 0;
    monitoringInterval = setInterval(() => {
    	
    
    document.getElementById('sentence-number').textContent = allsentencenumber; // Frissítjük a számlálót az összszámmal
    
        if (document.visibilityState === 'visible') {
            navigator.clipboard.readText()
                .then(text => {
                    let currentDate = new Date().toLocaleString();
                    //console.log(`[${currentDate}] Clipboard content: ${text}`);
                    
                    if (previousClipboardContent !== null && text !== previousClipboardContent) {
                        console.log('The clipboard content has changed since the last check!');
                        
                        window.location.href = "reader a 3.html";
                        return;
                        //playany(['snd/wet-click-low-atmospheric.wav', 'snd/wet-click-low-atmospheric.wav', 'snd/wet-click-low-atmospheric.wav'], 1, 'center');
                        //clearScreen();
                        //showImage("./picture/rallystyleice395179972.jpeg", "20px");
                        //stopSpeaking(); 
                        //playrefreshSound();
                        // Az oldal teljes újratöltése
                        //pasteeeweb();
                    }
                    
                    previousClipboardContent = text; // Update the previous clipboard content
                    counter++;

                    if (counter % 10 === 0) {
                        clearInterval(monitoringInterval);
                        //console.log('The timer has been stopped every 10 runs.');
                        timeout = setTimeout(() => {
                            monitorClipboard();
                        }, 2000); // Call itself after 2 seconds
                    }
                })
                .catch(err => {
                    console.error('An error occurred while reading the clipboard: ', err);
                });
        }
    }, 3000);
}


setTimeout(function() {
                        monitorClipboard();
                    }, 2000);
//monitorClipboard();


//teljes leállítása:
function stopMonitoring() {
	
	fadeInOutText('stopMonitoring', 18, 'rgba(220, 60, 20, 1)', 5);
	
    clearInterval(monitoringInterval); // Megállítja az időzített ciklust
    clearTimeout(timeout); // Megszünteti a várakozási időt
    previousClipboardContent = null; // Visszaállítja a vágólap tartalmát
}

/*
// Hívjuk meg a stopMonitoring() függvényt, ha le szeretnénk állítani a monitorozást
 //stopMonitoring();
*/



        document.addEventListener('DOMContentLoaded', function() {
        	
        // ez nem mer clipboardinfókat nem engedné és hang sincs ilyenkor
       // startTypingAnimation('paragraphId', 'divId', "Let's make your coding experience smooth and enjoyable!");
        
            let images = [
                'background0.jpeg',
                'background1.jpeg',
                'background2.jpeg',
                'background3.jpeg',
                'background4.jpeg',
                'background5.jpeg',
                'background6.jpeg',
                'background7.jpeg',
                'background8.jpeg',
                'background9.jpeg',
                'background10.jpeg',
                // További képek...
            ];

            images.sort(); // Képek rendezése

            let randomImage = images[Math.floor(Math.random() * images.length)]; // Véletlenszerű kép kiválasztása

            // A kiválasztott kép nevének beírása a 'title' osztályú div-be
            document.querySelector('.callout.left .title').textContent = randomImage;

            // A képek listájának dinamikus beírása a 'body' osztályú div-be
            document.querySelector('.callout.left .body').innerHTML = images.join('<br>');

            // A változók értékeinek beírása a 'callout right' osztályú div-be
            let vari1 = "123";
            let vari2 = "456";
            let vari3 = "aa bb?";
            let vari4 = "789";

            document.querySelector('.callout.right .title').textContent = vari1;
            document.querySelector('.callout.right .body').innerHTML = `${vari2}<br>${vari3}<br>${vari4}`;

            // A további kódod...
            let popup = document.getElementById('popup');
            popup.style.display = 'block';
            optionsopen = 1;
            document.body.style.backgroundImage = "url('./picture/" + randomImage + "')";
            document.body.style.animation = "backgroundSlideIn 1s forwards";
        });


// betöltéskor total commander cím vizsgálat
//A program törli totaladdress localstorage bejegyzést.
// Folytatás a kódhoz, amely kezeli a "Total commander file list" szöveget a vágólapról

// Módosítás a kódhoz, hogy ellenőrizze, a vágólap tartalmazza-e a "Total commander file list" részszöveget





document.addEventListener('DOMContentLoaded', () => {
  // Ellenőrizzük, hogy a vágólap tartalmaz-e a "Total commander file list" részszöveget
  navigator.clipboard.readText().then((clipText) => {
if (clipText.includes("Total commander file list") && clipText.includes(".jpg")) {
  // Do something with the file content
    //	alert(".jpg");
      // Ha igen, akkor töröljük a 'totaladdress' bejegyzést a localStorage-ból
      localStorage.removeItem('totaladdressjpg');
      // És betöltjük a vágólap tartalmát a 'totaladdress' bejegyzésbe
      localStorage.setItem('totaladdressjpg', clipText);
      
      totaladdautojpg();
    }
  });
});

let extractedPath;

// így törölhető a kép
//localStorage.removeItem('extractedPathstorage');

function totaladdautojpg() {
  // Várunk fél másodpercet
  setTimeout(() => {
    // Kiolvassuk a 'totaladdressjpg' bejegyzést a localStorage-ból
    const totalAddress = localStorage.getItem('totaladdressjpg');
    if (totalAddress) {
      // Ha van érték, akkor belehelyezzük a 'newAddressTotal' változóba
      const newAddressTotal = totalAddress;
      // Töröljük a 'totaladdress' bejegyzést a localStorage-ból
      localStorage.removeItem('totaladdressjpg');

      //info a usernek
      const newText = "Total commander JPG clipboard recognized. (the filename should always be .jpg)";
      document.querySelector('.scroll-left p').textContent = newText;
      
      navigator.clipboard.writeText(''); // Clears the clipboard by writing an empty string
                       
      
         // Sikertelen művelet, vagy egyéb tájékoztatás
    startTypingAnimation('paragraphId', 'divId', 'Total commander pathway recognized on clipboard. (Info 1: picture filename should always be .jpg, and should be in the pictures folder)(Info 2: If the book is not found, it will be removed from the favourites) The clipboard is deleted.');
      
                        
      
      
  /*
      változtass. Ha a newAddressTotal változóban szerepel .jpeg vagy .png és nem szerepel a .jpg szöveg akkor... (a többi változatlan).
      
      // Check the file extension
// Check the file extension
if ((newAddressTotal.includes('.jpeg') || newAddressTotal.includes('.png')) && !newAddressTotal.includes('.jpg')) {
  console.log('The PictureBackground variable does not have a .jpg file extension.');
  
  startTypingAnimation('paragraphId', 'divId', 'The Picture does not have a .jpg file extension.');
  fadeInOutText("ERROR", 32, 'rgba(240, 30, 31, 1)', 16);
  return;
}

*/
	
//alert(newAddressTotal);

// Check if newAddressTotal is defined
if (typeof newAddressTotal === 'undefined') {
  console.log('The newAddressTotal variable is undefined.');
  
  startTypingAnimation('paragraphId', 'divId', 'The newAddressTotal variable is undefined.');
  fadeInOutText("ERROR", 32, 'rgba(240, 30, 31, 1)', 16);
  return;
}


      
      
      
      
      // Kinyerjük az útvonalat a totalAddress változóból
      extractedPath = totalAddress.match(/\/storage[\s\S]*?\.jpg/)[0];
      // Ellenőrizzük, hogy az extractedPath tartalmaz-e "+" karaktert
      if (extractedPath.includes('+')) {
        alert('Please rename the file to remove the "+" character before adding it to favorites.');
        return; // Leállítjuk a funkciót
      }
      // Csak az első sortörés cseréje, ha a kívánt szöveg megtalálható
      extractedPath = extractedPath.replace(/\n/, '/');

let startIndex = extractedPath.indexOf("/picture/");
if (startIndex !== -1) {
  extractedPath = extractedPath.substring(startIndex);
}
extractedPath = "." + extractedPath;
//alert(extractedPath);

		// Háttér kép elérési útvonala
PictureBackground = './picture/background8.jpg';


//extractedPath = "." + extractedPath

// SetItem
localStorage.setItem('extractedPathstorage', extractedPath);



          
       //   startTypingAnimation('paragraphId', 'divId', 'The new JPG file path is OK.' + extractedPath);
          
          playrefreshSound();
        
      } else {
        // Ha még nincs favoritstorage, akkor létrehozzuk és beállítjuk az új címet
        localStorage.setItem('totaladdressjpg', extractedPath);
        
      }
    
  }, 1000); // Fél másodperc (500 ms) várakozás
}











document.addEventListener('DOMContentLoaded', () => {
  // Ellenőrizzük, hogy a vágólap tartalmaz-e a "Total commander file list" részszöveget
  navigator.clipboard.readText().then((clipText) => {
if (clipText.includes("Total commander file list") && clipText.includes(".txt")) {
    	//alert();
      // Ha igen, akkor töröljük a 'totaladdress' bejegyzést a localStorage-ból
      localStorage.removeItem('totaladdress');
      // És betöltjük a vágólap tartalmát a 'totaladdress' bejegyzésbe
      localStorage.setItem('totaladdress', clipText);
    }
  });
});


totaladdauto();

function totaladdauto() {
  // Várunk fél másodpercet
  setTimeout(() => {
    // Kiolvassuk a 'totaladdress' bejegyzést a localStorage-ból
    const totalAddress = localStorage.getItem('totaladdress');
    if (totalAddress) {
      // Ha van érték, akkor belehelyezzük a 'newAddressTotal' változóba
      const newAddressTotal = totalAddress;
      // Töröljük a 'totaladdress' bejegyzést a localStorage-ból
      localStorage.removeItem('totaladdress');

      //info a usernek
      const newText = "Total commander clipboard recognized.";
      document.querySelector('.scroll-left p').textContent = newText;
      
      
      // Kinyerjük az útvonalat a totalAddress változóból
      extractedPath = totalAddress.match(/\/storage[\s\S]*?\.txt/)[0];
      // Ellenőrizzük, hogy az extractedPath tartalmaz-e "+" karaktert
      if (extractedPath.includes('+')) {
        alert('Please rename the file to remove the "+" character before adding it to favorites.');
        return; // Leállítjuk a funkciót
      }
      // Csak az első sortörés cseréje, ha a kívánt szöveg megtalálható
      extractedPath = extractedPath.replace(/\n/, '/');

      // Hozzáadjuk az extractedPath tartalmát a favoritstorage bejegyzéshez
      const favoritStorage = localStorage.getItem('favoritstorage');
      if (favoritStorage) {
        // Ellenőrizzük, hogy a favoritstorage már tartalmazza-e az extractedPath-t
        if (!favoritStorage.includes(extractedPath)) {
          // Ha nem tartalmazza, akkor hozzáadjuk az új címet egy új sorba
          const updatedFavoritStorage = `${favoritStorage}\n${extractedPath}`;
          localStorage.setItem('favoritstorage', updatedFavoritStorage);
          
          startTypingAnimation('paragraphId', 'divId', 'The new file path is entered in the favorites.');
          
          navigator.clipboard.writeText(''); // Clears the clipboard by writing an empty string
          
       setTimeout(function() {
              // Második funkció meghívása
              
              
              // Új könyv jelzésére
              newfavoritbookfirst = 1;
localStorage.setItem('newfavoritbookflag', newfavoritbookfirst);

newfavoritbookfirst = 12222; // Ez az érték nem lesz használva

// A localStorage-ból visszaolvassuk az értéket és hozzárendeljük a változóhoz
newfavoritbookfirst = localStorage.getItem('newfavoritbookflag');
//alert(newfavoritbookfirst); // Ez most az "1" értéket fogja kiírni

              
              localStorage.setItem('newbooktest', extractedPath);
              
              
                       playrefreshSound();
}, 2000);
    
          
        } else {
          // Ha már tartalmazza, akkor figyelmeztetjük a felhasználót
          //alert('This address is already in your favorites.');
          
          fadeInOutText('This address is already in your favorites', 32, 'rgba(220, 90, 110, 1)', 14);
          
          fadeInOutText(extractedPath, 12, 'rgba(230, 60, 10, 0.71)', 34);
          
          navigator.clipboard.writeText(''); // Clears the clipboard by writing an empty string
        }
      } else {
        // Ha még nincs favoritstorage, akkor létrehozzuk és beállítjuk az új címet
        localStorage.setItem('favoritstorage', extractedPath);
        
      }
    } else {
      //console.log('A "totaladdress" bejegyzés nem található a localStorage-ban.');
    }
  }, 1000); // Fél másodperc (500 ms) várakozás
}



  




        // betöltéskor clipboard vagy randomfavorit indítása

//   Ha az origcontent

document.addEventListener('DOMContentLoaded', () => {
	
/*
displayImage(
    ['share_1209667316.jpg', '1748939855156.jpg', '1748939781867.jpg'], // Több kép
    'shrink',
    50,
    30,
    50,
    50,
    6,
    '',
    24,
    'rgba(255, 0, 0, 1)'
);
*/


//displayImage('', 'shrink', 50, 30, 50, 50, 2, 'Stay cool', 34, 'rgba(65, 90, 170, 0.71)');









newfavoritbookfirst = parseInt(localStorage.getItem('newfavoritbookflag')); // parseInt() használata számra alakításhoz
//alert(newfavoritbookfirst);
//navigator.clipboard.writeText(''); // Clears the clipboard by writing an empty string
if (newfavoritbookfirst === 1) { // Most számokat hasonlítunk össze
  //alert(newfavoritbookfirst);
  newfavoritbookfirst = 0;
  localStorage.setItem('newfavoritbookflag', newfavoritbookfirst);
  newbookinFavorit();
}

	
	
	setTimeout(function() {
              // Második funkció meghívása
                       pastecheck();
}, 1000);






	
	
  function pastecheck() {
  if (navigator.clipboard) {
    navigator.clipboard.readText()
      .then(text => {
        if (text.length > 30) {
        	
        
        
        
    //if (text.includes('{') || text.includes('()')) {
           if (text.includes('∆') || text.includes('∆')) {
   
                        console.log('A curly brace or parentheses were found in the clipboard:', text);
                        console.log('This is likely JavaScript code. Running RandomFavorit...');
                        startTypingAnimation('paragraphId', 'divId', 'This is likely JavaScript code. The clipboard is deleted. Running RandomFavorit...');
                        navigator.clipboard.writeText(''); // Clears the clipboard by writing an empty string
                       

 console.log('Clipboard cleared successfully.');
                        RandomFavorit();
                        return; // Leállítjuk a funkciót
                    } 

if (text.includes(' --> ') || text.includes('-->')) {
	
	isSrt = 1;
  
            console.log('This appears to be an SRT file. Timecode separators -->');
            //alert('This appears to be an SRT file. Please be cautious when pasting.');
            
            console.log('Timecode separators were found in the clipboard:', text);
                        console.log('This appears to be an SRT file. Running srtConverter...');
                        
                        startTypingAnimation('paragraphId', 'divId', 'This appears to be an SRT file. Timecode separators Running srtConverter. Conversion done. Clipboard cleared successfully.');
                        navigator.clipboard.writeText('');  
//Clears the clipboard by writing an empty string
                       

 console.log('Clipboard cleared successfully.');
 
 //alert(text);
 
                       // srtConverter();
                      const srtText = text;
const lines = srtText.split('\n');
let result = '';
for (const line of lines) {
    if (!line.match(/^\d+$/) && !line.includes('-->')) {
        result += line + '\n';
    }
}
const finalResult = result.trim();
text = finalResult;

let words = finalResult.split(' ');
let pointCount = 0;
for (let i = 0; i < words.length; i++) {
    if (words[i].includes('.')) {
        pointCount++;
    }
}
if (pointCount < 3) {
    for (let i = 0; i < words.length; i++) {
        if (i % 15 === 0) {
            words[i] += '.';
        }
    }
}
text = words.join(' ');
                       
                       
                       
                       
                       // return; // Leállítjuk a funkciót
            
            
            
          }


else {
                        console.log('No curly braces or parentheses found in the clipboard.');
                    }
        
        
        





        
    
        
        
        
        
          const origcontent = text;
          //alert(`Clipboard content: ${origcontent}`);
          //ide typescript info karakterszám, loading content
          window.origcontent = origcontent;
          
          legorigabbcontent = origcontent;
   // alert(origcontent);
   
          // bele a localstorage-ba
          // Először töröld a korábbi bejegyzést, ha létezik
localStorage.removeItem('webText');
// Majd mentsd el az új tartalmat
localStorage.setItem('webText', origcontent);

    pasteeeweb();
        
          
          
          
          
        } else {
          // Ide kerül a másik mód, ha nincs meg az 1000 karakter
          console.log('Clipboard content is less than 1000 characters');
          // Itt folytathatod a kívánt műveleteket
          
          
          
           
  RandomFavorit();


          
          
          //itt a dom clipboard vége
        }
      })
      .catch(err => {
        if (err.name === 'TypeError' && err.message.includes('Cannot read properties of null')) {
        //  console.error('Failed to read clipboard content: The clipboard is empty or not supported');
          console.log('Failed to read clipboard content: The clipboard is empty or not supported. Ez a clilboardhiba kezelése. Ezzel a módszerrel, ha a vágólap tartalma nem szöveg, vagy ha a böngésző nem támogatja a vágólap olvasását, akkor megjelenik egy hibaüzenet, és a funkció nem áll le.');
          
          //alert("itt a clilboardhiba kezelése, Ezzel a módszerrel, ha a vágólap tartalma nem szöveg, vagy ha a böngésző nem támogatja a vágólap olvasását, akkor megjelenik egy hibaüzenet, és a funkció nem áll le.");
          
          navigator.clipboard.writeText("");
          
          RandomFavorit();
          
        } else {
          console.error(`Failed to read clipboard content: ${err}`);
        }
      });
  } else {
    console.error('Clipboard API not supported');
  }
  
                }
  
});

     // itt a dom clipboard legvége


    // Favorit Randomindítás 

// Globális változó a fájl tartalmának tárolására
//let origcontent;


              
var randombooknumber;

async function RandomFavorit() {
  let existingEntries = localStorage.getItem('favoritstorage');
  if (existingEntries) {
    let txtEntries = existingEntries.split('\n').filter(line => line.endsWith('.txt'));
    
    //A randomEntry lesz ugye a kiválasztott sor. Ennek a sornak a száma kellene és kiírni egy alert-ba.
    if (txtEntries.length > 0) {
    let randomEntry = txtEntries[Math.floor(Math.random() * txtEntries.length)];
    await readTextFile(randomEntry);
    // Az alert hívás itt történik, miután a fájl beolvasása sikeres volt
    //alert(`Random entry: ${txtEntries.indexOf(randomEntry) + 1}`);
    
    randombooknumber = (`${txtEntries.indexOf(randomEntry) + 1}`);
    
    fadeInOutText(randombooknumber, 64, 'rgba(70, 40, 231, 1)', 47);
    bookfavoritindex = randombooknumber;
    
      // Az alert hívás itt történik, miután a fájl beolvasása sikeres volt
      //alert(origcontent);


// A localStorage-ban tároljuk a randomEntry értékét a 'readpathstorage' kulcs alatt ha kitörölnénk manuálisan
      localStorage.setItem('readpathstorage', randomEntry);



  bookname = randomEntry.substring(randomEntry.lastIndexOf("/") + 1);

  
// A bookname faszságai
// Nemkívánatos speciális karakterek
const undesiredSpecialChars = ['+', '-', '_', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];

// Tisztítás
let filteredContent = bookname.split('').map(char => undesiredSpecialChars.includes(char) ? ' ' : char).join('');

// Visszahelyezés a kiszedett karakterek helyére egy space-szel
bookname = filteredContent;
        
//alert(bookname);



      legorigabbcontent = origcontent;
            
                analysis();   // már itt lefut
            
                replaceSt();
                removeQuotes();  // idézőjel
                replaceMr();
                linebreakreplacement(); //savefilenak formázás
                
                let result = AIrecognizelanguage(origcontent);
                supervision();
                //console.log(result);
                
                
                // funkción belüli funkció következik
                
                
                
           //     bookname = (randomEntry + " clipboard");
      
      
      
  //    
      
      
           // minden nyitó és záró zárójel kiszedése a bookmark localstorage miatt, ez nem csere 
            bookname = bookname.replace(/[()]/g, '');
            
            
            console.log('File loaded successfully.');

            if (bookname) {
            	fadebookname(); // fadetext
                console.log('Book name:', bookname); // Ha létezik a bookname, kiírjuk a konzolba
            }
            countSentences();
            
      // idáig a core betöltése, és flawless!!! yeah
      
    }
  }
  
}








//firstbooktestnek
//var randombooknumber;

async function newbookinFavorit() {



	
  let existingEntries = localStorage.getItem('favoritstorage');
  if (existingEntries) {
    let txtEntries = existingEntries.split('\n').filter(line => line.endsWith('.txt'));
    
    // A randomEntry lesz a kiválasztott sor. Ennek a sornak a száma kellene és kiírni egy alert-ba.
    if (txtEntries.length > 0) {
      // Fájlútvonal kiválasztása a localStorage-ból
      let selectedEntry = localStorage.getItem('newbooktest');
      
      // Ellenőrizzük, hogy a kiválasztott fájl létezik-e a listában
      if (txtEntries.includes(selectedEntry)) {
        await readTextFile(selectedEntry);
        
        // Az alert hívás itt történik, miután a fájl beolvasása sikeres volt
        //alert(`Selected entry: ${txtEntries.indexOf(selectedEntry) + 1}`);
        alert(`new book`);
        
        
        // A localStorage-ban tároljuk a selectedEntry értékét a 'readpathstorage' kulcs alatt
        localStorage.setItem('readpathstorage', selectedEntry);

        bookname = selectedEntry.substring(selectedEntry.lastIndexOf("/") + 1);

        // A bookname faszságai
        // Nemkívánatos speciális karakterek
        const undesiredSpecialChars = ['+', '-', '_', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];

        // Tisztítás
        let filteredContent = bookname.split('').map(char => undesiredSpecialChars.includes(char) ? ' ' : char).join('');

        // Visszahelyezés a kiszedett karakterek helyére egy space-szel
        bookname = filteredContent;

        legorigabbcontent = origcontent;

        analysis();   // már itt lefut

        replaceSt();
        removeQuotes();  // idézőjel
        replaceMr();
        linebreakreplacement(); //savefilenak formázás

        let result = AIrecognizelanguage(origcontent);
        supervision();
        //console.log(result);

        // minden nyitó és záró zárójel kiszedése a bookmark localstorage miatt, ez nem csere 
        bookname = bookname.replace(/[()]/g, '');

        console.log('File loaded successfully.');

createButton('Delete Book', 'absolute', 300, 600, 'rgba(200,255,0,0.51)', 10101, function() {
    manualbookdelete2();
}, false);


        if (bookname) {
          fadebookname(); // fadetext
          console.log('Book name:', bookname); // Ha létezik a bookname, kiírjuk a konzolba
        }
        countSentences();

      } else {
        console.error('A kiválasztott fájl nem található a listában.');
      }
    }
  }
}





async function readTextFile(filePath) {
  try {
    const response = await fetch(filePath);
    if (!response.ok) {
    	
    fadeInOutText('No File found!', 38, 'rgba(220, 60, 20, 1)', 5);
    	manualbookdelete();
    return;
    
    // ezek már nem kellenek...
      throw new Error(`A fájl nem található: ${filePath}`);
    }
    origcontent = await response.text();
    //console.log(origcontent);
  } catch (error) {
    console.error(error.message);
    
    // EGY NAGY TÖRLÉS IDE HA NINCS ILYEN FILE
    alert('Ez egy randomindítási error, Nincs File!');
    
         	//playRandomSound20();
        // Ha a fájl beolvasása nem sikerül, jelenítsen meg egy alertet
        alert('Nem sikerült beolvasni a fájlt: ' + filePath);
        alert('Favoritból törlésre kerül: ' + filePath);
        
        
        
        
// Delete favorit line
        
        	//alert('deleteline');
	//alert(filePath);
    // A 'favoritstorage' bejegyzés tartalmának kiolvasása a 'localStorage'-ból
    let favoritContent = localStorage.getItem('favoritstorage');

    // Ellenőrizze, hogy a tartalom nem üres
    if (favoritContent) {
        // Szétválasztja a sorokat
        let lines = favoritContent.split('\n');

        // Keresse meg a filePath változóban levő sort
      //  let filePath = '...'; // Itt helyettesítse a tényleges értékkel
    //  alert(filePath);
        let indexToRemove = lines.findIndex(line => line.includes(filePath));

        if (indexToRemove !== -1) {
         
            lines.splice(indexToRemove, 1);


            // Frissítse a 'favoritstorage' bejegyzést a módosított tartalommal
            localStorage.setItem('favoritstorage', lines.join('\n'));

            // Felhasználó értesítése
            alert('A favorit sorok törlése megtörtént.');
            
            
            
            
            // bookname kinyerése a filepathból
            
            let fullPath = filePath;
           // alert(fullPath + ' fullPath');
        let readPath = fullPath.substring(fullPath.lastIndexOf('/') + 1); // Csak a fájl nevét tároljuk a readPath változóban
        bookname = readPath;
       // alert(bookname + ' bookname favoritcontentes');
        
        // itt nem booknamezünk, mert nem biztos hogy ki lesz választva
        //ezért
       // itt kel feltölteni local readpath
       localStorage.setItem('readpathstorage', readPath);
       
       
       
       
       
       
           // readPath = localStorage.getItem('readpathstorage');
            
            
            
        } else {
            alert('A megadott fájl nem található a kedvencek között.');
        }
    } else {
        alert('Nincs mentett kedvenc.');
    }
    
    // Delete vége
    
  //Delete rapidline is az oldalszámmal együtt
  
  
  // Load bookmarkrapidvar from local storage
 // var bookmarkrapidvar = localStorage.getItem("bookmarkrapid");

//var bookmarkrapidvar = localStorage.getItem("bookmarkrapid");



readPath = localStorage.getItem('readpathstorage');
bookname = readPath;
  // Display the bookmarkrapidvar content
  //alert('rapidline ' + bookmarkrapidvar);
  
  
//alert(bookname + ' rapidline');

  // Get the value of the bookname variable (replace with actual value)
 // var bookname = "..."; // Replace with the actual value

//alert(bookname);





  // Split the content into lines
      if (bookmarkrapidvar) {
  let lines = bookmarkrapidvar.split('\n');

  // Find the index of the line containing the bookname
  let indexToRemove = lines.findIndex(line => line.includes(bookname));

  if (indexToRemove !== -1) {
    // Remove the line containing the bookname
    lines.splice(indexToRemove, 1);

    // Also remove the next line (if it exists)
   // if (lines[indexToRemove]) {
      lines.splice(indexToRemove, 1);
   // }

    // Update the 'bookmarkrapid' entry in local storage
    localStorage.setItem('bookmarkrapid', lines.join('\n'));

    // Notify the user
    alert('A fasom sorok törlése megtörtént.');
    playrefreshSound();
    
  } else {
    alert('A megadott könyv nem található a listában.');
  }
  
      } else {
        alert('Nincs mentett kedvenc.');
    }

  // AZ OLDAL TELJES ÚJRATÖLTÉSE
  playrefreshSound();



    
    
    
    
  }
}

//RandomFavorit();

   // Favorit Randomindítás vége


   
     // betöltéskor clipboard -on van e youtube srt REWORD indítása

document.addEventListener('DOMContentLoaded', () => {
  if (navigator.clipboard) {
    navigator.clipboard.readText()
      .then(text => {
        if (text.length > 100) {
          if (text.includes('reword') || text.includes('rewording')) {
            console.log('rewording found in the clipboard');
            console.log('This is likely gpt formatting youReword text. Running gptformattingyouReword()...');
            
            //const youcontent = text; // Declare 'youcontent' variable and assign clipboard content to it
           // window.origcontent = youcontent;
            
            // Remove "reword" and "rewording" from the clipboard content
           // const youcontentclean = youcontent.replace(/\breword\b|\brewording\b/gi, '');
            
            
/*
EZ RÉGI XAR!            
function openLocalHTML() {
  var filePath = "/storage/emulated/0/work new/reader translator tts joy/html/lb16.html";

  fetch(filePath)
    .then(function(response) {
      return response.text();
    })
    .then(function(html) {
      var newWindow = window.open("", "_blank");
      newWindow.document.write(html);
    })
    .catch(function(error) {
      console.error("Error loading HTML file:", error);
    });
}
*/


// EZ GREAT!!!

async function openLocalHTML() {
  const filePath = "/storage/emulated/0/work new/reader translator tts joy/html/lb16.html";
  
  try {
    const response = await fetch(filePath);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const html = await response.text();
    const newWindow = window.open("", "_blank");
    
    // Biztonságosabb dokumentum írás
    newWindow.document.open();
    newWindow.document.write(html);
    newWindow.document.close();
    
    // Opcionális: URL beállítása tisztább megjelenésért
    // newWindow.history.replaceState(null, "", `data:text/html;charset=utf-8,${encodeURIComponent(html)}`);
    
  } catch (error) {
    console.error("Error loading HTML file:", error);
    // Felhasználó barátabb hibajelzés
    alert(`Failed to load the file: ${error.message}`);
  }
}

// Call the function to open the HTML file in a new window
openLocalHTML();

    
            
            return; // Stop the function execution
          } else {
            // Handle case when it's not gptformattingyouReword text
          }
        } else {
          console.log('Clipboard content is less than 100 characters');
          // Continue with other operations
        }
      })
      .catch(err => {
        console.error(`Failed to read clipboard content: ${err}`);
      });
  } else {
    console.error('Clipboard API not supported');
  }
})


     // itt a dom clipboard REWORD vége






function pasteeeweb() {
	
	
	
	firstdomload = 63246;//hogy arrowup ne olvassa fel a booksorszámot mert nincs is ennek
	
  if (localStorage.getItem('webText')) {
    origcontent = localStorage.getItem('webText');
    localStorage.removeItem('webText'); // Remove the 'webText' entry from localStorage
  }

legorigabbcontent = origcontent;
	//alert(origcontent);
	//alert(legorigabbcontent);

         // ez az egysoros szűrő itt nagyon effektív
         
  // Brutal Analysis Clipboardnak
  
  let fileName = origcontent.replace(/[^a-zA-Z0-9áéíóöőúüűÁÉÍÓÖŐÚÜŰ.,?!']+/g, ' ');
  origcontent = fileName;
  
  console.log("Brutal Analysis " + origcontent); 
  
  // ide jöhetne egy, ha sok pont egymásután akkor abban a sorban szóközre cserélő script
  
  //egy gyengébb szűrést is
    // Nemkívánatos speciális karakterek
    //const undesiredSpecialChars = ['+', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];
    //ez hosszabb geminis
    //const undesiredSpecialCharsBrutal = ['+', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~', '-', '_', ',', ':', ';', '°'];
const undesiredSpecialCharsBrutal = ['+', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~', '-', '_', ',', ':', ';', '°', '\n'];

    
    function filterSpecialChars(origcontent) {
  let filteredText = '';
  for (let i = 0; i < origcontent.length; i++) {
    const char = origcontent[i];
    if (!undesiredSpecialCharsBrutal.includes(char) || isHungarianAccent(char) || char === '?' || char === '!' || char === '.') {
      filteredText += char;
    }
  }
  return filteredText;
}

    function isHungarianAccent(char) {
  const hungarianAccents = ['á', 'é', 'í', 'ó', 'ö', 'ú', 'ű', 'Á', 'É', 'Í', 'Ó', 'Ö', 'Ú', 'Ű'];
  return hungarianAccents.includes(char);
}

//const inputText = "+Ez|egy=próba#string*magyar(ékezetekkel)?!";
const filteredText = filterSpecialChars(origcontent);
//console.log(filteredText); // Output: Ez egy próba string magyar ékezetekkel?!

origcontent = filteredText;

//alert(origcontent);
//console.log(origcontent);
    
                // tisztítás
  //   const filteredContent = filterSpecialCharacters(origcontent);
   //   origcontent = filteredContent; // replace the original content with

        
        
        
  
  
  
  
  
  
  analysis();
  //alert(origcontent);
//console.log(origcontent);

let sentenceCount = {};
  for (let i = 3; i <= 16; i++) {
    sentenceCount[i] = 0;
  }
  let sentences = origcontent.match(/[^\.!\?]+[\.!\?]+/g);

  for (let i = 0; i < sentences.length; i++) {
    let wordCount = sentences[i].split(' ').length;
    if (wordCount >= 3 && wordCount <= 16) {
      sentenceCount[wordCount]++;
    }
  }

  let sentenceCountString = '';
  for (let key in sentenceCount) {
    sentenceCountString += `Number of ${key}-word sentences: ${sentenceCount[key]}\n`;
  }

  let sentencePool = [];
  for (let key in sentenceCount) {
    for (let i = 0; i < sentenceCount[key]; i++) {
      sentencePool.push(...origcontent.match(/[^\.!\?]+[\.!\?]+/g).filter(sentence => sentence.split(' ').length === parseInt(key)));
    }
  }

  bookname = sentencePool[Math.floor(Math.random() * sentencePool.length)];

  // ha nincs csak egy szó lesz kiválasztva
  if (sentencePool.length === 0) {
    let words = origcontent.split(' ');
    bookname = words[Math.floor(Math.random() * words.length)];
  }

  // remove special character from end of bookname
  bookname = bookname.replace(/[?!.]$/, '');

//  console.log(`bookname: ${bookname}`);

  // display sentence count and bookname in alert dialog
  
  // hudba mehet
//  alert(`Sentence count:\n\n${sentenceCountString}bookname: ${bookname}`);
  
// A bookname faszságai
// Nemkívánatos speciális karakterek
const undesiredSpecialChars = ['+', '-', '_', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];

// Tisztítás
let filteredContent = bookname.split('').map(char => undesiredSpecialChars.includes(char) ? ' ' : char).join('');

// Visszahelyezés a kiszedett karakterek helyére egy space-szel
bookname = filteredContent + ' clipboard';

//ha srt lenne a tartalom

if (isSrt === 1) {
	
	bookname = generateFilename(origcontent);
	//alert(bookname);
	isSrt = 0;
	}

function generateFilename(origcontent) {
            const words = origcontent.trim().split(' ');
            return `${words[0]} ${words[1]} ${words[2]} ${words[3]} ${words[4]} ${words[5]} ${words[6]} ${words[7]} ${words[8]} ${words[9]} srtTotxt`;
        }


//alert(bookname);



//bookNameSelector();
//bookname = 'aaaccc';

//ez kikomment mert nem ez a legorigabb most
//  legorigabbcontent = origcontent;  

//alert(origcontent);

  analysis();

  replaceSt();
  removeQuotes();
  replaceMr();
  linebreakreplacement();

  let result = AIrecognizelanguage(origcontent);
  supervision();
  //console.log(result);
analyseStatistic();
  bookname = bookname.replace(/[()]/g, '');

  console.log('Clipboard loaded and cleared successfully.');
  //alert('Clipboard cleared successfully.');
  
  
  
navigator.clipboard.writeText(''); // Clears the clipboard by writing an empty string




  startTypingAnimation('paragraphId', 'divId', 'Clipboard loaded and cleared successfully.');
  
  
  
  
  if (bookname) {
    fadebookname();
    console.log('Book name:', bookname);
  }

  countSentences();
}





function analyseStatistic() {
  const charCount = origcontent.length;
  const wordCount = origcontent.trim().split(/\s+/).length;
  //const sentenceCount = origcontent.match(/[.!?]+/g)?.length || 0;
  let sentences = origcontent.match(/[^.!?]+(?:\.|!|\?)(?=\s|$)/g);
        allsentencenumber = sentences.length; // Beállítjuk a mondatok számát a változó értékének
        console.log('Sentence count:', allsentencenumber);
// xar mindig 1, const paragraphCount = origcontent.split(/\n\s*\n/).filter(paragraph => paragraph.trim().length > 0).length;
  const questionMarkCount = (origcontent.match(/[?]+/g) || []).length;
  const exclamationMarkCount = (origcontent.match(/[!]+/g) || []).length;

//hudba mehet
  console.log('Character count:', charCount);
  console.log('Word count:', wordCount);
  
//  console.log('Paragraph count:', paragraphCount);
  console.log('Question mark count:', questionMarkCount);
  console.log('Exclamation mark count:', exclamationMarkCount);
  
}


function bookNameSelector() {
  
}

// Now you can access the bookname variable globally after calling the bookNameSelector function.
//bookNameSelector();
//console.log(bookname);








// nem szükséges minden paste szöveget tárolni a bookmarkban ezért törlés, ha van benne " clipboard"



        document.getElementById('fileInput').addEventListener('change', function() {
    const file = this.files[0];
    const reader = new FileReader();
    reader.onload = function(e) {
        origcontent = e.target.result;
        if (reader.readyState === 2) { // Ellenőrizzük, hogy a fájl beolvasása befejeződött-e
            if (file.type === 'text/plain') {
            	
            firstdomload = 63246;//hogy arrowup ne olvassa fel a booksorszámot mert nincs is ennek
            
//alert();
toggleFullscreen();
            
            	legorigabbcontent = origcontent;
            
                         analysis();   // már itt lefut
            
                replaceSt();
                removeQuotes();  // idézőjel
                replaceMr();
                linebreakreplacement(); //savefilenak formázás
                
                let result = AIrecognizelanguage(origcontent);
                supervision();
                //console.log(result);
                
                
                
                
            } else {
                alert('Csak txt fájlokat tölthet fel!');
            }
            bookname = file.name;
            
            
// A bookname faszságai
// Nemkívánatos speciális karakterek
const undesiredSpecialChars = ['+', '-', '_', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];

// Tisztítás
let filteredContent = bookname.split('').map(char => undesiredSpecialChars.includes(char) ? ' ' : char).join('');

// Visszahelyezés a kiszedett karakterek helyére egy space-szel
bookname = filteredContent;
        
//alert(bookname);



let lapozzSzavakSzama = 0;

let readPath = origcontent;

 // "lapozz" szavak számolása
        let szavak = readPath.split(" ");
        for (let j = 0; j < szavak.length; j++) {
            if (szavak[j] === "lapozz") {
                lapozzSzavakSzama++;
            }
        }
        // "Lapozz" szavak számolása
        for (let j = 0; j < szavak.length; j++) {
            if (szavak[j] === "Lapozz") {
                lapozzSzavakSzama++;
            }
        }


        
        //alert(lapozzSzavakSzama);
        if (lapozzSzavakSzama > 15) {
            ezkjkkonyv = 1;
            nyusziin();
            fadeInOutText('Kaland Játék Kockázat könyv', 30, 'rgba(220, 60, 220, 0.61)', 5);
            
            
            
            
            
        }
        

        
        
        
        

            
            
            
            
            
            
            
            
            
            // minden nyitó és záró zárójel kiszedése a bookmark localstorage miatt, ez nem csere 
            bookname = bookname.replace(/[()]/g, '');
            
            
            console.log('File loaded successfully.');

            if (bookname) {
            	fadebookname(); // fadetext
                console.log('Book name:', bookname); // Ha létezik a bookname, kiírjuk a konzolba
            }
            countSentences();
        }
    };
    reader.readAsText(file);
});


/*
                                             A SPECIÁLIS FASZSÁGOK
                   az idézőjelek zavarhatják a jávascriptet és a mondatokra bontást is
 */

             // kiszed minden szart
                    // kiszed minden szart
                           // kiszed minden szart

function analysisnemkerdez() {
   
        // tisztítás
     const filteredContent = filterSpecialCharacters(origcontent);
      origcontent = filteredContent; // replace the original content with

   
}

function analysis() {   // ezen a soron ne változtass, az összes többin változtass, hogy működjön. Az origcontent már globálisan adott változó.

stopMusic();
stopPlayany();
        
        
    // Kívánatos speciális karakterek
    const desiredSpecialChars = ['?', '!', '.', ',', '\n'];
    // Nemkívánatos speciális karakterek
    const undesiredSpecialChars = ['+', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];
    
    let undesiredCharCount = 0;
    
    // Számolja meg a nemkívánatos speciális karaktereket
    for (let i = 0; i < origcontent.length; i++) {
        if (undesiredSpecialChars.includes(origcontent[i])) {
            undesiredCharCount++;
        }
    }
    
    // Számolja ki az eredeti tartalom 0.015%-át
    const threshold = origcontent.length * 0.00015;
    
    // Értesítse a felhasználót, ha a limitet túllépték
    if (undesiredCharCount > threshold) {
        console.log('Analysis Figyelem: A nemkívánatos speciális karakterek száma meghaladja az eredeti tartalom 0.015%-át.' + bookname);
        
                // tisztítás
     const filteredContent = filterSpecialCharacters(origcontent);
      origcontent = filteredContent; // replace the original content with

        
        
    } else {
        console.log('Az eredeti tartalom megfelelő.');
    }
}




function removeQuotes() {
    // Eredeti szöveg
    //var origcontent = 'This is a "quoted" text with "multiple" quotes.';

    // Idézőjelek eltávolítása
    origcontent = origcontent.replace(/"/g, '');
    origcontent = origcontent.replace(/”/g, '');
    origcontent = origcontent.replace(/“/g, '');



    // Eredeti és tisztított szöveg kiíratása
    //console.log("Eredeti szöveg: " + origcontent);
    //console.log("Tisztított szöveg: " + clearcontent);
}








function filterSpecialCharacters(str) {
  const allowedCharacters = new Set(
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 .?!',áéíóöőúüűÁÉÍÓÖŐÚÜŰ\t\n"
  );

  let filteredString = "";

  for (let i = 0; i < str.length; i++) {
    if (allowedCharacters.has(str[i])) {
      filteredString += str[i];
    }
  }

  return filteredString;
}









function replaceMr() {
    origcontent = origcontent.replace(/Mr./g, 'Mister');
    origcontent = origcontent.replace(/Mrs./g, 'Misses');
    origcontent = origcontent.replace(/Ms./g, 'Miss');
    origcontent = origcontent.replace(/\bDr\./g, 'doctor');
    origcontent = origcontent.replace(/\bdr\./g, 'doctor'); //ez yo de sajna nem mindenhol
    //origcontent = origcontent.replace(/ dr./g, 'doctor'); ez nem yo
    
       //speciál perjelt spacera de annyira nem is zavar
     origcontent = origcontent.replace(/[\/\\]/g, ', ');
    
    //origcontent = origcontent.replace(/am./g, 'forenoon');
    //origcontent = origcontent.replace(/ am./g, 'forenoon'); sajna magyarfodításkor zavar
    //origcontent = origcontent.replace(/a.m./g, 'forenoon');
    //origcontent = origcontent.replace(/ a.m./g, 'forenoon');
    //origcontent = origcontent.replace(/AM /g, 'forenoon'); magyarfordításkor zavar
    
   // origcontent = origcontent.replace(/pm./g, 'afternoon');
  //  origcontent = origcontent.replace(/ pm./g, 'afternoon');
   // origcontent = origcontent.replace(/p.m./g, 'afternoon');
   // origcontent = origcontent.replace(/ p.m./g, 'afternoon');
   // origcontent = origcontent.replace(/PM /g, 'afternoon');
    
}

function replaceSt() {
    origcontent = origcontent.replace(/St. /g, 'saintorstreet ');
    //origcontent = origcontent.replace(/st. /g, 'saintorstreet ')
}

// savefilenak kis formázás
function linebreakreplacement() {
    origcontent = origcontent.replace(/(\r\n|\n)/gm, ' ');
   // origcontent = origcontent.replace(/nevezik/g, 'újSzó');
}

function insertLineBreaks(content) {
  const words = content.split(" ");
  const lineBreakedWords = [];
  let wordCount = 0;
  for (const word of words) {
    lineBreakedWords.push(word);
    wordCount++;
    if (wordCount % 10 === 0) {
      lineBreakedWords.push("\n"); // this will work on all systems
    }
    if (wordCount < words.length && wordCount % 10 !== 0) {
      lineBreakedWords.push(" ");
    }
  }
  return lineBreakedWords.join("");
}





// ITT FOGOM FOLYTATNIIIIIII
function selectclean() {
 
    // eltávolítása
//    origcontent = origcontent.replace(/z/g, '');


}




// ez rohadtul nem pontos arrgh




var findword
findword = ("when");

function findandcountSentences() {
	
	analysis();   // már itt lefut
            
                replaceSt();
                removeQuotes();  // idézőjel
                replaceMr();
                linebreakreplacement(); //savefilenak formázás
                
                let result = AIrecognizelanguage(origcontent);
	
	
	
    if (origcontent) {
        let sentences = origcontent.match(/[^.!?]+(?:\.||\?)(?=\s|$)/g);
        allsentencenumber = sentences.length; // Beállítjuk a mondatok számát a változó értékének
        console.log('Number of Sentences:', allsentencenumber);
        for (let i = 0; i < sentences.length; i++) {
            let sentence = sentences[i];
            if (sentence.includes(findword)) {
                console.log(`Sentence ${i + 1}: ${sentence}`);
            }
        }
    }
}










        function countSentences() {
    if (origcontent) {
        let sentences = origcontent.match(/[^.!?]+(?:\.|!|\?)(?=\s|$)/g);
        allsentencenumber = sentences.length; // Beállítjuk a mondatok számát a változó értékének
        console.log('Number of Sentences:', allsentencenumber);
        displaysentence = sentences[currentsentencenumber - 1]; // Kiválasztjuk a megfelelő sorszámú mondatot
    }
}



document.getElementById('okButton').addEventListener('click', function() {
    origcontent = document.getElementById('bigInput').value;
    if (origcontent) {
    	
        legorigabbcontent = origcontent;
    
        analysis(); // már itt lefut
    
        replaceSt();
        removeQuotes();
        replaceMr();
        linebreakreplacement(); //savefilenak formázás
        
        let result = AIrecognizelanguage(origcontent);
        
        //console.log(result);
        
        
        
        
        // bookname választás ez random
        let sentences = origcontent.match(/[^.!?]+(?:\.|!|\?)(?=\s|$)/g);
if (sentences) {
    let randomIndex = Math.floor(Math.random() * sentences.length);
    bookname = sentences[randomIndex].trim();

    let cleanFilename = bookname.replace(/[^\w\s]/gi, '');
    bookname = cleanFilename;
    //console.log('Cleaned Book Name:', cleanFilename);
    //console.log(bookname);
    //fadebookname();
    countSentences();
    bookname = bookname.split(' ').slice(0, 6).join(' ') + ' clipboard';
    fadebookname();
    //countSentences();
    
      supervision();
      
        } else {
            console.log('No sentences found in the input content.');
        }
    }
    
  //  console.log("continyuje");
    //alert("continyuje");
    
});


document.getElementById('bigInput').addEventListener('input', function() {
    // Az origcontent értékét a gomb lenyomásakor állítjuk be
    
    
});


/*
// régi nemkell
        document.getElementById('bigInput').addEventListener('input', function() {
    if (origcontent) {
    	replaceSt();
        removeQuotes();
        replaceMr();
        
        let result = AIrecognizelanguage(origcontent);
        //console.log(result);
        analysis();
        let sentences = origcontent.match(/[^.!?]+(?:\.|!|\?)(?=\s|$)/g);
        if (sentences) {
            let randomIndex = Math.floor(Math.random() * sentences.length);
            bookname = sentences[randomIndex].trim();

            let cleanFilename = bookname.replace(/[^\w\s]/gi, '');
            bookname = cleanFilename;
            //console.log('Cleaned Book Name:', cleanFilename);
            //console.log(bookname);
            fadebookname();
            countSentences();
        } else {
            //console.log('No sentences found in the input content.');
        }
    }
})

*/

        document.getElementById('TheSlider').addEventListener('input', function() {
    let sliderValue = parseInt(this.value);
    let maxSliderValue = parseInt(this.max);

    currentsentencenumber = Math.min(Math.floor(sliderValue * (allsentencenumber / maxSliderValue)) + 1, allsentencenumber);

    if (origcontent) {
        //let cleanedText = origcontent;
        let sentences = origcontent.match(/[^.!?]+(?:\.|!|\?)(?=\s|$)/g); // Alakítsa mondatokra a tisztított szöveget

        if (sentences && sentences.length > 0) {
            displaysentence = sentences[currentsentencenumber - 1]; // Kiválasztja a megfelelő sorszámú mondatot
            document.getElementById('selectedtextblock').innerText = displaysentence; // Megjeleníti a kiválasztott mondatot
        }
        
        
               if (sentences && sentences.length > 0) {
            let startIndex = Math.max(0, currentsentencenumber - 3); // Az előtte levő két mondat indexe
            let endIndex = Math.min(sentences.length, currentsentencenumber + 2); // Az utána levő két mondat indexe

            let contextText = sentences.slice(startIndex, endIndex).join(' '); // Az összes releváns mondat összefűzése

            document.getElementById('contextblock').innerText = contextText; // Megjeleníti az összes releváns mondatot a contextblock-ban
        }

    }
});

const slider = document.getElementById('TheSlider');
        const counter = document.getElementById('counter');
        
        

slider.addEventListener('input', function() {
    let sliderValue = parseInt(this.value);
    let maxSliderValue = parseInt(this.max);

    if (sliderValue < 2) {
        //currentsentencenumber = 1; // Ha a slider értéke kisebb, mint 5, akkor a mondat sorszáma legyen 1
        //displaysentence = getSelectedSentence(currentsentencenumber); // Az első mondat lekérése
        //document.getElementById('selectedtextblock').innerText = displaysentence; // Az első mondat megjelenítése a selectedtextblock-ban
       // document.getElementById('contextblock').innerText = displaysentence; // Az első mondat megjelenítése a contextblock-ban is
    } else {
        currentsentencenumber = Math.min(Math.floor(sliderValue * (allsentencenumber / maxSliderValue)) + 1, allsentencenumber);
    }

    counter.textContent = currentsentencenumber; // Frissítjük a számlálót az új mondat sorszámával
});

        slider.addEventListener('input', function() {
            counter.textContent = currentsentencenumber;
        });

//slider currentre pozicionálás
function setSliderToCurrentSentence() {
    let slider = document.getElementById('TheSlider');
    let maxSliderValue = parseInt(slider.max);

    let sliderValue = Math.floor((currentsentencenumber - 1) / allsentencenumber * maxSliderValue);
    slider.value = sliderValue;
}



/* 
vannak ilyen kódok:
document.addEventListener('keydown', function(event) {
    if (event.key === '0') {
    	...
    
Ezek ki és bekapcsolására kell két funkció.
*/



  
  
  

function readRadioText(text) {
  if (!window.speechSynthesis) return;

  const originalVolume = radioAudio ? radioAudio.volume : 0.5;

  // Hangerő csökkentése
  if (radioAudio) radioAudio.volume = 0.062;

  const utterance = new SpeechSynthesisUtterance(text);

  // Véletlenszerű sebesség 0.6 és 1.0 között
  utterance.rate = Math.random() * 0.4 + 0.6;

  utterance.onend = function() {
    // Felolvasás vége, hangerő visszaállítása
    if (radioAudio) radioAudio.volume = originalVolume;
  };

  window.speechSynthesis.speak(utterance);
}





function enableKeydownListener() {
  document.addEventListener('keydown', handleKeydown);
}

function disableKeydownListener() {
  document.removeEventListener('keydown', handleKeydown);
}


// Billentyűleütések figyelésének engedélyezése
enableKeydownListener();

// Billentyűleütések figyelésének letiltása
//disableKeydownListener();

/// új funkcióknak, ki- vagy bekapcsolhatod a meglévő billentyűfigyelést, és így például egy adott gombhoz új feladatot adhatsz, miközben a régi feladat nem fut

let keyListenerActive = true; // Ez jelzi, hogy figyelünk-e a billentyűkre

// Funkció a billentyűfigyelés kikapcsolására
function disableKeyListener() {
  keyListenerActive = false;
  console.log('Billentyűfigyelés kikapcsolva');
}

// Funkció a billentyűfigyelés bekapcsolására
function enableKeyListener() {
  keyListenerActive = true;
  console.log('Billentyűfigyelés bekapcsolva');
}


/// ez a biginputnak no listener

const bigInput = document.getElementById('bigInput');

// Kezdetben engedélyezzük a globális keydown listenert
enableKeydownListener();

// Ha az input fókuszba kerül, tiltsuk le a globális keydown listenert
bigInput.addEventListener('focus', () => {
  disableKeydownListener();
});

// Ha az input fókusz elveszik, engedélyezzük újra a globális keydown listenert
bigInput.addEventListener('blur', () => {
  enableKeydownListener();
});



/*

// Új feladat, amihez előbb letiltjuk a régi figyelést
function assignNewTaskToKey() {
  disableKeyListener();

  // Például az 'a' gomb új funkciója
  document.addEventListener('keydown', function newTaskHandler(event) {
    if (event.key === 'a') {
      console.log('Az új "a" gomb funkció fut');
      // Ha már nem kell az új feladat, eltávolíthatjuk a listener-t és visszakapcsolhatjuk az eredetit
      document.removeEventListener('keydown', newTaskHandler);
      enableKeyListener();
    }
  });
}

// Meghívhatod ezt a függvényt, amikor szeretnéd az új feladatot hozzárendelni
// assignNewTaskToKey();

*/

function randombooknewmenube() {
  hatterradiogombra();
  stopSpeaking();
  // randomBooknewAndrandomsentence();
  randomBooknew();
  setTimeout(randomSentence, 6000);
  setTimeout(readTextinfinite, 6000);
}

  









// ------- buttons  buttonok

let isNumberSelectorActive = false;
let numbers = [];
let selectedNumberIndex = 0;
let numbersContainer = null;

function handleKeydown(event) {
  if (isNumberSelectorActive) {
    // Számválasztó aktív, a d és a gombok léptetnek, az 1 gomb aktivál
    if (event.key === 'd') {
      // Jobbra lépés a számok között
      selectedNumberIndex = (selectedNumberIndex + 1) % numbers.length;
      updateNumberButtonsHighlight();
      event.preventDefault();
      return;
    } else if (event.key === 'a') {
      // Balra lépés a számok között
      selectedNumberIndex = (selectedNumberIndex - 1 + numbers.length) % numbers.length;
      updateNumberButtonsHighlight();
      event.preventDefault();
      return;
    } else if (event.key === '1') {
      // Aktiválás (ugrás)
      if (numbersContainer) {
        // Kiválasztott szám gombjának kattintás szimulálása
        const buttons = numbersContainer.querySelectorAll('button');
        if (buttons[selectedNumberIndex]) {
          buttons[selectedNumberIndex].click();
        }
      }
      event.preventDefault();
      return;
    }
  }
  
  if (event.key === '8') {
    marqueaiebookname();
    closeReadTextInfiniteOptionsModal();

    favcontclose();
    closeNewsDisplayContainer();

    // Megjelenítjük a buborékot, ami a kisablakot nyitja meg kattintásra
    showBubble(
        "háttérzene touch setup", 
        "rgb(51,51,51,0.1)", 
        [150, 550], 
        null, 
        openOptionsPopup,  // buborék onclick-ként az új kisablak nyitó funkciója
        6000
    );

    // Meghívjuk az eredeti opciós gomb funkciót, ha kell
    optionsApopupButtonFunction();

    stopSpelling();
    stopSpeaking();
    stopzagor();
    stopmanualfavoritdelete();

    muteSounds = JSON.parse(localStorage.getItem("muteSounds"));
    if (muteSounds) {
        stopMusic();
        stopPlayany();
        muteRadio();
    }

    keyPressCount1 = 0;
    keyPressCount3 = 0;
} else if (event.key === '1') {
    	


if (holdopened === 1) {
	bookname = "archive";
//alert(bookname);

            holdDown();
            return;
}

const container = document.getElementById('newsDisplayContainer');
  if (container) {
  	
    stopSpeechSynthesis();
      showPreviousArticle();
      return;
  }

        stopSpeaking(); 
        keyPressCount1 += 1; // Increment keyPressCount
        
        
        if (optionsopen === 1) {
            if (keyPressCount1 >= 2) {
                downfavoritLoad();
                lover();
            } else {
                togglefavoritLoadPopup();
                //keyPressCount1 = 0; // Reset keyPressCount
            }
        } else if (optionsopen === 0) {
        	 if (instanttranslate === 1) 
          {
                
                          // Első funkció meghívása
                       one();
                       stopSpeaking(); 
                // Fél másodperc várakozás
                    setTimeout(function() {
              // Második funkció meghívása
                       two();
}, 100);
                   return;
                   
                                        }
            one();
        }
    } else if (event.key === '2') {
    	
    if (holdopened === 1 && optionsopen === 0) {
    holdopened = 0;
    bookname = "archive";
    stopSpeaking(); 
    holdSelect();
    return;
}

    
    if (optionsopen === 1  && favoritlistopen === 0) {
            stopSpeaking(); 
            
            hold();
            return;
        }
    
    	//favcontclose();
    //colorful();
    
        stopSpeaking(); 
        
        if (optionsopen === 1 && favpopuploadForJoy1 === 1) {
            selectfavoritLoadBlind();
            optionsApopupButtonFunction();
            favcontclose();
            
            setTimeout(bookpercent, 3000);
setTimeout(four, 4000);


        } else if (optionsopen === 0) {
            two();
        }
    } else if (event.key === '3') {
    	
    //smallprompt();
    
    
    if (holdopened === 1) {
            holdUp();
            return;
}

let container = document.getElementById('newsDisplayContainer');
if (container) {
  stopSpeechSynthesis();
  showNextArticle();
  return;
}

container = document.getElementById('googleSearchResultsContainer');
if (container) {
  stopSpeechSynthesis123();
  showNextSearchResult123();
  return;
}


        stopSpeaking(); 
       
       
       if (optionsopen === 1 && favoritlistopen === 1) {
    	stopSpeaking(); 
    
    upfavoritLoad();
    }
       
        if (optionsopen === 1 && favoritlistopen === 0) {
            stopSpeaking(); 
            
            
            keyPressCount3 += 1; // Növeld a nyomásszámlálót

if (keyPressCount3 === 1) {
    // Első nyomás
    console.log("Első nyomás - infogomb() hívása");
    infogomb();
} else if (keyPressCount3 === 2) {
    // Második nyomás
    console.log("Második nyomás - infogomb() hívása");
    weathernow();
                weather3();
} else if (keyPressCount3 === 3) {
    // Harmadik nyomás
    console.log("Harmadik nyomás - weathernow() és weather3() hívása");
    fetchAndReadWeather('Nagykáta');
    keyPressCount3 = 0; // Visszaállítjuk 0-ra, hogy újra kezdődjön a számlálás
} else {
    // Biztonsági ág, ha valamiért nagyobb lenne a számláló
    keyPressCount3 = 0;
}

            
            
        } else if (optionsopen === 0) {
        	 if (instanttranslate === 1) 
          {
                   // Első funkció meghívása
                       three();
                       stopSpeaking(); 
                // Fél másodperc várakozás
                    setTimeout(function() {
              // Második funkció meghívása
                       two();
}, 100);
                
                   return;
                   
                                        }
            three();
            bookmarksave();
        }
    } else if (event.key === '4') {
    	
   stopMusic();
stopPlayany();
    
        stopSpeaking(); 
        
        if (optionsopen === 1) {
            stopSpeaking(); 
            let popup = document.getElementById('popup');
    if (popup.style.display === 'block') {
    	playRandomSound6();
    
    	optionsopen = 0;
        popup.style.display = 'none'; // Ha látható, akkor elrejtjük
        //meg a többi ablakot is bezárjuk
            favoritPopup.style.display = 'none'; // Elrejti a popup ablakot
            currentFavoritIndex = 0;
            stopMusic();
            stopPlayany();
            searchclose();
        
        }
            recognition.start();
            return;
        }
        
        
        
          if (first4shot === 1) {
          	first4shot = 0;
  	playany(['snd/button/Free Switch Sound Effect Download SFX MP3 Library Soundsnap.mp3', 'snd/button/Page 2 Switch Soundsnap.mp3'], 1);
  
  //enterFullscreen();
  }
        
        four();
    } else if (event.key === '5') {
    	
    if (optionsopen === 1) {
    //	alert();
    
    userbookmarksave();
    return;
    }
    
        stopSpeaking(); 
        wordread2();
    } else if (event.key === 'Enter') {
    	
   hatterradiogombra();
    	
        stopSpeaking();
     //   randomBooknewAndrandomsentence();
     randomBooknew();
        setTimeout(randomSentence, 6000);
        //setTimeout(readTextinfinite, 6000);

        
    } else if (event.key === '6') {
    	

if (optionsopen === 1) {
    userbookmarkload();
    return;
    }


       stopSpeaking(); 
       //slowextraText();
       
       gamePlaySound(['snd/Data Alert Digi GFX019208.mp3', 'snd/Data Alert Digi GFX019208.mp3'], 1);
 readTextinfinite();  
   
       showBubble(
  "Delay options touch",
  "rgba(33,150,243,0.9)",
  [null, 40],
  null,
  () => readtextinfiniteoptionsmodal(), // itt csak a függvényt adjuk át, nem hívjuk meg azonnal
  6000,
  false
);
       //haromszorepeat();
       //ok de kell a button
       
    } else if (event.key === '0') {
        stopSpeaking(); 
        
        
        //return;
        
            if (optionsopen === 1) {
            instanTTranslate();
        } else if (optionsopen === 0) {
            //wordread();
            startTypingAnimation('paragraphId', 'divId', 'speak');
         // kép
displayImage(
    ['1753348756089.jpg', '1753348717775.jpg'], // Több kép
    'shrink',
    50,
    30,
    50,
    50,
    4,
    '',
    24,
    'rgba(255, 0, 0, 1)'
);

    	 recognition.start();
    	// recognition.start();
        }
        
    } else if (event.key === '7') {
    	
    
    if (optionsopen === 1) {
        	
            stopSpeaking(); 
            let popup = document.getElementById('popup');
    if (popup.style.display === 'block') {
    	playRandomSound6();
    
    	optionsopen = 0;
        popup.style.display = 'none'; // Ha látható, akkor elrejtjük
        //meg a többi ablakot is bezárjuk
            favoritPopup.style.display = 'none'; // Elrejti a popup ablakot
            currentFavoritIndex = 0;
            stopMusic();
            stopPlayany();
            searchclose();
        
        }
            commandselectjoypad();
            return;
        }
    
    
    
    
    
        stopSpeaking(); 
            háromszóOlvasás();
            
           
            

    } else if (event.key === '9') {
    	
    if (optionsopen === 0) {
   gamePlaySound(['snd/Data Alert Digi GFX019208.mp3', 'snd/Data Alert Digi GFX019208.mp3'], 1);


                        
       	//randomSentence();
           
           randomSentenceV2();
       
    }
         if (optionsopen === 1) {
         	popup.style.display = 'none'; // Ha látható, akkor elrejtjük
        stopSpeaking();
        //randomBooknew();
        
        playrefreshSound();   // Az oldal teljes újratöltése
        }
        
    } 




else if (event.key === 's') {
    //Radio
    
    if (toggleFastRadio === 1) {
        fastradio();
    } else {
        // Állapot növelése
        sState = (sState + 1) % 3;

        // Az aktuális állapot alapján történő funkciók hívása
        switch (sState) {
            case 0:
                console.log("Állapot 0: Funkció 1");
                // Funkció 1 hívása
                stopRadio();
                break;
            case 1:
                console.log("Állapot 1: Funkció 2");
                // Funkció 2 hívása eza az elsooo
                playRadio();
                break;
            case 2:
                console.log("Állapot 2: Funkció 3");
                // Funkció 3 hívása
                halkRadio();
                break;
        }
    }
    
    
    
} else if (event.key === 'w') {
    	
        stopSpeaking(); 
       // alert(bookname);
        fadebookname();
        updateCanvasSize(); // Set initial size
            showSpeedometer(); // Call the function to show the speedometer
        
        
        if (nyuszino === 0) {
        userbookmarksave();
        return;
        }
        
        
        
        if (radioplayer === 1) {
  stopSpeaking();

  var textToRead = radioado;

  // Ezt a dedikált funkciót hívd, nem a readanytexthun-t
  readRadioText(textToRead);

  stopClearFadeinoutText();

  fadeInOutTextBlink(labelText, 34, 'rgba(200, 0, 110, 1)', 50, 555);
}

        
        
        
        
        // mondatszámok per
        var textToRead2 = (currentsentencenumber + " per " + allsentencenumber + " mondat.") ;
        var lang = 'hu-HUN';
        var audio2 = new SpeechSynthesisUtterance(textToRead2);
        audio2.lang = lang;
        audio2.rate = 0.8;
        audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
        audio2.pitch = 1.0;
        speechSynthesis.speak(audio2);

        //recognition.start();
        hanyora();
        //dpadup();
        let readpercentage = Math.round((currentsentencenumber / allsentencenumber) * 100);
        readpercentage = (readpercentage + " percent");
     //   console.log(readpercentage); 
        var textToRead2 = readpercentage;
        var lang2 = 'en-ENG';
        var audio2 = new SpeechSynthesisUtterance(textToRead2);
        audio2.lang = lang2;
        audio2.rate = 0.8;
        audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
        audio2.pitch = 1.0;
     //   speechSynthesis.speak(audio2);
        // csak fun
        readany = ("yeah."); // lehet funkción kívül, de a funkció nevekre figyelni és Buttonkell
    //    readanytext();
        //titletranslate();
        
        
        
        
        
                  //alert(firstdomload);
           if (firstdomload === 1) {
	//firstdomload = 0;
           //alert(randombooknumber);
console.log('BookIndex: ' + randombooknumber);
fadeInOutText(randombooknumber, 64, 'rgba(70, 40, 231, 1)', 47);

bookfavoritindex = randombooknumber;
var textToRead3 = (randombooknumber + ' ');
var audio3 = new SpeechSynthesisUtterance(textToRead3);
    speechSynthesis.speak(audio3);
    }
    
    else if (firstdomload === 0) {
    	console.log('Current Favorite Index: ' + (currentFavoritIndex + 1));
    bookfavoritindex = (currentFavoritIndex + 1);
  //fadeInOutText(randombooknumber, 64, 'rgba(70, 40, 231, 1)', 47);
var textToRead3 = (currentbooknumber + ' ');
var audio3 = new SpeechSynthesisUtterance(textToRead3);
    speechSynthesis.speak(audio3);
    }
    
    else if (firstdomload === 3) {
    	console.log('Current Favorite Index: ' + (currentFavoritIndex + 1));
    bookfavoritindex = (currentFavoritIndex + 1);
    
var textToRead3 = (currentbooknumber + ' ');
var audio3 = new SpeechSynthesisUtterance(textToRead3);
    speechSynthesis.speak(audio3);
    }
    
    
    titletranslate();
           bookpercent();
          // four();
        
    }


else if (event.key === 'a') {
        dpadleft();
    }
    else if (event.key === 'd') {
        dpadright();
    }

}//handlekeydown vége






// analógok

var currentbooknumber;

document.addEventListener('keydown', function(event) {
    switch (event.code) {
    	
    case 'ArrowDown':
        
           // console.log('Lefelé');
           
           stopSpeaking(); 
           recognition.start();
            
           
            break;
    
    //ArrowUp tré analóg
        case 'ArrowUp':
        
           // console.log('Felfelé'); // Felfelé nyíl
           
 //tré
       
           
            break;
        
        case 'ArrowLeft':
            console.log('Balra'); // Balra nyíl
     
     
            break;
  case 'ArrowRight':
        
       // selectzagor();
        
            console.log('Jobbra'); // Jobbra nyíl
            break;
            
            
 case 'KeyJ':
            //console.log('J gomb balra jobbanalóg');  

            stopSpeaking(); 

        if (optionsopen === 1) 
       {
       // semmi
        	
        }
        else
        {
               if (winner === "hu") {
                const translateBtn = document.getElementById('translateBtn');
                translateBtn.click();
                middleslowextraText();
                
               } else {
                readrepeatText();
               }
         }
         
            break;
        case 'KeyL':
        
        if (kaland === true && optionsopen !== 1) {
       // kjkMultiJump();
        }
    
            console.log('L gomb'); // L gomb
            break;
        case 'KeyI':
            stopSpelling();
            
            initiateSpelling();
            break;
        case 'KeyK':
        stopSpeaking(); 
        
        if (optionsopen === 1) 
       {
       
       recognition.start();
        	
        }
        
        kjk();
        
        
            console.log('K gomb'); // K gomb
            break;
            
            
            
        case 'KeyG':
            console.log('G gomb'); // G gomb
            break;
        // Itt adhatsz hozzá további gombokat, ha szükséges
    }
});














//////////// onscreen buttonok

//írj joyonscreen2 funkciót tabletre. 20 kör alakú gombot rajzolj ki, oppacity 0.5 legyen. Mind a 20 gomb működjön (lenyomáskor mindegyiknek legyen saját funkciója) és legyenek elhelyezhetőek a képernyőn x y kordinátákkal. Nem canvas módszer kell, hanem html, és nagy z index.
    
let draggedElement = null;
let offset = [0, 0];

// Gombok pozíciójának betöltése a localStorage-ból
function loadPositions() {
  for (let i = 1; i <= 20; i++) {
    const button = document.getElementById(`gomb${i}`);
    const storedPosition = localStorage.getItem(`gomb${i}Position`);
    if (storedPosition) {
      const position = JSON.parse(storedPosition);
      button.style.left = `${position.x}px`;
      button.style.top = `${position.y}px`;
    }
  }
}

// Gombok pozíciójának elmentése a localStorage-ba
function savePosition(button, x, y) {
  const position = { x, y };
  localStorage.setItem(button.id + 'Position', JSON.stringify(position));
}

document.querySelectorAll('.kor-gomb').forEach(button => {
  button.addEventListener('mousedown', (e) => {
    draggedElement = button;
    offset = [
      draggedElement.offsetLeft - e.clientX,
      draggedElement.offsetTop - e.clientY
    ];
  });

  button.addEventListener('touchstart', (e) => {
    draggedElement = button;
    offset = [
      draggedElement.offsetLeft - e.touches[0].clientX,
      draggedElement.offsetTop - e.touches[0].clientY
    ];
  });
});

document.addEventListener('mousemove', (e) => {
  if (draggedElement) {
    draggedElement.style.left = `${e.clientX + offset[0]}px`;
    draggedElement.style.top = `${e.clientY + offset[1]}px`;
    savePosition(draggedElement, e.clientX + offset[0], e.clientY + offset[1]);
  }
});

document.addEventListener('touchmove', (e) => {
  if (draggedElement) {
    draggedElement.style.left = `${e.touches[0].clientX + offset[0]}px`;
    draggedElement.style.top = `${e.touches[0].clientY + offset[1]}px`;
    savePosition(draggedElement, e.touches[0].clientX + offset[0], e.touches[0].clientY + offset[1]);
    e.preventDefault();
  }
});

document.addEventListener('mouseup', () => {
  draggedElement = null;
});

document.addEventListener('touchend', () => {
  draggedElement = null;
});



// A gombok kattintásra történő funkciói


function gomb1Funkcio() {
  // 1. Létrehozzuk a mesterséges 'keydown' eseményt az '1' gombhoz
  const event = new KeyboardEvent('keydown', {
    key: '1',      // Ez az érték megegyezik a fizikai event listener feltételével
    code: 'Digit1',
    bubbles: true  // Az esemény buborékol a dokumentumig, ahol a fizikai listener figyeli
  });

  // 2. Elindítjuk az eseményt a dokumentumon
  // A fizikai joypad eseménykezelője ezt fogja elkapni és végrehajtani a hozzá tartozó logikát.
  document.dispatchEvent(event);
  
  console.log("Gomb 1 megnyomva, esemény átirányítva a fizikai kezelőnek.");
}

function gomb2Funkcio() {
  // 1. Létrehozzuk a mesterséges 'keydown' eseményt a '2' gombhoz
  const event = new KeyboardEvent('keydown', {
    key: '2',      // Ez az érték megegyezik a fizikai event listener feltételével
    code: 'Digit2',
    bubbles: true  // Az esemény buborékol a dokumentumig
  });

  // 2. Elindítjuk az eseményt a dokumentumon
  // A fizikai joypad eseménykezelője ezt fogja elkapni és végrehajtani a hozzá tartozó logikát.
  document.dispatchEvent(event);
  
  console.log("Gomb 2 megnyomva, esemény átirányítva a fizikai kezelőnek.");
}

function gomb3Funkcio() {
  // 1. Létrehozzuk a mesterséges 'keydown' eseményt a '3' gombhoz
  const event = new KeyboardEvent('keydown', {
    key: '3',      // Ez az érték megegyezik a fizikai event listener feltételével
    code: 'Digit3',
    bubbles: true  // Az esemény buborékol a dokumentumig, ahol a fizikai listener figyeli
  });

  // 2. Elindítjuk az eseményt a dokumentumon
  // Ezt kapja el a fizikai billentyűzetkezelő.
  document.dispatchEvent(event);
  
  console.log("Gomb 3 megnyomva, esemény átirányítva a fizikai kezelőnek.");
}

function gomb4Funkcio() {
  // 1. Létrehozzuk a mesterséges 'keydown' eseményt a '4' gombhoz
  const event = new KeyboardEvent('keydown', {
    key: '4',      // Ez az érték megegyezik a fizikai event listener feltételével
    code: 'Digit4',
    bubbles: true  // Az esemény buborékol a dokumentumig, ahol a fizikai listener figyeli
  });

  // 2. Elindítjuk az eseményt a dokumentumon
  // Ezt kapja el a fizikai billentyűzetkezelő.
  document.dispatchEvent(event);
  
  console.log("Gomb 4 megnyomva, esemény átirányítva a fizikai kezelőnek.");
}

function gomb5Funkcio() {
  // 1. Létrehozzuk a mesterséges 'keydown' eseményt az '5' gombhoz
  const event = new KeyboardEvent('keydown', {
    key: '5',      // Ez az érték megegyezik a fizikai event listener feltételével
    code: 'Digit5',
    bubbles: true  // Az esemény buborékol a dokumentumig, ahol a fizikai listener figyeli
  });

  // 2. Elindítjuk az eseményt a dokumentumon
  // Ezt kapja el a fizikai billentyűzetkezelő.
  document.dispatchEvent(event);
  
  console.log("Gomb 5 megnyomva, esemény átirányítva a fizikai kezelőnek.");
}

function gomb6Funkcio() {
  // 1. Létrehozzuk a mesterséges 'keydown' eseményt a '6' gombhoz
  const event = new KeyboardEvent('keydown', {
    key: '6',      // Ez az érték megegyezik a fizikai event listener feltételével
    code: 'Digit6',
    bubbles: true  // Az esemény buborékol a dokumentumig, ahol a fizikai listener figyeli
  });

  // 2. Elindítjuk az eseményt a dokumentumon
  // Ezt kapja el a fizikai billentyűzetkezelő.
  document.dispatchEvent(event);
  
  console.log("Gomb 6 megnyomva, esemény átirányítva a fizikai kezelőnek.");
}

function gomb7Funkcio() {
  // 1. Létrehozzuk a mesterséges 'keydown' eseményt a '7' gombhoz
  const event = new KeyboardEvent('keydown', {
    key: '7',      // Ez az érték megegyezik a fizikai event listener feltételével
    code: 'Digit7',
    bubbles: true  // Az esemény buborékol a dokumentumig, ahol a fizikai listener figyeli
  });

  // 2. Elindítjuk az eseményt a dokumentumon
  // Ezt kapja el a fizikai billentyűzetkezelő.
  document.dispatchEvent(event);
  
  console.log("Gomb 7 megnyomva, esemény átirányítva a fizikai kezelőnek.");
}

function gomb8Funkcio() {
  // 1. Létrehozzuk a mesterséges 'keydown' eseményt a '8' gombhoz
  const event = new KeyboardEvent('keydown', {
    key: '8',      // Ez az érték megegyezik a fizikai event listener feltételével
    code: 'Digit8',
    bubbles: true  // Az esemény buborékol a dokumentumig, ahol a fizikai listener figyeli
  });

  // 2. Elindítjuk az eseményt a dokumentumon
  // Ezt kapja el a fizikai billentyűzetkezelő.
  document.dispatchEvent(event);
  
  console.log("Gomb 8 megnyomva, esemény átirányítva a fizikai kezelőnek.");
}

function gomb9Funkcio() {
  // 1. Létrehozzuk a mesterséges 'keydown' eseményt a '9' gombhoz
  const event = new KeyboardEvent('keydown', {
    key: '9',      // Ez az érték megegyezik a fizikai event listener feltételével
    code: 'Digit9',
    bubbles: true  // Az esemény buborékol a dokumentumig, ahol a fizikai listener figyeli
  });

  // 2. Elindítjuk az eseményt a dokumentumon
  // Ezt kapja el a fizikai billentyűzetkezelő.
  document.dispatchEvent(event);
  
  console.log("Gomb 9 megnyomva, esemény átirányítva a fizikai kezelőnek.");
}


function gomb10Funkcio() {
  console.log("Gomb 10 megnyomva");
}
function gomb11Funkcio() {
  console.log("Gomb 11 megnyomva");
}
function gomb12Funkcio() {
  console.log("Gomb 12 megnyomva");
}
function gomb13Funkcio() {
  console.log("Gomb 13 megnyomva");
}
function gomb14Funkcio() {
  console.log("Gomb 14 megnyomva");
}
function gomb15Funkcio() {
  console.log("Gomb 15 megnyomva");
}
function gomb16Funkcio() {
  console.log("Gomb 16 megnyomva");
}
function gomb17Funkcio() {
  console.log("Gomb 17 megnyomva");
}
function gomb18Funkcio() {
  console.log("Gomb 18 megnyomva");
}
function gomb19Funkcio() {
  console.log("Gomb 19 megnyomva");
}
function gomb20Funkcio() {
  console.log("Gomb 20 megnyomva");
}

// A gombokhoz tartozó onclick események hozzáadása
document.getElementById('gomb1').addEventListener('click', gomb1Funkcio);
document.getElementById('gomb2').addEventListener('click', gomb2Funkcio);
document.getElementById('gomb3').addEventListener('click', gomb3Funkcio);
document.getElementById('gomb4').addEventListener('click', gomb4Funkcio);
document.getElementById('gomb5').addEventListener('click', gomb5Funkcio);
document.getElementById('gomb6').addEventListener('click', gomb6Funkcio);
document.getElementById('gomb7').addEventListener('click', gomb7Funkcio);
document.getElementById('gomb8').addEventListener('click', gomb8Funkcio);
document.getElementById('gomb9').addEventListener('click', gomb9Funkcio);
document.getElementById('gomb10').addEventListener('click', gomb10Funkcio);
document.getElementById('gomb11').addEventListener('click', gomb11Funkcio);
document.getElementById('gomb12').addEventListener('click', gomb12Funkcio);
document.getElementById('gomb13').addEventListener('click', gomb13Funkcio);
document.getElementById('gomb14').addEventListener('click', gomb14Funkcio);
document.getElementById('gomb15').addEventListener('click', gomb15Funkcio);
document.getElementById('gomb16').addEventListener('click', gomb16Funkcio);
document.getElementById('gomb17').addEventListener('click', gomb17Funkcio);
document.getElementById('gomb18').addEventListener('click', gomb18Funkcio);
document.getElementById('gomb19').addEventListener('click', gomb19Funkcio);
document.getElementById('gomb20').addEventListener('click', gomb20Funkcio);

// Betöltjük a gombok pozícióit a localStorage-ból
loadPositions();

function resetGombXY() {
  const buttons = [];
  for (let i = 1; i <= 20; i++) {
    buttons.push(document.getElementById(`gomb${i}`));
  }

  const screenWidth = window.innerWidth;
  const screenHeight = window.innerHeight;

  const maxButtonsPerRow = 7;
  const totalRows = 3;

  // Example vertical positions for 3 rows centered vertically
  const rowHeightSpacing = 50; // space between rows
  const startTop = (screenHeight / 2) - (rowHeightSpacing * (totalRows - 1) / 2);

  const buttonWidth = buttons[0]?.offsetWidth || 50; // approximate if unknown
  const spacingH = 10; // horizontal spacing between buttons

  // Rows button counts 
  const rowCounts = [7, 7, 6];

  for (let row = 0, btnIndex = 0; row < totalRows; row++) {
    const btnCount = rowCounts[row];
    const rowWidth = btnCount * buttonWidth + (btnCount - 1) * spacingH;
    const startLeft = (screenWidth - rowWidth) / 2 - 50; // -50 px balra tolás

    for (let col = 0; col < btnCount; col++, btnIndex++) {
      const btn = buttons[btnIndex];
      if (!btn) continue;
      btn.style.position = 'fixed';
      btn.style.left = `${startLeft + col * (buttonWidth + spacingH)}px`;
      btn.style.top = `${startTop + row * rowHeightSpacing}px`;
      savePosition(btn, btn.offsetLeft, btn.offsetTop);
    }
  }
}


// gombok ki be onscreen

// Gombok ki/be kapcsolása
let gombokKi = true;

// Gombok elrejtése induláskor
const gombok = document.querySelectorAll('.kor-gomb');

// Visszaállítjuk az utolsó ismert állapotot
const storedState = localStorage.getItem('gombokKi');
if (storedState !== null) {
  gombokKi = storedState === 'true';
}

// Állapot alapján elrejtjük vagy megjelenítjük a gombokat
gombok.forEach(gomb => {
  if (gombokKi) {
    gomb.style.display = 'none';
  } else {
    gomb.style.display = 'block';
  }
});

document.getElementById('toggleGombok').addEventListener('click', () => {
  gombokKi = !gombokKi;
  
  // Mentjük az új állapotot stringként
  localStorage.setItem('gombokKi', String(gombokKi));

  gombok.forEach(gomb => {
    if (gombokKi) {
      gomb.style.display = 'none';
    } else {
      gomb.style.display = 'block';
    }
  });




  // Első lenyomáskor indítsd el az initJoypadSetup függvényt
  if (!gombokKi && !initJoypadSetupCalled) {
    initJoypadSetup();
    initJoypadSetupCalled = true;
    optionsApopupButtonFunction();
  }
});

// Változó, hogy az initJoypadSetup ne fusson le többször
let initJoypadSetupCalled = false;




function setButtonSize(isLarge) {
  const buttons = document.querySelectorAll('.kor-gomb');
  buttons.forEach(button => {
    if (isLarge) {
      button.style.transform = 'scale(1.5)';
      button.style.transition = 'transform 0.3s ease';
    } else {
      button.style.transform = 'scale(1)';
      button.style.transition = 'transform 0.3s ease';
    }
  });
}


// Betöltéskor állítsd be a gombok nagy méretét, localStorage nélkül
function setDefaultButtonSize() {
  const buttons = document.querySelectorAll('.kor-gomb');
  buttons.forEach(button => {
    button.style.transform = 'scale(1.5)';
    button.style.transition = 'transform 0.3s ease';
  });
}

// Hívd meg az oldal betöltésekor vagy initJoypadSetup előtt
setDefaultButtonSize();

// a setuppanel az onscreen joypad buttonoknak
function initJoypadSetup() {
  // Hozz létre egy panelt a reset gombhoz
  const resetPanel = document.createElement('div');
  resetPanel.style.position = 'absolute';
  resetPanel.style.top = `calc(20%)`; // Középről feljebb
  resetPanel.style.left = 'calc(50% - 150px)'; // Középre igazítva
  resetPanel.style.width = '300px'; // Szélesebb panel
  resetPanel.style.height = '250px'; // Magasabb panel
  resetPanel.style.padding = '20px';
  resetPanel.style.borderRadius = '10px';
  resetPanel.style.zIndex = '10100';
  resetPanel.style.backgroundColor = 'rgba(255, 255, 255, 0.5)'; // Átlátszó háttér
  resetPanel.style.backdropFilter = 'blur(5px)'; // Környezet elmosódása
  resetPanel.style.cursor = 'grab'; // Mutató jelzi, hogy húzható

  // Hozz létre egy címkét a panel nevének
  const panelTitle = document.createElement('div');
  panelTitle.textContent = 'Onscreen Joypad Setup';
  panelTitle.style.textAlign = 'center';
  panelTitle.style.fontSize = '18px';
  panelTitle.style.fontWeight = 'bold';
  panelTitle.style.marginBottom = '20px'; // Távolság a gomboktól

  // Hozz létre egy gombot a reset funkcióhoz
  const resetButton = document.createElement('button');
  resetButton.textContent = 'Reset';
  resetButton.style.color = 'black';
  resetButton.style.background = 'inherit';
  resetButton.style.border = 'none';
  resetButton.style.padding = '10px 20px';
  resetButton.style.borderRadius = '5px';
  resetButton.style.cursor = 'pointer';
  resetButton.style.position = 'absolute';
  resetButton.style.bottom = '20px';
  resetButton.style.left = '20px';

  // Hozz létre egy kilépés gombot
  const exitButton = document.createElement('button');
  exitButton.textContent = 'X';
  exitButton.style.color = 'black';
  exitButton.style.background = 'inherit';
  exitButton.style.border = 'none';
  exitButton.style.padding = '10px 20px';
  exitButton.style.borderRadius = '5px';
  exitButton.style.cursor = 'pointer';
  exitButton.style.position = 'absolute';
  exitButton.style.bottom = '20px';
  exitButton.style.right = '20px';

  // Hozz létre egy infó gombot
  const infoButton = document.createElement('button');
  infoButton.textContent = 'Info';
  infoButton.style.color = 'black';
  infoButton.style.background = 'inherit';
  infoButton.style.border = 'none';
  infoButton.style.padding = '10px 20px';
  infoButton.style.borderRadius = '5px';
  infoButton.style.cursor = 'pointer';
  infoButton.style.position = 'absolute';
  infoButton.style.bottom = '20px';
  infoButton.style.left = 'calc(50% - 40px)'; // Középre igazítva

  // Hozz létre egy input mezőt
  const inputField = document.createElement('input');
  inputField.type = 'text';
  inputField.placeholder = 'Írj be valamit';
  inputField.style.width = '100%';
  inputField.style.padding = '10px';
  inputField.style.marginBottom = '20px';
  inputField.style.borderRadius = '5px';
  inputField.style.border = '1px solid #ccc';

  // Elemek hozzáadása a panelhez
  resetPanel.appendChild(panelTitle);
  resetPanel.appendChild(inputField);
  resetPanel.appendChild(resetButton);
  resetPanel.appendChild(exitButton);
  resetPanel.appendChild(infoButton);
  document.body.appendChild(resetPanel);

// Gomb méret toggle létrehozása
const sizeToggleLabel = document.createElement('label');
sizeToggleLabel.textContent = 'Gomb méret';
sizeToggleLabel.style.display = 'block';
sizeToggleLabel.style.marginBottom = '10px';
sizeToggleLabel.style.fontWeight = 'bold';
sizeToggleLabel.style.cursor = 'pointer';

const sizeToggle = document.createElement('input');
sizeToggle.type = 'checkbox';
sizeToggle.style.marginLeft = '10px';
sizeToggleLabel.appendChild(sizeToggle);

// Hozzáadjuk a panelhez a toggle-t a címke után
resetPanel.insertBefore(sizeToggleLabel, inputField);

// Betöltjük a korábbi állapotot a localStorage-ból
const storedSizeState = localStorage.getItem('gombMeretNagy');
if (storedSizeState === 'true') {
  sizeToggle.checked = true;
  setButtonSize(true);
} else {
  setButtonSize(false);
}

// Toggle alapértelmezett állapota: bekapcsolt (nagy méret)
sizeToggle.checked = true;
setButtonSize(true);

// Toggle változás eseménykezelője - csak állítja a méretet, nem menti
sizeToggle.addEventListener('change', () => {
  const isLarge = sizeToggle.checked;
  setButtonSize(isLarge);
  // localStorage mentés NINCS
});


  // Info gomb funkciója
  infoButton.addEventListener('click', () => {
    const functions = [
      { name: 'gomb1Funkcio', func: gomb1Funkcio },
      { name: 'gomb2Funkcio', func: gomb2Funkcio },
      { name: 'gomb3Funkcio', func: gomb3Funkcio },
      { name: 'gomb4Funkcio', func: gomb4Funkcio },
      { name: 'gomb5Funkcio', func: gomb5Funkcio },
      { name: 'gomb6Funkcio', func: gomb6Funkcio },
      { name: 'gomb7Funkcio', func: gomb7Funkcio },
      { name: 'gomb8Funkcio', func: gomb8Funkcio },
      { name: 'gomb9Funkcio', func: gomb9Funkcio },
      { name: 'gomb10Funkcio', func: gomb10Funkcio },
      { name: 'gomb11Funkcio', func: gomb11Funkcio },
      { name: 'gomb12Funkcio', func: gomb12Funkcio },
      { name: 'gomb13Funkcio', func: gomb13Funkcio },
      { name: 'gomb14Funkcio', func: gomb14Funkcio },
      { name: 'gomb15Funkcio', func: gomb15Funkcio },
      { name: 'gomb16Funkcio', func: gomb16Funkcio },
      { name: 'gomb17Funkcio', func: gomb17Funkcio },
      { name: 'gomb18Funkcio', func: gomb18Funkcio },
      { name: 'gomb19Funkcio', func: gomb19Funkcio },
      { name: 'gomb20Funkcio', func: gomb20Funkcio }
    ];

    // Console-ba kiírás
    console.log('Gombok által elindított funkciók:');
    functions.forEach(func => {
      console.log(`- ${func.name}:`);
      console.log(func.func.toString());
      console.log('---');
    });

    // Popup ablak létrehozása
    const infoPopup = document.createElement('div');
    infoPopup.style.position = 'absolute';
    infoPopup.style.top = '50%';
    infoPopup.style.left = '50%';
    infoPopup.style.transform = 'translate(-50%, -50%)';
    infoPopup.style.width = '500px';
    infoPopup.style.height = '400px';
    infoPopup.style.background = 'rgba(128, 128, 128, 0.6)'; // Szürkés háttér, átlátszó
    infoPopup.style.borderRadius = '10px';
    infoPopup.style.padding = '20px';
    infoPopup.style.zIndex = '10101'; // Magasabb z-index, mint a reset panel

    const infoContent = document.createElement('div');
    infoContent.style.overflowY = 'auto';
    infoContent.style.height = 'calc(100% - 40px)';
    infoContent.style.color = 'white'; // Fehér szöveg
    infoContent.style.fontSize = '18px'; // Nagyobb szöveg

    let contentHtml = '';
    functions.forEach(func => {
      contentHtml += `<b>${func.name}:</b><br>${func.func.toString()}<br><br>`;
    });

    infoContent.innerHTML = contentHtml;

    const closeButton = document.createElement('button');
    closeButton.textContent = 'Bezárás';
    closeButton.style.position = 'absolute';
    closeButton.style.bottom = '10px';
    closeButton.style.right = '10px';
    closeButton.style.padding = '5px 10px';
    closeButton.style.borderRadius = '5px';
    closeButton.style.cursor = 'pointer';
    closeButton.style.color = 'white'; // Fehér szöveg
    closeButton.style.background = 'rgba(0, 0, 0, 0.5)'; // Átlátszó fekete háttér

    infoPopup.appendChild(infoContent);
    infoPopup.appendChild(closeButton);
    document.body.appendChild(infoPopup);

    closeButton.addEventListener('click', () => {
      infoPopup.remove();
    });
  });




  
// itt a popup infopanelablak vége


  // Panel draggable funkciók
  let isDragging = false;
  let offsetX, offsetY;

  resetPanel.addEventListener('mousedown', (e) => {
    isDragging = true;
    offsetX = e.clientX - resetPanel.offsetLeft;
    offsetY = e.clientY - resetPanel.offsetTop;
    resetPanel.style.cursor = 'grabbing'; // Vizualizáció húzás közben
  });

  document.addEventListener('mousemove', (e) => {
    if (isDragging) {
      resetPanel.style.left = `${e.clientX - offsetX}px`;
      resetPanel.style.top = `${e.clientY - offsetY}px`;
    }
  });

  document.addEventListener('mouseup', () => {
    isDragging = false;
    resetPanel.style.cursor = 'grab'; // Visszaáll az alapértelmezett kurzor
  });

  // Érintéses eszközök támogatása
  resetPanel.addEventListener('touchstart', (e) => {
    isDragging = true;
    const touch = e.touches[0];
    offsetX = touch.clientX - resetPanel.offsetLeft;
    offsetY = touch.clientY - resetPanel.offsetTop;
  });

  document.addEventListener('touchmove', (e) => {
    if (isDragging) {
      const touch = e.touches[0];
      resetPanel.style.left = `${touch.clientX - offsetX}px`;
      resetPanel.style.top = `${touch.clientY - offsetY}px`;
      e.preventDefault(); // Megakadályozza az oldal görgetését
    }
  });

  document.addEventListener('touchend', () => {
    isDragging = false;
  });

  // Elemek hozzáadása a panelhez
  resetPanel.appendChild(panelTitle);
  resetPanel.appendChild(resetButton);
  resetPanel.appendChild(exitButton);
  document.body.appendChild(resetPanel);

  // Reset gomb funkciója
  resetButton.addEventListener('click', resetGombXY);

  // Exit gomb funkciója
  exitButton.addEventListener('click', () => {
    resetPanel.remove();
  });
}

// Hívja meg a függvényt
//initJoypadSetup();



    
    
    
    
    
    
    
    
    //////////////
   // 
    
    
    
    
    
    
    
    
    
    
    //////////



function kjkhistoryshow() {
  // Lekérdezzük a zagorsave localStorage bejegyzés tartalmát
  const zagorsaveData = localStorage.getItem('zagorsave');
  let zagorsaveEntries = [];
  if (zagorsaveData) {
    zagorsaveEntries = JSON.parse(zagorsaveData);
  }

  // Létrehozzuk a megjelenítendő elemet
  const historyContainer = document.createElement('div');
  historyContainer.style.position = 'fixed';
  historyContainer.style.top = '5%';
  historyContainer.style.left = '0';
  historyContainer.style.width = '100%';
  historyContainer.style.height = '20%';
  historyContainer.style.backgroundColor = 'rgba(190, 110, 190, 0.2)';
  historyContainer.style.display = 'flex';
  historyContainer.style.justifyContent = 'center';
  historyContainer.style.alignItems = 'center';
  historyContainer.style.zIndex = '9999';
  historyContainer.style.opacity = '0';
  historyContainer.style.transition = 'opacity 0.9s ease-in-out';

  // Létrehozzuk a tartalmat tartalmazó elemet
  const historyContent = document.createElement('div');
  historyContent.style.backgroundColor = 'rgba(10, 150, 210, 0.3)';
  historyContent.style.padding = '20px';
  historyContent.style.borderRadius = '9px';
  historyContent.style.maxWidth = '80%';
  historyContent.style.maxHeight = '80%';
  historyContent.style.overflowY = 'auto';

historyContent.style.fontSize = '18px';


  // Hozzáadjuk a bejegyzéseket a tartalomhoz
  zagorsaveEntries.forEach(entry => {
    const [sentenceNumber, bookName] = entry.split('|');
    const entryElement = document.createElement('p');
    entryElement.textContent = `Mondat száma: ${sentenceNumber}, Könyv neve: ${bookName}`;
    historyContent.appendChild(entryElement);
  });

  // Létrehozzuk a bezárás gombot
  const closeButton = document.createElement('button');
  closeButton.textContent = 'Close';
  closeButton.style.display = 'block';
  closeButton.style.margin = '15px auto 0';
  closeButton.addEventListener('click', () => {
  	playany(['snd/Zapsplat High tech beep with reverb 4.mp3'], 1);
    historyContainer.style.opacity = '0';
    setTimeout(() => {
      historyContainer.remove();
    }, 500);
  });





  // Létrehozzuk a törlő gombot
  const DelButton = document.createElement('button');
  DelButton.textContent = 'Delete';
  DelButton.style.display = 'block';
  DelButton.style.margin = '15px auto 0';
  DelButton.addEventListener('click', () => {
  	
  //historysavetofile();
  	zagorhistoryclean();
     historyContainer.remove();
     kjkhistoryshow();
     
  });
  
  
  historyContent.appendChild(DelButton);
  historyContent.appendChild(closeButton);
  historyContainer.appendChild(historyContent);
  document.body.appendChild(historyContainer);

  // Megjelenítjük a fade in animációt
  setTimeout(() => {
    historyContainer.style.opacity = '1';
  }, 100);
  
  playoscilla(519, 100); // F4
playoscilla(392, 100); // G4
playoscilla(349, 150); // F4
playoscilla(392, 100); // G4
playoscilla(523, 200); // C5
playoscilla(392, 100); // G4
}



function zagorhistoryclean() {
	
	
	
playany(['snd/Zapsplat High tech beep with reverb 4.mp3'], 1);
    // Megkérdezi a felhasználót, hogy biztosan törölni akarja-e az összes tartalmat
    const confirmation = confirm("Biztosan törölni akarja az előzmény összes tartalmát?");

    // Ha a felhasználó megerősíti a törlést
    if (confirmation) {
    	historysavetofile();
    playoscilla(392, 100); // G4
    playoscilla(392, 100); // G4
   
           // Eltávolítjuk a zagorsave localStorage bejegyzést
    localStorage.removeItem('zagorsave');
    //kjkhistorydelall();



        // Opcióként értesítheted a felhasználót a sikeres törlésről
        //alert("A tartalom sikeresen törölve lett.");
        startTypingAnimation('paragraphId', 'divId', 'A tartalom sikeresen törölve lett.');
        
    } else {
        // Ha a felhasználó nem erősíti meg, értesítheted őt
        //alert("A törlés megszakítva.");
        startTypingAnimation('paragraphId', 'divId', 'A törlés megszakítva.');
    }
}

function historysavetofile() {
	let favoritContent = localStorage.getItem('zagorsave');
    let blob = new Blob([favoritContent], { type: 'text/plain' });
    let url = URL.createObjectURL(blob);
    let link = document.createElement('a');
    link.href = url;
    
    let currentDate = new Date().toLocaleString();
    
    link.download = 'history_files   ' + currentDate + '   zagor előzmények_files.txt';
    link.click();
    URL.revokeObjectURL(url);
	}



function kjkhistorydelall() {
//  if (kaland === true && optionsopen === 1) {
	if (kaland === true) {
    // Eltávolítjuk a zagorsave localStorage bejegyzést
    localStorage.removeItem('zagorsave');
    
    playoscilla(519, 100); // F4
playoscilla(392, 100); // G4
playoscilla(349, 150); // F4
playoscilla(392, 100); // G4
playoscilla(523, 200); // C5
playoscilla(392, 100); // G4
  }
}

function kjkhistorydeltwo() {
  // Lekérdezzük a zagorsave localStorage bejegyzés tartalmát
  const zagorsaveData = localStorage.getItem('zagorsave');
  let zagorsaveEntries = [];
  if (zagorsaveData) {
    zagorsaveEntries = JSON.parse(zagorsaveData);
  }

  // Eltávolítjuk az utolsó két bejegyzést a tömbből
  zagorsaveEntries.pop();
  zagorsaveEntries.pop();

  // Frissítjük a localStorage bejegyzést a módosított tömbmel
  localStorage.setItem('zagorsave', JSON.stringify(zagorsaveEntries));
  
  playoscilla(519, 100); // F4
playoscilla(392, 100); // G4
playoscilla(349, 150); // F4
playoscilla(392, 100); // G4
playoscilla(523, 200); // C5
playoscilla(392, 100); // G4
}

function kjkhistorydelone() {
  // Lekérdezzük a zagorsave localStorage bejegyzés tartalmát
  const zagorsaveData = localStorage.getItem('zagorsave');
  let zagorsaveEntries = [];
  if (zagorsaveData) {
    zagorsaveEntries = JSON.parse(zagorsaveData);
  }

  // Eltávolítjuk az utolsó bejegyzést a tömbből
  zagorsaveEntries.pop();

  // Frissítjük a localStorage bejegyzést a módosított tömbmel
  localStorage.setItem('zagorsave', JSON.stringify(zagorsaveEntries));
  
  playoscilla(519, 100); // F4
playoscilla(392, 100); // G4
playoscilla(349, 150); // F4
playoscilla(392, 100); // G4
playoscilla(523, 200); // C5
playoscilla(392, 100); // G4
}






function nyusziout() {
	startTypingAnimation('paragraphId', 'divId', 'kjk zagor naplózás off');
nyuszino = 1;

}

function nyusziin() {
	startTypingAnimation('paragraphId', 'divId', 'kjk zagor naplózás ON');
nyuszino = 0;

}




//////////////////
// ha nincs joypad 1.

function nojoyonscreen() {

  optionsApopupButtonFunction();

  createScriptButton("next", function() {
    stopSpeaking(); 
    three();
  }, {
    position: "absolute",
    bottom: "10%", // Pozíció korrigálása
    right: "5%", // Pozíció korrigálása
    transform: "translate(-50%, -50%)",
    fontSize: "52px",
    padding: "10px 20px",
    backgroundColor: "rgba(0, 75, 255, 0.8)", // Átlátszatlanság növelése
    color: "rgba(255, 255, 255, 1)", // Szövegszín fehérre állítása
    border: "none",
    borderRadius: "8px",
    zIndex: '9995'
  })

  createScriptButton("prev", function() {
    stopSpeaking();
    one();
  }, {
    position: "absolute",
    bottom: "10%", // Pozíció korrigálása
    left: "5%", // Pozíció korrigálása
    transform: "translate(-50%, -50%)",
    fontSize: "52px",
    padding: "10px 20px",
    backgroundColor: "rgba(0, 75, 255, 0.8)", // Átlátszatlanság növelése
    color: "rgba(255, 255, 255, 1)", // Szövegszín fehérre állítása
    border: "none",
    borderRadius: "8px",
    zIndex: '9995'
  })

  createScriptButton("kjk", function() {
    stopSpeaking();
    kjk();
  }, {
    position: "absolute",
    bottom: "20%", // Pozíció korrigálása
    right: "5%", // Pozíció korrigálása
    transform: "translate(-50%, -50%)",
    fontSize: "45px",
    padding: "10px 20px",
    backgroundColor: "rgba(0, 75, 255, 0.8)", // Átlátszatlanság növelése
    color: "rgba(255, 255, 255, 1)", // Szövegszín fehérre állítása
    border: "none",
    borderRadius: "6px",
    zIndex: '9995'
  })

  createScriptButton("kjkhistoryshow", function() {
    kjkhistoryshow();
  }, {
    position: "absolute",
    bottom: "20%", // Pozíció korrigálása
    left: "5%", // Pozíció korrigálása
    transform: "translate(-50%, -50%)",
    fontSize: "20px",
    padding: "10px 20px",
    backgroundColor: "rgba(0, 75, 255, 0.8)", // Átlátszatlanság növelése
    color: "rgba(255, 255, 255, 1)", // Szövegszín fehérre állítása
    border: "none",
    borderRadius: "6px",
    zIndex: '9995'
  })

  createScriptButton("kalandlap", function() {
    optionsApopupButtonFunction();
    kalandlap();
  }, {
    position: "absolute",
    bottom: "30%", // Pozíció korrigálása
    left: "5%", // Pozíció korrigálása
    transform: "translate(-50%, -50%)",
    fontSize: "20px",
    padding: "10px 20px",
    backgroundColor: "rgba(0, 75, 255, 0.8)", // Átlátszatlanság növelése
    color: "rgba(255, 255, 255, 1)", // Szövegszín fehérre állítása
    border: "none",
    borderRadius: "6px",
    zIndex: '9995'
  })

  createScriptButton("naplózásoff", function() {
    startTypingAnimation('paragraphId', 'divId', 'kjk zagor naplózás off');
    nyuszino = 1;
  }, {
    position: "absolute",
    bottom: "40%", // Pozíció korrigálása
    left: "5%", // Pozíció korrigálása
    transform: "translate(-50%, -50%)",
    fontSize: "20px",
    padding: "10px 20px",
    backgroundColor: "rgba(0, 75, 255, 0.8)", // Átlátszatlanság növelése
    color: "rgba(255, 255, 255, 1)", // Szövegszín fehérre állítása
    border: "none",
    borderRadius: "6px",
    zIndex: '9995'
  })

  //toggleFullscreen();
}






//////////////////
/// ha nincs joypad, ez jó a számoknak, kjk

//   inputablak ki-be kapcsolható -------------------------------

let inputWindowVisible = false;

function toggleInputWindow() {
    if (inputWindowVisible) {
        const inputContainer = document.getElementById('inputContainer');
        if (inputContainer) {
            inputContainer.remove();
            inputWindowVisible = false;
        }
    } else {
        createInputWindow('nums', (value) => {
            console.log('Input value:', value);
        });
        inputWindowVisible = true;
        
    }
}

function createInputWindow(label, onSubmit) {
    const inputContainer = document.createElement('div');
    inputContainer.id = 'inputContainer';
    inputContainer.style.position = 'fixed';
    inputContainer.style.top = '20%';
    inputContainer.style.left = '84%';
    inputContainer.style.transform = 'translate(-50%, -50%)';
    inputContainer.style.backgroundColor = 'rgba(240, 240, 240, 0.02)'
    inputContainer.style.padding = '20px';
    inputContainer.style.boxShadow = '0 0 10px rgba(0, 0, 0, 0.5)';
    inputContainer.style.borderRadius = '10px';
    inputContainer.style.zIndex = '9999'; // z-index beállítása 9999-re
    inputContainer.style.width = 'auto'; // Szélesség automatikus beállítása
    inputContainer.style.height = 'auto'; // Magasság automatikus beállítása

    const inputLabel = document.createElement('label');
    inputLabel.textContent = label;
    inputLabel.style.display = 'block';
    inputLabel.style.marginBottom = '8px';
    inputLabel.style.color = 'rgba(240, 240, 240, 0.03)'; // RGBA szín beállítása a felirathoz

    const inputField = document.createElement('input');
    inputField.type = 'text';
    inputField.style.backgroundColor = 'rgba(0, 0, 0, 0.01)';
    inputField.style.padding = '1px';
    inputField.style.borderRadius = '1px';
    inputField.style.color = 'rgba(120, 120, 120, 0.05)'; // RGBA szín beállítása az inputmező szövegéhez
    inputField.focus(); // Fókuszba helyezzük az inputmezőt

    const buttonContainer = document.createElement('div');
    buttonContainer.style.display = 'flex';
    buttonContainer.style.justifyContent = 'space-between';
    buttonContainer.style.marginTop = '1px';

    const okButton = document.createElement('button');
    okButton.textContent = 'OK';
    okButton.style.backgroundColor = 'rgba(240, 240, 240, 0.02)'
    okButton.style.color = 'rgba(240, 240, 240, 0.05)'
    okButton.style.border = 'none';
    okButton.style.padding = '5px 10px';
    okButton.style.borderRadius = '15px';
    okButton.style.cursor = 'pointer';
    okButton.addEventListener('click', () => {
        const value = inputField.value;
        inputContainer.remove();
        onSubmit(value);
        inputWindowVisible = false;
    });

    const kjkButton = document.createElement('button');
    kjkButton.textContent = 'KJK';
    kjkButton.style.backgroundColor = 'rgba(240, 240, 240, 0.02)'
    kjkButton.style.color = 'rgba(240, 240, 240, 0.02)'
    kjkButton.style.border = 'none';
    kjkButton.style.padding = '18px 30px'; // Nagyobb méret a KJK gombhoz
    kjkButton.style.borderRadius = '5px';
    kjkButton.style.cursor = 'pointer';
    kjkButton.addEventListener('click', () => {
        kjk(); // Indítjuk a kjk() függvényt
        inputField.focus(); // Fókuszba helyezzük az inputmezőt
    });

    buttonContainer.appendChild(okButton);
    buttonContainer.appendChild(kjkButton);

    inputContainer.appendChild(inputLabel);
    inputContainer.appendChild(inputField);
    inputContainer.appendChild(buttonContainer);
    document.body.appendChild(inputContainer);

    //inputField.focus(); // Fókuszba helyezzük az inputmezőt
}




/*      használat
toggleInputWindow();
*/

//   -------------------------------



/////////////////////
/// A kaland játék kockázat



// Frissíti a számválasztó gombjai kiemelését a selectedNumberIndex szerint
function updateNumberButtonsHighlight() {
  if (!numbersContainer) return;
  const buttons = numbersContainer.querySelectorAll('button');
  buttons.forEach((btn, i) => {
    if (i === selectedNumberIndex) {
      btn.style.outline = '3px solid yellow'; 
      btn.style.backgroundColor = '#ff9933'; 

      // Felolvasás a kiválasztott számról
      const msg = new SpeechSynthesisUtterance(` ${btn.textContent}`);
      msg.lang = 'hu-HU';
      //speechSynthesis.cancel(); // Megállítjuk az esetleg futó beszédet
      speechSynthesis.speak(msg);

    } else {
      btn.style.outline = 'none';
      btn.style.backgroundColor = ''; // vagy eredeti színed
    }
  });
}




function kjk() {
  stopMonitoring();
  document.body.style.overflow = 'auto';

  let selectedText = document.getElementById('selectedtextblock').innerText;
  let numberRegex = /\d+/g;
  numbers = selectedText.match(numberRegex);

  if (numbers && numbers.length > 1) {
    isNumberSelectorActive = true;
    selectedNumberIndex = 0;
console.log('Numbers:', numbers);
    var textToRead2 = `Több szám van. ${numbers.join(' vagy ')}.`;
    var lang2 = 'hu-HUN';
    var audio2 = new SpeechSynthesisUtterance(textToRead2);
    audio2.lang = lang2;
    audio2.rate = 1;
    audio2.volume = 1;
    audio2.pitch = 1;
    speechSynthesis.speak(audio2);

    numbersContainer = document.createElement('div');
    numbersContainer.style.display = 'flex';
    numbersContainer.style.justifyContent = 'center';
    numbersContainer.style.marginTop = '250px';
    numbersContainer.style.marginLeft = '50px';
    numbersContainer.style.zIndex = '15000';
    numbersContainer.id = 'numbersContainer';

    numbers.forEach((number, index) => {
      const button = document.createElement('button');
      button.textContent = number;
      button.style.backgroundColor = getRandomColor();
      button.style.color = 'white';
      button.style.border = 'none';
      button.style.padding = '22px 40px';
      button.style.margin = '0 10px';
      button.style.borderRadius = '8px';
      button.style.cursor = 'pointer';
      button.style.fontSize = '20px';
      button.style.zIndex = '15000';
      button.addEventListener('click', () => {
        stopSpeakinguniver();
        kjkNumjump = number;
        isNumberSelectorActive = false;
        numbersContainer.remove();
        numbersContainer = null;
        processSelectedNumber();
      });
      numbersContainer.appendChild(button);
    });


    document.body.appendChild(numbersContainer);
    updateNumberButtonsHighlight();

    // Gombok eltávolítása 30s után, ha nincs választás
    let timer = setTimeout(() => {
      if (isNumberSelectorActive) {
        isNumberSelectorActive = false;
        if (numbersContainer) {
          numbersContainer.remove();
          numbersContainer = null;
        }
      }
    }, 30000);
  } else if (numbers && numbers.length === 1) {
    kjkNumjump = numbers[0];
    processSelectedNumber();
  } else {
    if (kaland === true) {
      const userInput = prompt('Hová ugorjak?');
      if (userInput) {
        kjkNumjump = userInput;
        processSelectedNumber();
      
    
  

    } else {
      console.log('Nem adott meg értéket');
    }
    }
    
  }




function processSelectedNumber() {
  sentences = origcontent.match(/[^.!?]+(?:\.|!|\?)(?=\s|$)/g);

  matchedSentences = sentences.filter(sentence => {
    const regex = new RegExp(`\\b${kjkNumjump}\\b`);
    return regex.test(sentence);
  });

  if (matchedSentences.length > 0) {
    if (matchedSentences.length > 1) {
      // Több találat esetén buttonokat készítünk és megkérdezzük a felhasználót
      
      if (muteSounds) {
        playany(['snd/kjk jump 20240522_204047.mp3', 'snd/kjk jump 20240522_204105.mp3', 'snd/kjk jump 20240522_204229.mp3', 'snd/kjk jump 20240522_204330.mp3', 'snd/kjk jump 20240522_204438.mp3'], 0.1);
    }
      readany = ("Több találat.");	
    readanytexthun();
    
      


      
      
      const buttonContainer = document.createElement('div');
    buttonContainer.classList.add('button-container');

    matchedSentences.forEach((sentence, index) => {
      const button = document.createElement('button');
      button.classList.add('custom-button'); // Hozzáadjuk az osztályt a buttonhoz
      button.style.zIndex = '9999';
      button.textContent = `Mondat ${index + 1}`;
      button.addEventListener('click', () => {
        handleSentenceSelection(sentence, index);
      });
      buttonContainer.appendChild(button);
    });

    document.body.appendChild(buttonContainer);

    const confirmButton = document.createElement('button');
    confirmButton.textContent = 'Kiválasztom';
    confirmButton.classList.add('customKjk2-button'); // Hozzáadjuk az osztályt a buttonhoz
    confirmButton.style.zIndex = '9999';
    confirmButton.addEventListener('click', () => {
      	if (muteSounds) {
        playany(['snd/kjk/Coin Spill 03.mp3', 'snd/kjk/Coin Gold 05.mp3', 'Drop Coin 02 gold.mp3', 'snd/kjk/Drop Coin 01.mp3', 'snd/kjk/Drop Coin 03.mp3', 'snd/kjk/Coin Drop Spins Coin.mp3'], 0.4);
    }
      	
      
        buttonContainer.remove();
        confirmButton.remove();
        
        stopSpeaking(); 
      readText();
        // A confirmButton lenyomásakor mentjük el a zagorsave bejegyzést
        const zagorsaveData = localStorage.getItem('zagorsave');
        let zagorsaveEntries = [];
        if (zagorsaveData) {
          zagorsaveEntries = JSON.parse(zagorsaveData);
        }


        const newEntry = `${currentsentencenumber}|${bookname}`;
        zagorsaveEntries.push(newEntry);


if (nyuszino === 0) {
	
        localStorage.setItem('zagorsave', JSON.stringify(zagorsaveEntries));

}

        // A zagorsave localstorage bejegyzés tartalmának kiírása a konzolra
        console.log('zagorsave localstorage bejegyzés tartalma:');
        zagorsaveEntries.forEach(entry => {
          const [sentenceNumber, bookName] = entry.split('|');
          console.log(`Mondat száma: ${sentenceNumber}, Könyv neve: ${bookName}`);
        });
      });
      buttonContainer.appendChild(confirmButton);

        // Remove buttons if no button is clicked within 5 seconds
    let timer = setTimeout(() => {
      buttonContainer.remove();
      confirmButton.remove();
    }, 63000);
  } else {
      // Egy találat esetén folytatjuk a kódot
      const selectedSentence = matchedSentences[currentIndex];
      console.log(selectedSentence);
      currentIndex++;
      if (currentIndex >= matchedSentences.length) {
        currentIndex = 0;
      }

      document.getElementById('selectedtextblock').innerText = selectedSentence;

      const sentenceIndex = sentences.indexOf(selectedSentence) + 1;
      console.log(`A kiválasztott mondat a(z) ${sentenceIndex}. mondat az origcontentben.`);

      currentsentencenumber = sentenceIndex;

      updateContextBlock();
      document.getElementById('counter').textContent = currentsentencenumber;
      setSliderToCurrentSentence();

      // fantasy hangot ideee
      if (muteSounds) {
        playany(['snd/kjk/Coin Spill 03.mp3', 'snd/kjk/Coin Gold 05.mp3', 'Drop Coin 02 gold.mp3', 'snd/kjk/Drop Coin 01.mp3', 'snd/kjk/Drop Coin 03.mp3', 'snd/kjk/Coin Drop Spins Coin.mp3'], 0.4);
    }
      
      
      
      readText();

      // A currentsentencenumber és bookname adatok mentése a zagorsave localstorage bejegyzésbe
      const zagorsaveData = localStorage.getItem('zagorsave');
      let zagorsaveEntries = [];
      if (zagorsaveData) {
        zagorsaveEntries = JSON.parse(zagorsaveData);
      }

      const newEntry = `${currentsentencenumber}|${bookname}`;
      zagorsaveEntries.push(newEntry);

      if (nyuszino === 0) {
	
        localStorage.setItem('zagorsave', JSON.stringify(zagorsaveEntries));

}

      // A zagorsave localstorage bejegyzés tartalmának kiírása a konzolra
      console.log('zagorsave localstorage bejegyzés tartalma:');
      zagorsaveEntries.forEach(entry => {
        const [sentenceNumber, bookName] = entry.split('|');
        console.log(`Mondat száma: ${sentenceNumber}, Könyv neve: ${bookName}`);
      });
    }
  } else {
    console.log('Nem található a szám a mondatokban');
  }
}






function handleSentenceSelection(sentence, index) {
  // A kiválasztott mondat feldolgozása
  console.log(`Kiválasztott mondat: ${sentence}`);
  currentIndex = index;

  document.getElementById('selectedtextblock').innerText = sentence;

  const sentenceIndex = sentences.indexOf(sentence) + 1;
  console.log(`A kiválasztott mondat a(z) ${sentenceIndex}. mondat az origcontentben.`);

  currentsentencenumber = sentenceIndex;

  updateContextBlock();
  document.getElementById('counter').textContent = currentsentencenumber;
  setSliderToCurrentSentence();

  // fantasy hangot ideee
  //playany(['snd/kjk jump 20240522_204047.mp3', 'snd/kjk jump 20240522_204105.mp3', 'snd/kjk jump 20240522_204229.mp3', 'snd/kjk jump 20240522_204330.mp3', 'snd/kjk jump 20240522_204438.mp3'], 0.5);

stopSpeaking(); 
  readText();

/*
  // A currentsentencenumber és bookname adatok mentése a zagorsave localstorage bejegyzésbe
  const zagorsaveData = localStorage.getItem('zagorsave');
  let zagorsaveEntries = [];
  if (zagorsaveData) {
    zagorsaveEntries = JSON.parse(zagorsaveData);
  }

  const newEntry = `${currentsentencenumber}|${bookname}`;
  zagorsaveEntries.push(newEntry);

  localStorage.setItem('zagorsave', JSON.stringify(zagorsaveEntries));

  // A zagorsave localstorage bejegyzés tartalmának kiírása a konzolra
  console.log('zagorsave localstorage bejegyzés tartalma:');
  zagorsaveEntries.forEach(entry => {
    const [sentenceNumber, bookName] = entry.split('|');
    console.log(`Mondat száma: ${sentenceNumber}, Könyv neve: ${bookName}`);
  });
  
  */
}




  function getRandomColor() {
    const letters = '0123456789ABCDEF';
    let color = '#';
    for (let i = 0; i < 6; i++) {
      color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
  }
}







async function jumpByNum() {
  if (!origcontent || typeof origcontent !== 'string') {
    alert('Az origcontent nincs definiálva vagy nem szöveg.');
    return;
  }

  const sentences = origcontent.match(/[^.!?]+(?:\.|!|\?)(?=\s|$)/g);
  if (!sentences || sentences.length === 0) {
    alert('Nem találhatók mondatok az origcontentben.');
    return;
  }

  // Új: hangfelismerés indítása és szám bekérése
  const num = await getNumberBySpeech(sentences.length);
  if (num === null) {
    // Felhasználó megszakította vagy nem sikerült
    return;
  }

  // Kiválasztott mondat
  const selectedSentence = sentences[num - 1];

  // Megjelenítés
  const selectedTextBlock = document.getElementById('selectedtextblock');
  if (selectedTextBlock) {
    selectedTextBlock.innerText = selectedSentence.trim();
  } else {
    console.log('selectedtextblock elem nem található.');
  }

  currentsentencenumber = num;

  if (typeof updateContextBlock === 'function') {
    updateContextBlock();
  }

  const counterElem = document.getElementById('counter');
  if (counterElem) {
    counterElem.textContent = currentsentencenumber;
  }

  if (typeof setSliderToCurrentSentence === 'function') {
    setSliderToCurrentSentence();
  }

  if (typeof playany === 'function') {
    playany([
      'snd/kjk/Coin Spill 03.mp3',
      'snd/kjk/Coin Gold 05.mp3',
      'Drop Coin 02 gold.mp3',
      'snd/kjk/Drop Coin 01.mp3',
      'snd/kjk/Drop Coin 03.mp3',
      'snd/kjk/Coin Drop Spins Coin.mp3'
    ], 0.4);
  }

  if (typeof readText === 'function') {
    stopSpeaking();
    await readText();
  }

  const zagorsaveData = localStorage.getItem('zagorsave');
  let zagorsaveEntries = [];
  if (zagorsaveData) {
    zagorsaveEntries = JSON.parse(zagorsaveData);
  }


  const newEntry = `${currentsentencenumber}|${bookname}`;
  zagorsaveEntries.push(newEntry);

  if (typeof nyuszino !== 'undefined' && nyuszino === 0) {
    localStorage.setItem('zagorsave', JSON.stringify(zagorsaveEntries));
  }

  console.log('zagorsave localstorage bejegyzés tartalma:');
  zagorsaveEntries.forEach(entry => {
    const [sentenceNumber, bookName] = entry.split('|');
    console.log(`Mondat száma: ${sentenceNumber}, Könyv neve: ${bookName}`);
  });
}




function getNumberBySpeech(maxNumber) {
  return new Promise((resolve) => {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      alert('A böngésződ nem támogatja a hangfelismerést. Használj promptot.');
      let input = prompt(`Hányadik mondatra szeretnél ugrani? (1 - ${maxNumber})`);
      if (input === null) {
        resolve(null);
        return;
      }
      input = input.trim();
      const num = parseInt(input, 10);
      if (isNaN(num) || num < 1 || num > maxNumber) {
        alert(`Kérlek, adj meg egy 1 és ${maxNumber} közötti egész számot.`);
        resolve(null);
        return;
      }
      resolve(num);
      return;
    }

    const recognition = new SpeechRecognition();
    recognition.lang = 'hu-HU';
    recognition.interimResults = false;
    recognition.maxAlternatives = 1;

    readUniversal("mondatszámot.", "hu-HU", 0.1);

    recognition.start();

    async function promptWithSpeech(message, promptMessage) {
      await readUniversal(message, "hu-HU", 1);
      let input = prompt(promptMessage);
      return input;
    }

    recognition.onresult = async (event) => {
      const speechResult = event.results[0].transcript.trim();
      console.log('Felismert szöveg:', speechResult);

      const num = parseInt(speechResult.replace(/\D/g, ''), 10);

      if (isNaN(num) || num < 1 || num > maxNumber) {
        await promptWithSpeech(
          `Nem sikerült érvényes számot felismerni. Kérlek, írd be a mondatszámot 1 és ${maxNumber} között.`,
          `Nem sikerült érvényes számot felismerni. Kérlek írd be a mondatszámot (1 - ${maxNumber}):`
        ).then((input) => {
          if (input === null) {
            resolve(null);
            return;
          }
          input = input.trim();
          const promptNum = parseInt(input, 10);
          if (isNaN(promptNum) || promptNum < 1 || promptNum > maxNumber) {
            alert(`Kérlek, adj meg egy 1 és ${maxNumber} közötti egész számot.`);
            resolve(null);
            return;
          }
          resolve(promptNum);
        });
      } else {
        resolve(num);
      }
    };

    recognition.onerror = async (event) => {
      alert('Hiba történt a hangfelismerés során: ' + event.error);
      await promptWithSpeech(
        `Hiba történt a hangfelismerés során. Kérlek írd be a mondatszámot 1 és ${maxNumber} között.`,
        `Hiba történt a hangfelismerés során. Kérlek írd be a mondatszámot (1 - ${maxNumber}):`
      ).then((input) => {
        if (input === null) {
          resolve(null);
          return;
        }
        input = input.trim();
        const promptNum = parseInt(input, 10);
        if (isNaN(promptNum) || promptNum < 1 || promptNum > maxNumber) {
          alert(`Kérlek, adj meg egy 1 és ${maxNumber} közötti egész számot.`);
          resolve(null);
          return;
        }
        resolve(promptNum);
      });
    };

    recognition.onend = async () => {
      await promptWithSpeech(
        `Nem érkezett felismerés. Kérlek írd be a mondatszámot 1 és ${maxNumber} között.`,
        `Nem érkezett felismerés. Kérlek írd be a mondatszámot (1 - ${maxNumber}):`
      ).then((input) => {
        if (input === null) {
          resolve(null);
          return;
        }
        input = input.trim();
        const promptNum = parseInt(input, 10);
        if (isNaN(promptNum) || promptNum < 1 || promptNum > maxNumber) {
          alert(`Kérlek, adj meg egy 1 és ${maxNumber} közötti egész számot.`);
          resolve(null);
          return;
        }
        resolve(promptNum);
      });
    };
  });
}




// search


function searchclose() {
    let favoritPopup = document.getElementById('searchPopup');
    searchPopup.style.display = 'none'; // Az ablak elrejtése
}

function searchpaste() {
  // Ellenőrizzük, hogy van-e valami a vágólapon
  navigator.clipboard.readText()
    .then(clipboardText => {
      // Ha van valami a vágólapon, beírjuk a textarea-ba
      document.getElementById('searchInput').value = clipboardText;
    })
    .catch(err => {
      console.error('Nem sikerült olvasni a vágólap tartalmát:', err);
    });
}


 // a nagy search funkció kjk alapján
 
function search() {
	enableKeydownListener();
	
	//alert();
  document.body.style.overflow = 'auto';
  stopMonitoring();


let searchInputValue = document.getElementById('searchInput').value;
  kjkNumjump = searchInputValue;
  
//kjkNumjump = ("and");

processSelectedNumber();

  searchclose();
  
  optionsApopupButtonFunction();
  



function processSelectedNumber() {
	
	
	
  sentences = origcontent.match(/[^.!?]+(?:\.|!|\?)(?=\s|$)/g);

  matchedSentences = sentences.filter(sentence => {
    const regex = new RegExp(`\\b${kjkNumjump}\\b`);
    return regex.test(sentence);
  });


if (matchedSentences.length === 0) {
  
  startTypingAnimation('paragraphId', 'divId', 'The searched term could not be located in the provided content.');
  
}

  if (matchedSentences.length > 0) {
    if (matchedSentences.length > 1) {
      // Több találat esetén buttonokat készítünk és megkérdezzük a felhasználót
      
      if (muteSounds) {
        playany(['snd/kjk jump 20240522_204047.mp3', 'snd/kjk jump 20240522_204105.mp3', 'snd/kjk jump 20240522_204229.mp3', 'snd/kjk jump 20240522_204330.mp3', 'snd/kjk jump 20240522_204438.mp3'], 0.1);
    }
      	readany = ("Több találat.");
    readanytexthun();
    
      

      
      
      const buttonContainer = document.createElement('div');
    buttonContainer.classList.add('button-container');

    matchedSentences.forEach((sentence, index) => {
      const button = document.createElement('button');
      button.classList.add('custom-button'); // Hozzáadjuk az osztályt a buttonhoz
      button.style.zIndex = '9999';
      button.textContent = `Mondat ${index + 1}`;
      button.addEventListener('click', () => {
        handleSentenceSelection(sentence, index);
      });
      buttonContainer.appendChild(button);
    });

    document.body.appendChild(buttonContainer);

    const confirmButton = document.createElement('button');
    confirmButton.textContent = 'Kiválasztom';
    confirmButton.classList.add('customKjk2-button'); // Hozzáadjuk az osztályt a buttonhoz
    confirmButton.style.zIndex = '9999';
    confirmButton.addEventListener('click', () => {
      	
      	playany(['snd/kjk/Coin Spill 03.mp3', 'snd/kjk/Coin Gold 05.mp3', 'Drop Coin 02 gold.mp3', 'snd/kjk/Drop Coin 01.mp3', 'snd/kjk/Drop Coin 03.mp3', 'snd/kjk/Coin Drop Spins Coin.mp3'], 0.4);
      
        buttonContainer.remove();
        confirmButton.remove();
        
        stopSpeaking(); 
      readText();
        // A confirmButton lenyomásakor mentjük el a zagorsave bejegyzést
        const zagorsaveData = localStorage.getItem('zagorsave');
        let zagorsaveEntries = [];
        if (zagorsaveData) {
          zagorsaveEntries = JSON.parse(zagorsaveData);
        }

        const newEntry = `${currentsentencenumber}|${bookname}`;
        zagorsaveEntries.push(newEntry);


if (nyuszino === 0) {
	// itt semmi zagor, ez keresés
       // localStorage.setItem('zagorsave', JSON.stringify(zagorsaveEntries));

}

        // A zagorsave localstorage bejegyzés tartalmának kiírása a konzolra
        console.log('zagorsave localstorage bejegyzés tartalma:');
        zagorsaveEntries.forEach(entry => {
          const [sentenceNumber, bookName] = entry.split('|');
          console.log(`Mondat száma: ${sentenceNumber}, Könyv neve: ${bookName}`);
        });
      });
      buttonContainer.appendChild(confirmButton);

        // Remove buttons if no button is clicked within 5 seconds
    let timer = setTimeout(() => {
      buttonContainer.remove();
      confirmButton.remove();
    }, 63000);
  } else {
      // Egy találat esetén folytatjuk a kódot
      const selectedSentence = matchedSentences[currentIndex];
      console.log(selectedSentence);
      currentIndex++;
      if (currentIndex >= matchedSentences.length) {
        currentIndex = 0;
      }

      document.getElementById('selectedtextblock').innerText = selectedSentence;

      const sentenceIndex = sentences.indexOf(selectedSentence) + 1;
      console.log(`A kiválasztott mondat a(z) ${sentenceIndex}. mondat az origcontentben.`);

      currentsentencenumber = sentenceIndex;

      updateContextBlock();
      document.getElementById('counter').textContent = currentsentencenumber;
      setSliderToCurrentSentence();

      // fantasy hangot ideee
      
      playany(['snd/kjk/Coin Spill 03.mp3', 'snd/kjk/Coin Gold 05.mp3', 'Drop Coin 02 gold.mp3', 'snd/kjk/Drop Coin 01.mp3', 'snd/kjk/Drop Coin 03.mp3', 'snd/kjk/Coin Drop Spins Coin.mp3'], 0.4);
      
      
      readText();

      // A currentsentencenumber és bookname adatok mentése a zagorsave localstorage bejegyzésbe
      const zagorsaveData = localStorage.getItem('zagorsave');
      let zagorsaveEntries = [];
      if (zagorsaveData) {
        zagorsaveEntries = JSON.parse(zagorsaveData);
      }

      const newEntry = `${currentsentencenumber}|${bookname}`;
      zagorsaveEntries.push(newEntry);

      if (nyuszino === 0) {
	// itt semmi zagor, ez keresés
       // localStorage.setItem('zagorsave', JSON.stringify(zagorsaveEntries));

}

      // A zagorsave localstorage bejegyzés tartalmának kiírása a konzolra
      console.log('zagorsave localstorage bejegyzés tartalma:');
      zagorsaveEntries.forEach(entry => {
        const [sentenceNumber, bookName] = entry.split('|');
        console.log(`Mondat száma: ${sentenceNumber}, Könyv neve: ${bookName}`);
      });
    }
  } else {
    console.log('Nem található a szám a mondatokban');
  }
}






function handleSentenceSelection(sentence, index) {
  // A kiválasztott mondat feldolgozása
  console.log(`Kiválasztott mondat: ${sentence}`);
  currentIndex = index;

  document.getElementById('selectedtextblock').innerText = sentence;

  const sentenceIndex = sentences.indexOf(sentence) + 1;
  console.log(`A kiválasztott mondat a(z) ${sentenceIndex}. mondat az origcontentben.`);

  currentsentencenumber = sentenceIndex;

  updateContextBlock();
  document.getElementById('counter').textContent = currentsentencenumber;
  setSliderToCurrentSentence();

  // fantasy hangot ideee
  //playany(['snd/kjk jump 20240522_204047.mp3', 'snd/kjk jump 20240522_204105.mp3', 'snd/kjk jump 20240522_204229.mp3', 'snd/kjk jump 20240522_204330.mp3', 'snd/kjk jump 20240522_204438.mp3'], 0.5);

stopSpeaking(); 
  readText();

/*
  // A currentsentencenumber és bookname adatok mentése a zagorsave localstorage bejegyzésbe
  const zagorsaveData = localStorage.getItem('zagorsave');
  let zagorsaveEntries = [];
  if (zagorsaveData) {
    zagorsaveEntries = JSON.parse(zagorsaveData);
  }

  const newEntry = `${currentsentencenumber}|${bookname}`;
  zagorsaveEntries.push(newEntry);

  localStorage.setItem('zagorsave', JSON.stringify(zagorsaveEntries));

  // A zagorsave localstorage bejegyzés tartalmának kiírása a konzolra
  console.log('zagorsave localstorage bejegyzés tartalma:');
  zagorsaveEntries.forEach(entry => {
    const [sentenceNumber, bookName] = entry.split('|');
    console.log(`Mondat száma: ${sentenceNumber}, Könyv neve: ${bookName}`);
  });
  
  */
}




  function getRandomColor() {
    const letters = '0123456789ABCDEF';
    let color = '#';
    for (let i = 0; i < 6; i++) {
      color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
  }
}


// search end




function textselect() {
  stopMonitoring();

 // let selectedText = document.getElementById('selectedtextblock').innerText;

let selectedText = document.getElementById('contextblock').innerText;


  // Panel létrehozása vagy lekérése
  let panel = document.getElementById('searchwork');
  if (!panel) {
    panel = document.createElement('div');
    panel.id = 'searchwork';

    Object.assign(panel.style, {
      position: 'fixed',
      top: '60%',
      left: '50%',
      transform: 'translate(-50%, -50%)',
      padding: '15px',
      backgroundColor: '#d3d3d3',
      border: '1px solid #888',
      zIndex: '10000',
      maxWidth: '350px',
      maxHeight: '250px',
      overflowY: 'auto',
      boxShadow: '0 0 12px rgba(0,0,0,0.4)',
      fontFamily: 'Arial, sans-serif',
      fontSize: '18px',
      color: '#222',
      borderRadius: '6px',
      cursor: 'default',
      userSelect: 'text',
      lineHeight: '1.4'
    });

    document.body.appendChild(panel);
  }

  // OKÉ gomb létrehozása, ha még nincs
  let okButton = document.getElementById('ok-button');
  if (!okButton) {
    okButton = document.createElement('button');
    okButton.id = 'ok-button';
    okButton.textContent = 'Oké';

    Object.assign(okButton.style, {
      position: 'fixed',
      top: '60%',
      left: 'calc(50% + 190px)', // a panel jobb oldalához igazítva
      transform: 'translateY(-50%)',
      padding: '10px 20px',
      fontSize: '16px',
      cursor: 'pointer',
      zIndex: '10001',
      borderRadius: '6px',
      border: '1px solid #888',
      backgroundColor: '#4CAF50',
      color: 'white',
      boxShadow: '0 2px 6px rgba(0,0,0,0.3)'
    });

    document.body.appendChild(okButton);
  }

  // Panel tartalom törlése és újratöltése
  panel.innerHTML = '';

  // Szavak és szóközök megtartása
  const wordsAndSpaces = selectedText.match(/\S+|\s+/g) || [];

  const wordSpans = [];

  wordsAndSpaces.forEach((part) => {
    if (/\S/.test(part)) {
      const span = document.createElement('span');
      span.textContent = part;
      span.style.userSelect = 'none';
      span.dataset.index = wordSpans.length;
      span.classList.add('word-span');
      panel.appendChild(span);
      wordSpans.push(span);
    } else {
      panel.appendChild(document.createTextNode(part));
    }
  });

  // Kiemeléshez használt osztály
  const highlightClass = 'highlighted-word';

  // CSS hozzáadása a highlight-hoz (ha még nincs)
  if (!document.getElementById('highlight-style')) {
    const style = document.createElement('style');
    style.id = 'highlight-style';
    style.textContent = `
      .${highlightClass} {
        background-color: yellow;
        border-radius: 3px;
      }
      .word-span {
        cursor: pointer;
        transition: background-color 0.2s;
      }
    `;
    document.head.appendChild(style);
  }

  // Sorozatos kijelölésekhez változó
  let lastSelectedIndexes = [];

  // Szavak kattintás esemény kezelője
  panel.querySelectorAll('.word-span').forEach(span => {
    span.addEventListener('click', () => {
      const idx = parseInt(span.dataset.index);

      const isHighlighted = span.classList.contains(highlightClass);

      if (isHighlighted) {
        span.classList.remove(highlightClass);
        lastSelectedIndexes = lastSelectedIndexes.filter(i => i !== idx);
      } else {
        lastSelectedIndexes.push(idx);
        lastSelectedIndexes.sort((a, b) => a - b);

        let isContinuous = true;
        for (let i = 1; i < lastSelectedIndexes.length; i++) {
          if (lastSelectedIndexes[i] !== lastSelectedIndexes[i - 1] + 1) {
            isContinuous = false;
            break;
          }
        }

        if (!isContinuous || lastSelectedIndexes.length > 3) {
          lastSelectedIndexes = [idx];
          wordSpans.forEach(s => s.classList.remove(highlightClass));
          span.classList.add(highlightClass);
        } else {
          wordSpans.forEach(s => s.classList.remove(highlightClass));
          lastSelectedIndexes.forEach(i => {
            wordSpans[i].classList.add(highlightClass);
          });
        }
      }
    });
  });

  // OKÉ gomb kattintás eseményének beállítása
  okButton.onclick = () => {
    lastSelectedIndexes.sort((a, b) => a - b);
    let simot = lastSelectedIndexes.map(i => wordSpans[i].textContent).join(' ');

    console.log('A kijelölt szöveg (simot):', simot);

    // Panel és gomb eltávolítása
    if (panel.parentNode) panel.parentNode.removeChild(panel);
    if (okButton.parentNode) okButton.parentNode.removeChild(okButton);

    // Beállítjuk a keresőmező értékét
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
      searchInput.value = simot;
    } else {
      console.warn('Nincs keresőmező (searchInput) az oldalon!');
    }

    // Meghívjuk a search() függvényt, ami a te logikádat követi
    if (typeof search === 'function') {
    	optionsApopupButtonFunction();
      search();
    } else {
      console.error('A search() függvény nem található!');
    }
  };
}













// multijump

//let kjkNumjump;
let sentences;
  let matchedSentences = [];
  let currentIndex = 0;
  let previousSelectedSentence = '';
  
function kjkMultiJump() {
  stopMonitoring();

  let selectedText = document.getElementById('selectedtextblock').innerText;
  let numberRegex = /\d+/g;
  
  

  let numbers = selectedText.match(numberRegex);

if (numbers) {
  
  if (numbers.length > 1) {
    // többi logika...
  
      var textToRead2 = `Több szám található a szövegben: ${numbers.join(', ')}. `;
      var lang2 = 'hu-HUN';
      var audio2 = new SpeechSynthesisUtterance(textToRead2);
      audio2.lang = lang2;
      audio2.rate = 1;
      audio2.volume = 1;
      audio2.pitch = 1;
      speechSynthesis.speak(audio2);

      // Színes gombok létrehozása a számokhoz
      const numbersContainer = document.createElement('div');
      numbersContainer.style.display = 'flex';
      numbersContainer.style.justifyContent = 'center';
      numbersContainer.style.marginTop = '250px';
      numbersContainer.style.marginLeft = '50px';
      numbersContainer.style.zIndex = '15000'; // Beállítjuk a z-index értékét

      numbers.forEach(number => {
        const button = document.createElement('button');
        button.textContent = number;
        button.style.backgroundColor = getRandomColor();
        button.style.color = 'white';
        button.style.border = 'none';
        button.style.padding = '30px 60px';
        button.style.margin = '0 10px';
        button.style.borderRadius = '5px';
        button.style.cursor = 'pointer';
        button.style.fontSize = '28px';
        button.style.zIndex = '15000'; // Beállítjuk a z-index értékét
        button.addEventListener('click', () => {
          kjkNumjump = number;
          numbersContainer.remove();
          processSelectedNumberMulti();
        });
        numbersContainer.appendChild(button);
      });

      document.body.appendChild(numbersContainer);
    } else {
      kjkNumjump = numbers[0];
      processSelectedNumberMulti();
    }
  } else {
  	
    if (kaland === true) {
    console.log('nincs benne szám');
    const userInput = prompt('Hová ugorjak?');
    if (userInput) {
      kjkNumjump = userInput;
      processSelectedNumberMulti();
    } else {
      console.log('Nem adott meg értéket');
    }
    }
    
  }
}

function processSelectedNumberMulti() {
  sentences = origcontent.match(/[^.!?]+(?:\.||\?)(?=\s|$)/g);

  matchedSentences = sentences.filter(sentence => {
    const regex = new RegExp(`\\b${kjkNumjump}\\b`);
    return regex.test(sentence);
  });

  if (matchedSentences.length > 0) {
    let selectedSentence;
    if (currentIndex >= matchedSentences.length) {
      currentIndex = 0;
    }

    let foundMatch = false;
    while (!foundMatch) {
      selectedSentence = matchedSentences[currentIndex];

      if (selectedSentence === previousSelectedSentence) {
        currentIndex++;
        if (currentIndex >= matchedSentences.length) {
          currentIndex = 0;
        }
      } else {
        foundMatch = true;
      }
    }

    console.log(selectedSentence);

    document.getElementById('selectedtextblock').innerText = selectedSentence;

      const sentenceIndex = sentences.indexOf(selectedSentence) + 1;
      console.log(`A kiválasztott mondat a(z) ${sentenceIndex}. mondat az origcontentben.`);

      currentsentencenumber = sentenceIndex;

      updateContextBlock();
      document.getElementById('counter').textContent = currentsentencenumber;
      setSliderToCurrentSentence();

      // fantasy hangot ideee
      playany(['snd/kjk jump 20240522_204047.mp3', 'snd/kjk jump 20240522_204105.mp3', 'snd/kjk jump 20240522_204229.mp3', 'snd/kjk jump 20240522_204330.mp3', 'snd/kjk jump 20240522_204438.mp3'], 0.5);


      readText();

    // A currentsentencenumber és bookname adatok mentése a zagorsave localstorage bejegyzésbe
    const zagorsaveData = localStorage.getItem('zagorsave');
    let zagorsaveEntries = [];
    if (zagorsaveData) {
      zagorsaveEntries = JSON.parse(zagorsaveData);
    }

    const newEntry = `${currentsentencenumber}|${bookname}`;
    zagorsaveEntries.push(newEntry);

    if (nyuszino === 0) {
	
        localStorage.setItem('zagorsave', JSON.stringify(zagorsaveEntries));

}

    // A zagorsave localstorage bejegyzés tartalmának kiírása a konzolra
    console.log('zagorsave localstorage bejegyzés tartalma:');
    zagorsaveEntries.forEach(entry => {
      const [sentenceNumber, bookName] = entry.split('|');
      console.log(`Mondat száma: ${sentenceNumber}, Könyv neve: ${bookName}`);
    });

    // Eltároljuk az aktuálisan kiválasztott mondatot
    previousSelectedSentence = selectedSentence;
  } else {
    console.log('Nem található a szám a mondatokban');
  }
}








function getRandomColor() {
  const letters = '0123456789ABCDEF';
  let color = '#';
  for (let i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }
  return color;
}







  





 
/*

//selectzagor 1kód indító le gomb itt van kívül

//let intervalId = null;
//let currentsentencenumber = 0; // Kívülre helyezzük a változót

// Eseményfigyelő hozzáadása a dokumentumhoz
document.addEventListener('keydown', (event) => {
  if (event.key === 'ArrowDown') {
    clearInterval(intervalId);
    intervalId = null; // Állítsuk vissza a intervalId-t nullára
  //  alert(currentsentencenumber);
  
  stopSpeaking();  
  
  displaysentence = getSelectedSentence(currentsentencenumber); // Az új kiválasztott mondat lekérése

    if (displaysentence) {
        document.getElementById('selectedtextblock').innerText = displaysentence; // Az új kiválasztott mondat megjelenítése
    }

    updateContextBlock(); // Frissítjük a kontextus blokkot az új kiválasztott mondat körül
    document.getElementById('counter').textContent = currentsentencenumber; // Frissítjük a számlálót az új mondat sorszámával
    setSliderToCurrentSentence(); // Frissítjük a slidert is
    
    
  
  let readpercentage = Math.round((currentsentencenumber / allsentencenumber) * 100);
        readpercentage = (readpercentage + " százalék. ");
        
   // readany = (readpercentage + " ");	
  //  readanytexthun();
  
        playany(['snd/20240523_150534.mp3', 'snd/Free Fantasy Sword Chime Stock Video Footage Download 4K & HD Clips.mp3', 'snd/Free Fantasy Sword Chime Stock Video Footage Download 4K & HD Clips_1716469252083.mp3'], 0.5);
        
    readText();
  }
});

*/


//selectzagor 2 fő kód

let intervalId = null;

function selectzagor() {
  stopMonitoring();

  const zagorsaveData = localStorage.getItem('zagorsave');
  if (!zagorsaveData) {
    console.log('Nincs mentett adat a zagorsave-ben');
    return;
  }

  const zagorsaveEntries = JSON.parse(zagorsaveData);
  let currentIndex = zagorsaveEntries.length - 2; // Az utolsó elem előtti elem legyen az első olvasás

  const currentEntry = zagorsaveEntries[currentIndex];
  const [sentenceNumber, bookName] = currentEntry.split('|');

  console.log(`oldal mentés: ${sentenceNumber}`);
  console.log(`könyv címe: ${bookName}`);

  currentsentencenumber = parseInt(sentenceNumber);

  console.log(currentsentencenumber);

  var textToRead2 = `oldalmentés: ${sentenceNumber}: ${bookName}`;
  var lang2 = 'hu-HUN';
  var audio2 = new SpeechSynthesisUtterance(textToRead2);
  audio2.lang = lang2;
  audio2.rate = 0.81; // Rate beállítása a töltöttség arányában
  audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
  audio2.pitch = 1; // Pitch beállítása a töltöttség arányában
  speechSynthesis.speak(audio2);

  currentIndex--;

  if (currentIndex < 0) {
    currentIndex = zagorsaveEntries.length - 1;
  }

  if (!intervalId) { // Ellenőrizzük, hogy van-e futó időzítő
    intervalId = setInterval(() => {
      const currentEntry = zagorsaveEntries[currentIndex];
      const [sentenceNumber, bookName] = currentEntry.split('|');

      console.log(`A jelenlegi sor mondat száma: ${sentenceNumber}`);
      console.log(`A jelenlegi sor könyv címe: ${bookName}`);

      currentsentencenumber = parseInt(sentenceNumber);

      console.log(currentsentencenumber);

      var textToRead2 = `oldalmentés: ${sentenceNumber}: ${bookName}`;
      var lang2 = 'hu-HUN';
      var audio2 = new SpeechSynthesisUtterance(textToRead2);
      audio2.lang = lang2;
      audio2.rate = 0.81; // Rate beállítása a töltöttség arányában
      audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
      audio2.pitch = 1; // Pitch beállítása a töltöttség arányában
      speechSynthesis.speak(audio2);

      currentIndex--;

      if (currentIndex < 0) {
        currentIndex = zagorsaveEntries.length - 1;
      }
      
      //visszaszámláló univerzális
      startCountdown(14);
      
    }, 15000); // 15 másodperc
  }
}

//let intervalId = null;

function stopzagor() {
  if (intervalId) {
    clearInterval(intervalId);
    intervalId = null;
    console.log('Zagor leállítva');
  } else {
    console.log('Nincs futó zagor');
  }
}



// Toggle Language manuális nyelvválasztó

const manualbuttlang = document.getElementById("manualbuttlang");

let buttonText = "Toggle Language";
let buttonColor = "blue";

manualbuttlang.addEventListener("click", () => {
  if (manuallanguage === "native") {
    manuallanguage = "foreign";
    winner = "en";
    marqueaienghun();
    buttonText = "Switch to native";
    buttonColor = "red";
    manualbuttlang.textContent = buttonText;
    manualbuttlang.style.backgroundColor = buttonColor;
    playany(['snd/button/war of stealth click 1.mp3'], 1);
    startTypingAnimation('paragraphId', 'divId', 'language: ' + ' eng ' + ' hun ');
  } else {
    manuallanguage = "native";
    winner = "hu";
    marqueaihuneng();
    buttonText = "Toggle Language";
    buttonColor = "blue";
    manualbuttlang.textContent = buttonText;
    manualbuttlang.style.backgroundColor = buttonColor;
    playany(['snd/button/war of stealth click 1.mp3'], 1);
    startTypingAnimation('paragraphId', 'divId', 'language: ' + ' hun ' + ' eng ');
  }
});


//    ---   ---   ---   touch érint

// teszteléshez új funkció stb...

document.addEventListener('click', function(event) {
	
	//az event.clientY 400 és 600 közötti legyen
	
    if (event.clientX > window.innerWidth - 200 && event.clientY >= 400 && event.clientY <= 600) {
    // Itt folytathatod a kódodat

        
    }
});



// fullscreen középen

document.addEventListener('click', function(event) {
	
	//az event.clientY 400 és 600 közötti legyen
	
    const squareSize = 300; // A négyzet mérete
const centerX = window.innerWidth / 2; // A böngészőablak középpontja X irányban
const centerY = window.innerHeight / 2; // A böngészőablak középpontja Y irányban

if (
    event.clientX >= centerX - squareSize / 2 && // Bal oldali határ
    event.clientX <= centerX + squareSize / 2 && // Jobb oldali határ
    event.clientY >= centerY - squareSize / 2 && // Felső határ
    event.clientY <= centerY + squareSize / 2    // Alsó határ
) {
    // Kód, ami akkor fut le, ha a feltétel igaz

    // Itt folytathatod a kódodat

//////// kiszedtem mer zavaró 2025 04-kor

if (firsttogglefullscreee === 1) {
	firsttogglefullscreee = 0;
	//////// toggleFullscreen();
      ////////      two();
           //playany(['snd/button/war of stealth click 1.mp3'], 1);
//    startTypingAnimation('paragraphId', 'divId', 'enterFullscreen');
//////// fadeInOutText("fullscreen", 64, 'rgba(70, 40, 231, 1)', 47);
//////// return;
    }
    
    
        
    }
});




  //  touch optoinsA onscreenclick jobbfelső
  
      document.addEventListener('click', function(event) {
    if (event.clientX > window.innerWidth - 200 && event.clientY < 200) {
    
    if (first4shot === 1) {
          	first4shot = 0;
  	playany(['snd/button/Free Switch Sound Effect Download SFX MP3 Library Soundsnap.mp3', 'snd/button/Page 2 Switch Soundsnap.mp3'], 1);
  
  closeNewsDisplayContainer();

  
 // enterFullscreen();
  }
    
    stopSpelling();
        stopSpeaking(); 
        stopzagor();
        stopmanualfavoritdelete();
        stopMusic();
        stopPlayany();
        keyPressCount1 = 0;
        keyPressCount3 = 0;
        
        stopMusic();
        
        optionsApopupButtonFunction();
        favcontclose();
    }
});


// touch ambience toggle lenyomás
  // Ellenőrizzük, hogy a kattintás nem programozott módon történt-e, mert elindítja a button2 által ez is : translateBtn.click(); (megoldás az event.isTrusted)
    
  // touch bal felső 200x200
    //////// kiszedtem mer zavaró 2025 04-kor
    //////// a 2 helyett 200 volt
    
    let ambientePlayed = false;
let clickCountAmbi = 0; // A kattintások számának nyilvántartása

document.addEventListener('click', function(event) {
    if (event.isTrusted) {
        // Ellenőrizzük, hogy a kattintás a bal felső 200x200-as területen történt-e
        if (event.clientX >= 0 && event.clientX < 2 && event.clientY >= 0 && event.clientY < 2) {
            clickCountAmbi++; // Növeljük a kattintások számát
            if (!ambientePlayed) {
                playAmbiance();
                ambientePlayed = true;
            } else if (clickCountAmbi % 3 === 0) {
                playAmbiance();
            } else if (clickCountAmbi % 2 === 0) {
                stopAmbiance();
            }

            // Az egész terület vizuális kiemelése
            const highlightArea = document.createElement('div');
            highlightArea.style.position = 'absolute';
            highlightArea.style.left = '0px'; // A bal felső sarok
            highlightArea.style.top = '0px';  // A bal felső sarok
            highlightArea.style.width = '200px';
            highlightArea.style.height = '200px';
            highlightArea.style.backgroundImage = 'url("./picture/img-ZUPIPm6H9vcyF8SAu52Kw.jpg")'; // Kép beállítása háttérképként
            highlightArea.style.backgroundSize = '150% 150%'; // Kép átméretezése
            highlightArea.style.backgroundRepeat = 'no-repeat'; // Kép ismétlődésének letiltása
            highlightArea.style.backgroundPosition = 'center'; // Kép középre igazítása
            highlightArea.style.borderRadius = '50px'; // Lekerekített sarkok
            highlightArea.style.opacity = '0.3'; // Átlátszóság beállítása
            highlightArea.style.zIndex = '9999'; // A legfelső réteg
            highlightArea.style.animation = 'fadeOut 1s ease-in-out';
            document.body.appendChild(highlightArea);

            // Animáció eltávolítása a DOM-ból
            setTimeout(function() {
                document.body.removeChild(highlightArea);
            }, 1000);
        }
    }
});



/*

Ha például szeretnéd, hogy a playAmbiance() funkció újra lefusson, ha a felhasználó újra a megadott területre kattint, akkor a ambientePlayed változót vissza kell állítanod false-ra. Ezt megteheted például egy gombra kattintva vagy egy időzítő segítségével.

// Gombra kattintva
document.getElementById('resetButton').addEventListener('click', function() {
    ambientePlayed = false;
});

// Időzítővel (pl. 60 másodperc után)
setTimeout(function() {
    ambientePlayed = false;
}, 60000);

*/















// touch book info, time

document.addEventListener('click', function(event) {
    if (event.isTrusted) {
        // A böngésző ablakának szélessége és magassága
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;

        // Ellenőrizzük, hogy a kattintás a bal alsó 200x200-as területen történt-e
        if (event.clientX >= 0 && event.clientX < 200 && 
            event.clientY >= windowHeight - 200 && event.clientY < windowHeight) {
            
            stopSpeaking(); 
            updateCanvasSize(); // Set initial size
            showSpeedometer(); // Call the function to show the speedometer
            
            if (nyuszino === 0) {
                userbookmarksave();
                return;
            }

            hanyora();
            let readpercentage = Math.round((currentsentencenumber / allsentencenumber) * 100);
            readpercentage = (readpercentage + " percent");
            var textToRead2 = readpercentage;
            var lang2 = 'en-ENG';
            var audio2 = new SpeechSynthesisUtterance(textToRead2);
            audio2.lang = lang2;
            audio2.rate = 0.8;
            audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
            audio2.pitch = 1.0;

            // csak fun
            readany = ("yeah."); // lehet funkción kívül, de a funkció nevekre figyelni és Buttonkell
            
            if (firstdomload === 1) {
                console.log('BookIndex: ' + randombooknumber);
                fadeInOutText(randombooknumber, 64, 'rgba(70, 40, 231, 1)', 47);
                bookfavoritindex = randombooknumber;
                var textToRead3 = (randombooknumber + ' ');
                var audio3 = new SpeechSynthesisUtterance(textToRead3);
                speechSynthesis.speak(audio3);
            } else if (firstdomload === 0) {
                console.log('Current Favorite Index: ' + (currentFavoritIndex + 1));
                var textToRead3 = (currentbooknumber + ' ');
                var audio3 = new SpeechSynthesisUtterance(textToRead3);
                speechSynthesis.speak(audio3);
            } else if (firstdomload === 3) {
                console.log('Current Favorite Index: ' + (currentFavoritIndex + 1));
                var textToRead3 = (currentbooknumber + ' ');
                var audio3 = new SpeechSynthesisUtterance(textToRead3);
                speechSynthesis.speak(audio3);
            }

            titletranslate();
            bookpercent();

            // UV info time
            fetch('https://api.weatherapi.com/v1/current.json?key=abd7bd86bde4449ba8c80819230411&q=Nagykata')
                .then(response => response.json())
                .then(data => {
                    const temperature = data.current.temp_c; // Extract temperature in Celsius
                    const uvIndex = data.current.uv; // Extract UV index
                    var localTime = new Date(data.location.localtime);
                    var hours = localTime.getHours();
                    var minutes = localTime.getMinutes();
                    var formattedTime = hours.toString().padStart(2, '0') + ':' + minutes.toString().padStart(2, '0');

                    var fetchedData = `Temp: ${temperature}°C. UV Index: ${uvIndex} _____ ${formattedTime}`;
                    console.log(fetchedData);
                    uvdata = fetchedData;

                    //feliratot is
                    fadeInOutText(uvdata, 26, 'rgba(230, 200, 200, 1)', 76);
                });

            // Az egész terület vizuális kiemelése
            const highlightArea = document.createElement('div');
            highlightArea.style.position = 'absolute';
            highlightArea.style.left = '0px'; // Bal alsó sarok
            highlightArea.style.top = (windowHeight - 200) + 'px'; // Bal alsó sarok
            highlightArea.style.width = '200px';
            highlightArea.style.height = '200px';
            highlightArea.style.backgroundImage = 'url("./picture/e-book-device-title-name-info-infobar-digital-clock--rhythmic-complex-hopeful-captured-throug-108846171.jpg")'; // Kép beállítása háttérképként
            highlightArea.style.backgroundSize = '150% 150%'; // Kép átméretezése
            highlightArea.style.backgroundRepeat = 'no-repeat'; // Kép ismétlődésének letiltása
            highlightArea.style.backgroundPosition = 'center'; // Kép középre igazítása
            highlightArea.style.borderRadius = '20px'; // Lekerekített sarkok
            highlightArea.style.opacity = '0.3'; // Átlátszóság beállítása
            highlightArea.style.zIndex = '9999'; // A legfelső réteg
            highlightArea.style.animation = 'fadeOut 1s ease-in-out';
            document.body.appendChild(highlightArea);

            // Animáció eltávolítása a DOM-ból
            setTimeout(function() {
                document.body.removeChild(highlightArea);
            }, 1000);
        }
    }
});



// touch jobbfelső ALATT 400-ZAL FORDÍTÁSNAK

// Flag a funkció ki- vagy bekapcsolásához
let isClickHandlingActive = false; // true = aktív, false = inaktív

// A kattintás kezelő függvénye
function handleClick(event) {
    if (!isClickHandlingActive) return; // Ha ki van kapcsolva, nem csinál semmit

    if (event.isTrusted) {
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;

        // Ellenőrizzük, hogy a kattintás a jobb felső sarok 600x400 px-es területén történt-e
        if (
            event.clientX >= windowWidth - 600 && event.clientX < windowWidth &&
            event.clientY >= 400 && event.clientY < 800 // 400 + 400
        ) {
            stopSpeaking(); 
            stopMusic();
            stopPlayany();
            muteRadio();

            if (optionsopen === 0) {
                firstdomload = 3;

                if (optionsopen !== 1) {
                    if (winner === "hu") {
                        studyreadTextinfiniteTranslated();
                    } else {
                        studyreadTextinfiniteTranslated();
                    }
                }
            }

            if (optionsopen === 1) {
                // jelenleg nem csinál semmit
            }

            enterFullscreen();

            // Vizuális kiemelés az érintett területre
            const highlightArea = document.createElement('div');
            highlightArea.style.position = 'absolute';
            highlightArea.style.left = (window.innerWidth - 600) + 'px';
            highlightArea.style.top = '400px';
            highlightArea.style.width = '600px';
            highlightArea.style.height = '400px';
            highlightArea.style.backgroundImage = 'url("./picture/raphael-ai-3.jpeg")';
            highlightArea.style.backgroundSize = 'cover';
            highlightArea.style.backgroundRepeat = 'no-repeat';
            highlightArea.style.backgroundPosition = 'center';
            highlightArea.style.borderRadius = '10px';
            highlightArea.style.opacity = '0.3';
            highlightArea.style.zIndex = '9999';
            highlightArea.style.animation = 'fadeOut 1s ease-in-out';

            document.body.appendChild(highlightArea);

            setTimeout(() => document.body.removeChild(highlightArea), 1333);
        }
    }
}

// Event listener hozzáadása
document.addEventListener('click', handleClick);

// A funkció ki- és bekapcsolásához például a böngésző konzolból vagy egy gombra kattintással:
// isClickHandlingActive = false; // kikapcsolja
// isClickHandlingActive = true;  // bekapcsolja



// touch jobb-alsó

document.addEventListener('click', function(event) {
    if (event.isTrusted) {
        // A böngésző ablakának szélessége és magassága
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;

        // Ellenőrizzük, hogy a kattintás a jobb alsó 200x200-as területen történt-e
        if (event.clientX >= windowWidth - 200 && event.clientX < windowWidth && 
            event.clientY >= windowHeight - 200 && event.clientY < windowHeight) {
            
            stopSpeaking(); 
            stopMusic();
        stopPlayany();
        muteRadio();
        
               if (optionsopen === 0) {
    startTypingAnimation('paragraphId', 'divId', 'speak');
    
    	firstdomload = 3;
    //ezzel kár szarakodni settimeres oscilla nem jó egy idő után sehogy se
    	recognition.start();
    }
    
         if (optionsopen === 1) {
         	popup.style.display = 'none'; // Ha látható, akkor elrejtjük
        stopSpeaking();
        randomBooknew();
        
        //playrefreshSound();   // Az oldal teljes újratöltése
      
        
        }
        

            // Az egész terület vizuális kiemelése
            const highlightArea = document.createElement('div');
            highlightArea.style.position = 'absolute';
            highlightArea.style.left = (windowWidth - 200) + 'px'; // Jobb alsó sarok
            highlightArea.style.top = (windowHeight - 200) + 'px'; // Jobb alsó sarok
            highlightArea.style.width = '200px';
            highlightArea.style.height = '200px';
            highlightArea.style.backgroundImage = 'url("./picture/waterproof-bluetooth-speaker-nestled.jpg")'; // Kép beállítása háttérképként
            highlightArea.style.backgroundSize = '150% 150%'; // Kép átméretezése
            highlightArea.style.backgroundRepeat = 'no-repeat'; // Kép ismétlődésének letiltása
            highlightArea.style.backgroundPosition = 'center'; // Kép középre igazítása
            highlightArea.style.borderRadius = '10px'; // Lekerekített sarkok
            highlightArea.style.opacity = '0.3'; // Átlátszóság beállítása
            highlightArea.style.zIndex = '9999'; // A legfelső réteg
            highlightArea.style.animation = 'fadeOut 1s ease-in-out';
            document.body.appendChild(highlightArea);

            // Animáció eltávolítása a DOM-ból
            setTimeout(function() {
                document.body.removeChild(highlightArea);
            }, 1000);
        }
    }
});




// touch kétujjas jobb alsó

// kétujjas érintéssel legyen

document.addEventListener('touchstart', function(event) {
    // Ellenőrizzük, hogy a touch esemény megbízható-e
    if (event.touches.length === 2 && event.isTrusted) {
        // A böngésző ablakának szélessége és magassága
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;

        // Ellenőrizzük, hogy a kattintás a jobb alsó 200x200-as területen történt-e
        const touchX = event.touches[0].clientX; // Az első érintés X koordinátája
        const touchY = event.touches[0].clientY; // Az első érintés Y koordinátája

        if (touchX >= windowWidth - 200 && touchX < windowWidth && 
            touchY >= windowHeight - 200 && touchY < windowHeight) {
            
            stopSpeaking(); 
            
            
            
                popup.style.display = 'none'; // Ha látható, akkor elrejtjük
                
                randomBooknew();
            //startTypingAnimation('paragraphId', 'divId', 'randomBooknew');
fadeInOutText("randomBooknew", 34, 'rgba(70, 10, 201, 0.51)', 60);

            // Az egész terület vizuális kiemelése
            const highlightArea = document.createElement('div');
            highlightArea.style.position = 'absolute';
            highlightArea.style.left = (windowWidth - 200) + 'px'; // Jobb alsó sarok
            highlightArea.style.top = (windowHeight - 200) + 'px'; // Jobb alsó sarok
            highlightArea.style.width = '200px';
            highlightArea.style.height = '200px';
            highlightArea.style.backgroundImage = 'url("./picture/waterproof-bluetooth-speaker-nestled.jpg")'; // Kép beállítása háttérképként
            highlightArea.style.backgroundSize = '150% 150%'; // Kép átméretezése
            highlightArea.style.backgroundRepeat = 'no-repeat'; // Kép ismétlődésének letiltása
            highlightArea.style.backgroundPosition = 'center'; // Kép középre igazítása
            highlightArea.style.borderRadius = '10px'; // Lekerekített sarkok
            highlightArea.style.opacity = '0.3'; // Átlátszóság beállítása
            highlightArea.style.zIndex = '9999'; // A legfelső réteg
            highlightArea.style.animation = 'fadeOut 1s ease-in-out';
            document.body.appendChild(highlightArea);

            // Animáció eltávolítása a DOM-ból
            setTimeout(function() {
                document.body.removeChild(highlightArea);
            }, 1000);
        }
    }
});


// touch 2 ujjas balalsó

document.addEventListener('touchstart', function(event) {
    // Ellenőrizzük, hogy a touch esemény megbízható-e
    if (event.touches.length === 2 && event.isTrusted) {
        // A böngésző ablakának szélessége és magassága
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;

        // Ellenőrizzük, hogy a kattintás a bal alsó 200x200-as területen történt-e
        const touchX = event.touches[0].clientX; // Az első érintés X koordinátája
        const touchY = event.touches[0].clientY; // Az első érintés Y koordinátája

        if (touchX >= 0 && touchX < 200 && 
            touchY >= windowHeight - 200 && touchY < windowHeight) {
            
            stopSpeaking(); 
            popup.style.display = 'none'; // Ha látható, akkor elrejtjük
            randomSentence();
       /*     
            if (winner === "en") {
            readTextinfiniteTranslated();
            }
            if (winner === "hu") {
            readTextinfinite();
            }
          */ 

//startTypingAnimation('paragraphId', 'divId', 'randomSentence');
fadeInOutText("randomSentence", 24, 'rgba(70, 10, 201, 0.51)', 58);

            // Az egész terület vizuális kiemelése
            const highlightArea = document.createElement('div');
            highlightArea.style.position = 'absolute';
            highlightArea.style.left = '0px'; // Bal alsó sarok
            highlightArea.style.top = (windowHeight - 200) + 'px'; // Bal alsó sarok
            highlightArea.style.width = '200px';
            highlightArea.style.height = '200px';
            highlightArea.style.backgroundImage = 'url("./picture/waterproof-bluetooth-speaker-nestled.jpg")'; // Kép beállítása háttérképként
            highlightArea.style.backgroundSize = '150% 150%'; // Kép átméretezése
            highlightArea.style.backgroundRepeat = 'no-repeat'; // Kép ismétlődésének letiltása
            highlightArea.style.backgroundPosition = 'center'; // Kép középre igazítása
            highlightArea.style.borderRadius = '10px'; // Lekerekített sarkok
            highlightArea.style.opacity = '0.3'; // Átlátszóság beállítása
            highlightArea.style.zIndex = '9999'; // A legfelső réteg
            highlightArea.style.animation = 'fadeOut 1s ease-in-out';
            document.body.appendChild(highlightArea);

            // Animáció eltávolítása a DOM-ból
            setTimeout(function() {
                document.body.removeChild(highlightArea);
            }, 1000);
        }
    }
});










        function optionsApopupButtonFunction() {
        	isClickHandlingActive = false; 
        stopReadInfiniteTranslated();
        
        enableKeydownListener();
        
        	keyPressCount = 0; // Move this outside the event listener
            let popup = document.getElementById('popup');
    if (popup.style.display === 'block') {
    	
    if (muteSounds) {
        playRandomSound6();
    }
    	
    
    	optionsopen = 0;
        popup.style.display = 'none'; // Ha látható, akkor elrejtjük
        //meg a többi ablakot is bezárjuk
            favoritPopup.style.display = 'none'; // Elrejti a popup ablakot
            currentFavoritIndex = 0;
            stopMusic();
            stopPlayany();
            searchclose();
        
        
        
        document.body.style.animation = "backgroundSlideOut 1s backwards"; // Animáció alkalmazása a háttérképre
        
        document.body.addEventListener('animationend', function() {
            if (popup.style.display === 'none') {
                document.body.style.backgroundImage = "none"; // Háttérkép eltávolítása csak akkor, ha a popup is rejtve van
            }
        });
    } else {
    	optionsopen = 1;
        popup.style.display = 'block'; // Ha nem látható, akkor megjelenítjük
        
        muteSounds = JSON.parse(localStorage.getItem("muteSounds"));
    if (muteSounds) {
        
gamePlaySound(['snd/atmospheric-metallic-swipe-9-195752.mp3', 'snd/atmospheric-metallic-swipe-8-195750.mp3', 'snd/atmospheric-metallic-swipe-11-195754.mp3'], 1);
    }

        
        
      //  playRandomSound3();
        document.body.style.backgroundImage = "url('./picture/background0.jpg')"; // Háttérkép beállítása background0.jpg-re
        document.body.style.animation = "backgroundSlideIn 1s forwards"; // Animáció alkalmazása a háttérképre
    }
}






// READTEXT ARTIKOLÁCIÓS MOTOR
    
    // =================================================================
// === READTEXT ARTIKULÁCIÓS MOTOR - PREMIUM EDITION ===
// =================================================================

// 1. SZÜNETSZÓTÁR ÉS GLOBÁLIS VÁLTOZÓK
var cocktailPauses = {
    "hogy": [[50, 150], [10, 30]], "mert": [[60, 180], [10, 40]], "hiszen": [[80, 200], [20, 50]],
    "de": [[100, 400], [30, 80]], "viszont": [[120, 350], [40, 90]], "azonban": [[150, 450], [50, 100]],
    "pedig": [[40, 120], [10, 30]], "vagy": [[60, 200], [20, 60]], "tehát": [[150, 300], [60, 120]],
    "így": [[80, 200], [30, 70]], "nos": [[200, 500], [100, 200]], "hát": [[150, 400], [50, 150]],
    "ugye": [[40, 150], [30, 80]], "talán": [[100, 250], [20, 60]], "valóban": [[80, 200], [30, 70]],
    "egyrészt": [[150, 350], [50, 100]], "másrészt": [[150, 350], [50, 100]],
    "ráadásul": [[100, 300], [40, 90]], "mellesleg": [[120, 350], [50, 100]],
    "tulajdonképpen": [[100, 300], [20, 60]], "lényegében": [[100, 300], [20, 60]],
    "amúgy": [[80, 250], [20, 60]], "egyébként": [[80, 250], [20, 60]]
};

var cocktailChunks = [];
var cocktailChunkIndex = 0;
var isCocktailPlaying = false;
var cocktailSessionId = 0;

// Beállítások mentése
var useArticulationEngine = true;
var settingsLoaded = false;

// 2. SEGÉDFÜGGVÉNYEK
function getRnd(range) {
    if (!range) return 0;
    return Math.floor(Math.random() * (range[1] - range[0] + 1)) + range[0];
}

function applyJitter(val, percent = 0.1) {
    const variation = val * percent;
    return val + (Math.random() * variation * 2 - variation);
}

// 3. JAVÍTOTT DARABOLÓ
function splitToCocktailChunks(text) {
    const keywords = Object.keys(cocktailPauses);
    const pattern = new RegExp(`([.!?]+)|(,|;|:)|(\\b(?:${keywords.join('|')})\\b)`, 'gi');
    const rawParts = text.split(pattern);
    return rawParts.filter(part => part !== undefined && part !== "");
}

// 4. A FŐ OLVASÓ FUNKCIÓ (ARTIKULÁCIÓS MOTOR)
async function readTextArticulation() {
    stopSpeaking();
    cocktailSessionId++;
    const currentSession = cocktailSessionId;
    isCocktailPlaying = true;

    let block = document.getElementById('selectedtextblock');
    let rawText = block.textContent || block.innerText;

    if (!rawText || rawText.trim().length === 0) return;

    if (rawText.length > 2000) {
        console.warn("Szöveg túl hosszú, darabolva lesz.");
    }

    cocktailChunks = splitToCocktailChunks(rawText);
    cocktailChunkIndex = 0;

    processNextChunk(currentSession);
}

function processNextChunk(sessionId) {
    if (sessionId !== cocktailSessionId || !isCocktailPlaying) return;

    if (cocktailChunkIndex >= cocktailChunks.length) {
        isCocktailPlaying = false;
        return;
    }

    const chunk = cocktailChunks[cocktailChunkIndex];
    if (chunk.trim().length === 0) {
        cocktailChunkIndex++;
        processNextChunk(sessionId);
        return;
    }

    const cleanChunk = chunk.toLowerCase().replace(/[.!?,;:\s]/g, '');
    const nextChunk = cocktailChunks[cocktailChunkIndex + 1] || "";
    const cleanNext = nextChunk.toLowerCase().replace(/[.!?,;:\s]/g, '');

    if (/^[.,!?;:]+$/.test(chunk.trim())) {
        let punctuationPause = 0;
        if (/[.!?]/.test(chunk)) punctuationPause = getRnd([500, 800]);
        else if (/,/.test(chunk)) punctuationPause = getRnd([200, 400]);
        else punctuationPause = 100;

        cocktailChunkIndex++;
        setTimeout(() => processNextChunk(sessionId), punctuationPause);
        return;
    }

    const utterance = new SpeechSynthesisUtterance(chunk);
    utterance.lang = (typeof winner !== 'undefined' && winner === "hu") ? 'hu-HU' : 'en-US';

    const baseRate = (typeof olvassebesseg !== 'undefined') ? parseFloat(olvassebesseg) : 0.9;
    utterance.rate = applyJitter(baseRate, 0.05);
    utterance.pitch = applyJitter(1.0, 0.05);
    utterance.volume = 1.0;

    utterance.onend = () => {
        if (sessionId !== cocktailSessionId) return;

        let pauseTime = 0;
        if (cocktailPauses[cleanChunk]) {
            pauseTime += getRnd(cocktailPauses[cleanChunk][1]);
        }

        if (cleanNext && cocktailPauses[cleanNext]) {
            pauseTime += getRnd(cocktailPauses[cleanNext][0]);
        }

        if (pauseTime === 0) pauseTime = 10;

        cocktailChunkIndex++;
        setTimeout(() => processNextChunk(sessionId), pauseTime);
    };

    utterance.onerror = (e) => {
        console.error("TTS Hiba:", e);
        cocktailChunkIndex++;
        processNextChunk(sessionId);
    };

    window.speechSynthesis.speak(utterance);
}

// 5. RÉGI PURITÁN FELOLVASÓ
function readTextPuritan() {
    var textToRead = document.getElementById('selectedtextblock').innerText;

    if (textToRead.length > 1000) {
        startTypingAnimation('paragraphId', 'divId', 'The text to be read is too long (more than 1000 words).');
        return;
    }

    var lang = 'en-ENG';
    if (winner === "hu") {
        var lang = 'hu-HUN';
    }

    var audio = new SpeechSynthesisUtterance(textToRead);
    audio.lang = lang;
    audio.rate = olvassebesseg;
    audio.volume = 1;
    audio.pitch = 1.0;

    speechSynthesis.speak(audio);
}

// 6. KREATÍV KÖR IKON ÉS OVERLAY KEZELÉSE
function createSettingsIcon() {
    // Ha van már ikon, távolítsuk el
    const existingIcon = document.getElementById('readSettingsIcon');
    if (existingIcon) {
        existingIcon.style.opacity = '0';
        existingIcon.style.transform = 'scale(0.5) rotate(-90deg)';
        setTimeout(() => {
            if (existingIcon.parentNode) {
                existingIcon.parentNode.removeChild(existingIcon);
            }
        }, 300);
    }

    // Létrehozzuk az új ikont
    const icon = document.createElement('div');
    icon.id = 'readSettingsIcon';
    
    // SVG ikon létrehozása (kreatív, modern)
    icon.innerHTML = `
        <svg width="100%" height="100%" viewBox="0 0 100 100">
            <!-- Külső kör pulsáló animáció -->
            <circle cx="50" cy="50" r="45" fill="none" stroke="url(#grad1)" stroke-width="3" 
                    stroke-dasharray="4,4" opacity="0.8">
                <animate attributeName="r" values="45;48;45" dur="2s" repeatCount="indefinite" />
                <animate attributeName="opacity" values="0.8;0.4;0.8" dur="2s" repeatCount="indefinite" />
            </circle>
            
            <!-- Belső kör -->
            <circle cx="50" cy="50" r="35" fill="url(#grad2)" stroke="white" stroke-width="2">
                <animate attributeName="fill" values="url(#grad2);url(#grad3);url(#grad2)" 
                         dur="3s" repeatCount="indefinite" />
            </circle>
            
            <!-- Hanghullám ikon -->
            <path d="M30,40 L30,60 M40,35 L40,65 M50,30 L50,70 M60,35 L60,65 M70,40 L70,60" 
                  stroke="white" stroke-width="3" stroke-linecap="round">
                <animate attributeName="d" 
                         values="M30,40 L30,60 M40,35 L40,65 M50,30 L50,70 M60,35 L60,65 M70,40 L70,60;
                                 M30,45 L30,55 M40,40 L40,60 M50,35 L50,65 M60,40 L60,60 M70,45 L70,55;
                                 M30,40 L30,60 M40,35 L40,65 M50,30 L50,70 M60,35 L60,65 M70,40 L70,60" 
                         dur="1.5s" repeatCount="indefinite" />
            </path>
            
            <!-- Fogaskerék ikon (beállítások) -->
            <circle cx="50" cy="50" r="15" fill="none" stroke="white" stroke-width="2" stroke-dasharray="20,5">
                <animateTransform attributeName="transform" type="rotate" from="0 50 50" to="360 50 50" 
                                 dur="8s" repeatCount="indefinite" />
            </circle>
            
            <!-- Gradiens definíciók -->
            <defs>
                <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#FF6B9D;stop-opacity:1" />
                    <stop offset="50%" style="stop-color:#4ECDC4;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#45B7D1;stop-opacity:1" />
                </linearGradient>
                <radialGradient id="grad2" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
                    <stop offset="0%" style="stop-color:#FF6B9D;stop-opacity:0.9" />
                    <stop offset="100%" style="stop-color:#4ECDC4;stop-opacity:0.9" />
                </radialGradient>
                <radialGradient id="grad3" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
                    <stop offset="0%" style="stop-color:#45B7D1;stop-opacity:0.9" />
                    <stop offset="100%" style="stop-color:#96CEB4;stop-opacity:0.9" />
                </radialGradient>
            </defs>
        </svg>
    `;
    
    // Kreatív stílus beállítása
    icon.style.cssText = `
        position: fixed;
        top: 20px;
        left: 20px;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        cursor: pointer;
        z-index: 15000 !important;
        box-shadow: 
            0 0 20px rgba(255, 107, 157, 0.6),
            0 0 40px rgba(78, 205, 196, 0.4),
            0 8px 30px rgba(0, 0, 0, 0.3),
            inset 0 0 20px rgba(255, 255, 255, 0.1);
        transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        opacity: 0;
        transform: scale(0) rotate(-180deg);
        overflow: visible;
        filter: drop-shadow(0 5px 15px rgba(0,0,0,0.2));
        animation: floatIcon 3s ease-in-out infinite;
    `;

    // CSS animáció hozzáadása
    const style = document.createElement('style');
    style.textContent = `
        @keyframes floatIcon {
            0%, 100% { transform: translateY(0px) scale(1) rotate(0deg); }
            50% { transform: translateY(-5px) scale(1.05) rotate(5deg); }
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 107, 157, 0.6), 0 0 40px rgba(78, 205, 196, 0.4), 0 8px 30px rgba(0, 0, 0, 0.3); }
            50% { box-shadow: 0 0 30px rgba(255, 107, 157, 0.8), 0 0 60px rgba(78, 205, 196, 0.6), 0 12px 40px rgba(0, 0, 0, 0.4); }
        }
        
        @keyframes sparkle {
            0% { opacity: 0; transform: scale(0); }
            50% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0); }
        }
    `;
    document.head.appendChild(style);

    // Hozzáadjuk az oldalhoz
    document.body.appendChild(icon);

    // Animált belépés
    setTimeout(() => {
        icon.style.opacity = '1';
        icon.style.transform = 'scale(1) rotate(0deg)';
        icon.style.animation = 'floatIcon 3s ease-in-out infinite, glow 2s ease-in-out infinite';
    }, 50);

    // Hover effektek
    icon.addEventListener('mouseenter', () => {
        icon.style.transform = 'scale(1.2) rotate(15deg)';
        icon.style.boxShadow = `
            0 0 40px rgba(255, 107, 157, 0.9),
            0 0 80px rgba(78, 205, 196, 0.7),
            0 15px 50px rgba(0, 0, 0, 0.4),
            inset 0 0 30px rgba(255, 255, 255, 0.2)
        `;
        
        // Sparkle effect hozzáadása hoverkor
        for (let i = 0; i < 8; i++) {
            setTimeout(() => {
                const sparkle = document.createElement('div');
                const angle = (Math.PI * 2 * i) / 8;
                const x = 30 * Math.cos(angle);
                const y = 30 * Math.sin(angle);
                
                sparkle.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    width: 4px;
                    height: 4px;
                    background: white;
                    border-radius: 50%;
                    transform: translate(-50%, -50%) translate(${x}px, ${y}px);
                    animation: sparkle 0.6s ease-out;
                    z-index: 15001;
                    pointer-events: none;
                `;
                
                icon.appendChild(sparkle);
                setTimeout(() => {
                    if (sparkle.parentNode) {
                        sparkle.remove();
                    }
                }, 600);
            }, i * 100);
        }
    });

    icon.addEventListener('mouseleave', () => {
        icon.style.transform = 'scale(1) rotate(0deg)';
        icon.style.boxShadow = `
            0 0 20px rgba(255, 107, 157, 0.6),
            0 0 40px rgba(78, 205, 196, 0.4),
            0 8px 30px rgba(0, 0, 0, 0.3),
            inset 0 0 20px rgba(255, 255, 255, 0.1)
        `;
    });

    // Kattintás esemény
    icon.addEventListener('click', showSettingsOverlay);
    
    // Automatikus eltűnés 1.5 másodperc múlva
    setTimeout(() => {
        if (icon.parentNode) {
            icon.style.opacity = '0';
            icon.style.transform = 'scale(0.5) rotate(180deg)';
            icon.style.boxShadow = 'none';
            setTimeout(() => {
                if (icon.parentNode) {
                    document.body.removeChild(icon);
                }
            }, 500);
        }
    }, 1500);
}

function showSettingsOverlay() {
    if (!settingsLoaded) {
        loadSettings();
    }

    // Ha van overlay, ne hozzunk létre újat
    const existingOverlay = document.getElementById('readSettingsOverlay');
    if (existingOverlay) {
        return;
    }

    // Overlay konténer
    const overlay = document.createElement('div');
    overlay.id = 'readSettingsOverlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, 
            rgba(20, 30, 48, 0.95) 0%, 
            rgba(36, 59, 85, 0.95) 100%);
        backdrop-filter: blur(10px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 15002 !important;
        opacity: 0;
        transition: opacity 0.4s ease;
    `;

    // Beállítások ablak - Glassmorphism stílus
    const settingsWindow = document.createElement('div');
    settingsWindow.style.cssText = `
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(20px);
        padding: 40px;
        border-radius: 24px;
        min-width: 400px;
        max-width: 90%;
        border: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow: 
            0 25px 50px -12px rgba(0, 0, 0, 0.5),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
        transform: translateY(30px);
        opacity: 0;
        transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
    `;

    settingsWindow.innerHTML = `
        <div style="text-align: center; margin-bottom: 30px;">
            <div style="
                width: 80px;
                height: 80px;
                background: linear-gradient(135deg, #FF6B9D, #4ECDC4);
                border-radius: 50%;
                margin: 0 auto 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 36px;
                color: white;
                box-shadow: 0 10px 30px rgba(255, 107, 157, 0.4);
                animation: floatIcon 3s ease-in-out infinite;
            ">
                🔊
            </div>
            <h2 style="
                margin: 0;
                color: white;
                font-family: 'Segoe UI', sans-serif;
                font-size: 28px;
                font-weight: 600;
                letter-spacing: 1px;
                text-shadow: 0 2px 10px rgba(0,0,0,0.3);
            ">
                Voice Engine Selection
            </h2>
            <p style="
                color: rgba(255,255,255,0.7);
                margin: 10px 0 30px;
                font-size: 16px;
            ">
                Choose your preferred reading experience
            </p>
        </div>
        
        <div style="margin: 30px 0;">
            <div class="option-card" data-value="articulation" style="
                background: ${useArticulationEngine ? 
                    'linear-gradient(135deg, rgba(78, 205, 196, 0.2), rgba(69, 183, 209, 0.2))' : 
                    'rgba(255,255,255,0.05)'};
                border: 2px solid ${useArticulationEngine ? '#4ECDC4' : 'rgba(255,255,255,0.1)'};
                border-radius: 16px;
                padding: 25px;
                margin-bottom: 20px;
                cursor: pointer;
                transition: all 0.3s ease;
                position: relative;
                overflow: hidden;
            ">
                <div style="display: flex; align-items: center; gap: 20px;">
                    <div style="
                        width: 60px;
                        height: 60px;
                        background: linear-gradient(135deg, #4ECDC4, #45B7D1);
                        border-radius: 12px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 28px;
                        color: white;
                        flex-shrink: 0;
                    ">
                        🎭
                    </div>
                    <div style="flex: 1;">
                        <div style="
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            margin-bottom: 8px;
                        ">
                            <h3 style="
                                margin: 0;
                                color: white;
                                font-size: 20px;
                                font-weight: 600;
                            ">
                                Articulation Engine
                            </h3>
                            ${useArticulationEngine ? `
                                <div style="
                                    width: 24px;
                                    height: 24px;
                                    border-radius: 50%;
                                    background: #4ECDC4;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    color: white;
                                    font-size: 14px;
                                ">
                                    ✓
                                </div>
                            ` : ''}
                        </div>
                        <p style="
                            color: rgba(255,255,255,0.7);
                            margin: 0;
                            font-size: 15px;
                            line-height: 1.5;
                        ">
                            Advanced AI-powered reading with natural pauses, 
                            expressive articulation and human-like rhythm.
                            <span style="
                                display: inline-block;
                                margin-top: 8px;
                                padding: 4px 12px;
                                background: rgba(78, 205, 196, 0.2);
                                border-radius: 20px;
                                font-size: 13px;
                                color: #4ECDC4;
                            ">
                                RECOMMENDED
                            </span>
                        </p>
                    </div>
                </div>
            </div>
            
            <div class="option-card" data-value="puritan" style="
                background: ${!useArticulationEngine ? 
                    'linear-gradient(135deg, rgba(255, 107, 157, 0.2), rgba(150, 206, 180, 0.2))' : 
                    'rgba(255,255,255,0.05)'};
                border: 2px solid ${!useArticulationEngine ? '#FF6B9D' : 'rgba(255,255,255,0.1)'};
                border-radius: 16px;
                padding: 25px;
                cursor: pointer;
                transition: all 0.3s ease;
                position: relative;
                overflow: hidden;
            ">
                <div style="display: flex; align-items: center; gap: 20px;">
                    <div style="
                        width: 60px;
                        height: 60px;
                        background: linear-gradient(135deg, #FF6B9D, #96CEB4);
                        border-radius: 12px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 28px;
                        color: white;
                        flex-shrink: 0;
                    ">
                        ⚡
                    </div>
                    <div style="flex: 1;">
                        <div style="
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            margin-bottom: 8px;
                        ">
                            <h3 style="
                                margin: 0;
                                color: white;
                                font-size: 20px;
                                font-weight: 600;
                            ">
                                Puritan Engine
                            </h3>
                            ${!useArticulationEngine ? `
                                <div style="
                                    width: 24px;
                                    height: 24px;
                                    border-radius: 50%;
                                    background: #FF6B9D;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    color: white;
                                    font-size: 14px;
                                ">
                                    ✓
                                </div>
                            ` : ''}
                        </div>
                        <p style="
                            color: rgba(255,255,255,0.7);
                            margin: 0;
                            font-size: 15px;
                            line-height: 1.5;
                        ">
                            Original fast reading engine. Clean, direct and efficient 
                            for quick text-to-speech conversion without pauses.
                        </p>
                    </div>
                </div>
            </div>
        </div>
        
        <div style="
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 40px;
        ">
            <button id="saveSettingsBtn" style="
                background: linear-gradient(135deg, #4ECDC4, #45B7D1);
                color: white;
                border: none;
                padding: 16px 40px;
                border-radius: 50px;
                cursor: pointer;
                font-size: 16px;
                font-weight: 600;
                letter-spacing: 1px;
                transition: all 0.3s ease;
                box-shadow: 0 8px 25px rgba(78, 205, 196, 0.4);
                min-width: 160px;
            ">
                💾 Save Settings
            </button>
            <button id="closeSettingsBtn" style="
                background: rgba(255, 255, 255, 0.1);
                color: rgba(255, 255, 255, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.2);
                padding: 16px 40px;
                border-radius: 50px;
                cursor: pointer;
                font-size: 16px;
                font-weight: 600;
                transition: all 0.3s ease;
                min-width: 160px;
            ">
                ✕ Close
            </button>
        </div>
    `;

    settingsWindow.addEventListener('click', (e) => e.stopPropagation());
    overlay.appendChild(settingsWindow);
    document.body.appendChild(overlay);

    // Animált belépés
    setTimeout(() => {
        overlay.style.opacity = '1';
        settingsWindow.style.opacity = '1';
        settingsWindow.style.transform = 'translateY(0)';
    }, 10);

    // Option card hover effects
    const optionCards = settingsWindow.querySelectorAll('.option-card');
    optionCards.forEach(card => {
        card.addEventListener('mouseenter', () => {
            if (!card.classList.contains('selected')) {
                card.style.transform = 'translateY(-5px)';
                card.style.boxShadow = '0 15px 30px rgba(0, 0, 0, 0.2)';
            }
        });
        
        card.addEventListener('mouseleave', () => {
            if (!card.classList.contains('selected')) {
                card.style.transform = 'translateY(0)';
                card.style.boxShadow = 'none';
            }
        });
        
        card.addEventListener('click', () => {
            const value = card.getAttribute('data-value');
            useArticulationEngine = (value === 'articulation');
            
            // Update visual selection
            optionCards.forEach(c => {
                const isSelected = c.getAttribute('data-value') === value;
                c.style.background = isSelected 
                    ? (value === 'articulation' 
                        ? 'linear-gradient(135deg, rgba(78, 205, 196, 0.2), rgba(69, 183, 209, 0.2))'
                        : 'linear-gradient(135deg, rgba(255, 107, 157, 0.2), rgba(150, 206, 180, 0.2))')
                    : 'rgba(255,255,255,0.05)';
                c.style.borderColor = isSelected 
                    ? (value === 'articulation' ? '#4ECDC4' : '#FF6B9D')
                    : 'rgba(255,255,255,0.1)';
            });
        });
    });

    // Button hover effects
    const buttons = settingsWindow.querySelectorAll('button');
    buttons.forEach(button => {
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            if (button.id === 'saveSettingsBtn') {
                button.style.boxShadow = '0 12px 35px rgba(78, 205, 196, 0.6)';
            } else {
                button.style.background = 'rgba(255, 255, 255, 0.2)';
            }
        });
        
        button.addEventListener('mouseleave', () => {
            button.style.transform = 'translateY(0)';
            if (button.id === 'saveSettingsBtn') {
                button.style.boxShadow = '0 8px 25px rgba(78, 205, 196, 0.4)';
            } else {
                button.style.background = 'rgba(255, 255, 255, 0.1)';
            }
        });
    });

    // Eseménykezelők
    const saveBtn = document.getElementById('saveSettingsBtn');
    const closeBtn = document.getElementById('closeSettingsBtn');

    saveBtn.addEventListener('click', () => {
        saveSettings();
        
        // Sikeres mentés jelzése
        const savedMsg = document.createElement('div');
        savedMsg.innerHTML = `
            <div style="
                width: 60px;
                height: 60px;
                background: linear-gradient(135deg, #4ECDC4, #45B7D1);
                border-radius: 50%;
                margin: 0 auto 15px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 30px;
                color: white;
                animation: floatIcon 2s ease-in-out infinite;
            ">
                ✓
            </div>
            <div style="color: white; font-size: 18px; font-weight: 600;">
                Settings Saved!
            </div>
        `;
        savedMsg.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: rgba(20, 30, 48, 0.95);
            backdrop-filter: blur(20px);
            padding: 30px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 15003;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        `;
        document.body.appendChild(savedMsg);
        
        setTimeout(() => {
            savedMsg.style.transform = 'translate(-50%, -50%) scale(1)';
        }, 10);
        
        setTimeout(() => {
            savedMsg.style.transform = 'translate(-50%, -50%) scale(0)';
            setTimeout(() => {
                if (savedMsg.parentNode) {
                    document.body.removeChild(savedMsg);
                }
            }, 500);
        }, 1500);
        
        // Eltávolítjuk az overlay-t
        if (overlay.parentNode) {
            overlay.style.opacity = '0';
            settingsWindow.style.transform = 'translateY(30px)';
            settingsWindow.style.opacity = '0';
            setTimeout(() => {
                if (overlay.parentNode) {
                    document.body.removeChild(overlay);
                }
            }, 500);
        }
    });

    closeBtn.addEventListener('click', () => {
        if (overlay.parentNode) {
            overlay.style.opacity = '0';
            settingsWindow.style.transform = 'translateY(30px)';
            settingsWindow.style.opacity = '0';
            setTimeout(() => {
                if (overlay.parentNode) {
                    document.body.removeChild(overlay);
                }
            }, 500);
        }
    });

    overlay.addEventListener('click', () => {
        if (overlay.parentNode) {
            overlay.style.opacity = '0';
            settingsWindow.style.transform = 'translateY(30px)';
            settingsWindow.style.opacity = '0';
            setTimeout(() => {
                if (overlay.parentNode) {
                    document.body.removeChild(overlay);
                }
            }, 500);
        }
    });
}

// 7. BEÁLLÍTÁSOK MENTÉSE ÉS BETÖLTÉSE
function saveSettings() {
    try {
        localStorage.setItem('readerSettings', JSON.stringify({
            useArticulationEngine: useArticulationEngine
        }));
        console.log('Beállítások mentve:', { useArticulationEngine });
    } catch (e) {
        console.error('Hiba a beállítások mentésekor:', e);
    }
}

function loadSettings() {
    try {
        const saved = localStorage.getItem('readerSettings');
        if (saved) {
            const settings = JSON.parse(saved);
            useArticulationEngine = settings.useArticulationEngine !== undefined ? settings.useArticulationEngine : true;
        }
        settingsLoaded = true;
        console.log('Beállítások betöltve:', { useArticulationEngine });
    } catch (e) {
        console.error('Hiba a beállítások betöltésekor:', e);
        useArticulationEngine = true;
    }
}

// 8. STOP FUNKCIÓ
function stopSpeaking() {
    isCocktailPlaying = false;
    cocktailSessionId++;
    window.speechSynthesis.cancel();
}

// 9. FŐ READTEXT FUNKCIÓ (KÖZÖS INTERFÉSZ)
function readText() {
    // MINDIG megjelenítjük a kreatív ikont
    createSettingsIcon();
    
    if (!settingsLoaded) {
        loadSettings();
    }
    
    if (useArticulationEngine) {
        readTextArticulation();
    } else {
        readTextPuritan();
    }
}

// 10. INICIALIZÁLÁS
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', loadSettings);
} else {
    loadSettings();
}

// 11. KÜLSŐ HÍVÁSRA IS ELÉRHETŐ
window.showReaderSettings = showSettingsOverlay;
    
    
// READTEXT END    
    
    
    
    
    
    
    
    
    
    
   function olvasseb() {



if (toggleolvassebessegon === 0) {
	toggleolvassebessegon = 1;
          playany(['snd/button/Free Switch Sound Effect Download SFX MP3 Library Soundsnap.mp3', 'snd/button/Page 2 Switch Soundsnap.mp3'], 1);
    
    
      
      
      randomNumber = rndmaker(10, 40);
      randomNumber = (randomNumber / 100);
            olvassebesseg = randomNumber;
//olvassebesseg = 0.3;
            startTypingAnimation('paragraphId', 'divId', 'olvasási sebesség lassú ' + olvassebesseg);
            
           // fadeInOutText('olvasási sebesség lassú ' + olvassebesseg, 44, 'rgba(220, 0, 0, 1)', 50);
        
    }
   else if (toggleolvassebessegon === 1) { 
   	toggleolvassebessegon = 0;
    playany(['snd/button/Free Switch Sound Effect Download SFX MP3 Library Soundsnap.mp3', 'snd/button/Page 2 Switch Soundsnap.mp3'], 1);
    
      startTypingAnimation('paragraphId', 'divId', 'olvasási sebesség default');
        olvassebesseg = 0.8;
    
    }


}
   
   //folyamatos read
   
var isReadingInfinite = false;
var timeoutId;
var currentReadingFunction = null; // Nyomon követi, hogy melyik funkció fut

function readTextinfiniteTranslated() {
  twotoinfiniteread();

const newText = bookname + " function readTextinfiniteTranslated";
    document.querySelector('.scroll-left p').textContent = newText;

  setTimeout(function() {
    var textToRead = document.getElementById('translated').innerText;

    if (textToRead.length > 1000) {
      startTypingAnimation('paragraphId', 'divId', 'The text to be read is too long (more than 1000 words).');
      return; // Exit the function if text is too long
    }

    var lang = 'hu-HUN';
    if (winner === "hu") {
      lang = 'en-ENG';
    }



    if (textToRead.includes('?')) {
    
readany = ("Kérdő mondat. ");	
    readanytexthun();
}

if (textToRead.includes('!')) {
    
      readany = ("Felkiáltó mondat. ");	
    readanytexthun();
}  
    

    var audio = new SpeechSynthesisUtterance(textToRead);
    audio.lang = lang;
    //audio.rate = Math.random() * 0.5 + 0.5; // Random rate between 0.5 and 1
    
    // Véletlenszerű sebesség generálása 1.2 és 1.6 között
//audio.rate = Math.random() * (1.6 - 1.2) + 1.2;

// Véletlenszerű sebesség generálása 0.7 és 0.97 között
audio.rate = Math.random() * (0.97 - 0.7) + 0.7;

    audio.volume = 1;
    audio.pitch = 1.0;

    audio.onend = function(event) {
      //var delay = Math.floor(Math.random() * 4) + 2; // Random delay between 2 and 6
      
      //var delay = Math.random() * 2.5 + 0.5; // Random delay between 0.5 and 3

var delay = Math.random() * 1.5; // Random delay between 0 and 1.5

//var delay = 0; 

      if (isReadingInfinite) {
        timeoutId = setTimeout(function() {
          threeinfinitenek();
          readTextinfiniteTranslated(); // Recursive call after delay
        }, delay * 1000); // Call after the random delay
      }
    }

    speechSynthesis.speak(audio);

    audio.onerror = function(event) {
      clearTimeout(timeoutId); // Cancel the next scheduled reading on error
    }

    isReadingInfinite = true;
    currentReadingFunction = 'translated'; // Set the current reading function
  }, 2000); // Wait for 2 seconds for twotoinfiniteread to complete
}






//////////



function threenumberrepeat() {
        	
        bookmarksave();
        
        if (currentsentencenumber === allsentencenumber) { 
    	playRandomSound();}//ide jöhet system AI szöveg
   
    	 if (currentsentencenumber === (allsentencenumber-1)) { 
    	playRandomSound();}
    if (currentsentencenumber < allsentencenumber) {
        currentsentencenumber++; // Növeljük a jelenlegi mondat sorszámát eggyel
        displaysentence = getSelectedSentence(currentsentencenumber); // Az új kiválasztott mondat lekérése

        if (displaysentence) {
            document.getElementById('selectedtextblock').innerText = displaysentence; // Az új kiválasztott mondat megjelenítése
        }

        updateContextBlock(); // Frissítjük a kontextus blokkot az új kiválasztott mondat körül
        document.getElementById('counter').textContent = currentsentencenumber; // Frissítjük a számlálót az új mondat sorszámával
        setSliderToCurrentSentence(); // Frissítjük a slidert is
        
        
        
       var currsen = document.getElementById('selectedtextblock').innerText;

    
        
        
    }
    bookpercent2();
}









///////

function readTextinfinite() {
  var textToRead = document.getElementById('selectedtextblock').innerText;

  if (textToRead.length > 1000) {
    startTypingAnimation('paragraphId', 'divId', 'The text to be read is too long (more than 1000 words).');
    return;
  }

  if (textToRead.includes('?')) {
    readany = "Kérdő mondat.";
    readanytexthun();
  }

  if (textToRead.includes('!')) {
    readany = "Felkiáltó mondat.";
    readanytexthun();
  }

  var lang = 'en-ENG';
  if (winner === "hu") {
    lang = 'hu-HUN';
  }

  // Olvassuk ki a késleltetés slider értékét, alap 0.6 (60%), itt 0 és 1 között érték
  var delayRatio = parseFloat(localStorage.getItem('delayRatio'));
  if (isNaN(delayRatio)) delayRatio = 0.6;

  

  var audio = new SpeechSynthesisUtterance(textToRead);
  audio.lang = lang;
  audio.rate = parseFloat(localStorage.getItem('olvassebesseg')) || 1;
  audio.volume = 1;
  audio.pitch = 1.0;

  audio.onend = function(event) {
    var timeoutDelay;
    // delayRatio határozza meg, hogy melyik almód legyen
    if (Math.random() < delayRatio) {
      timeoutDelay = 0; // nodelay almód
    } else {
      var minDelay = 1.5;
      var maxDelay = 2.0;
      timeoutDelay = Math.random() * (maxDelay - minDelay) + minDelay; // delay almód
    }

    console.log("A késleltetés értéke: " + timeoutDelay + " másodperc");

    timeoutId = setTimeout(function() {
      threeinfinitenek();
      readTextinfinite();
    }, timeoutDelay * 1000);
  }

  speechSynthesis.speak(audio);

  audio.onerror = function(event) {
    clearTimeout(timeoutId);
  }

  isReadingInfinite = true;
  currentReadingFunction = 'infinite';
}



//Ez a funkció az aktuális olvasási sebességet a localStorage-ból olvassa ki, így összhangban van a gyorsabb funkcióval, amely ugyanezt az értéket állítja be.
//Ebben a változatban a onend eseménynél először egy véletlenszám dönti el (60% eséllyel), hogy a késleltetés nulla legyen (nodelay almód), vagy véletlenszerű érték 1.5-2 másodperc között (delay almód). Így a késleltetés random, de 60% eséllyel nincs várakozás
  //var delay = Math.floor(Math.random() * 4) + 2; // Random delay between 2 and 6
      
      //var delay = Math.random() * 2.5 + 0.5; // Random delay between 0.5 and 3

//var delay = Math.random() * 1.5; // Random delay between 0 and 1.5

//var delay = Math.random() * 1.5 + 0.5; // Random delay between 0.5 and 2 ez a standard

//var delay = 0; 
  





/**
 * Létrehozza és megjeleníti a 'ReadTextInfinite Options' modális ablakot,
 * amely 6 másodperc után automatikusan bezáródik.
 */
function readtextinfiniteoptionsmodal() {
  // 1. ELŐKÉSZÍTÉS ÉS KORÁBBI MODÁL ELTÁVOLÍTÁSA
  const existingModal = document.getElementById('readTextInfiniteOptionsModal');
  if (existingModal) {
    //existingModal.remove();
  }

  // 2. OVERLAY (Háttér) LÉTREHOZÁSA
  const overlay = document.createElement('div');
  overlay.id = 'readTextInfiniteOptionsModal';
  Object.assign(overlay.style, {
    position: 'fixed',
    top: 0, // MARAD
    left: 0,
    width: '100vw',
    height: '100vh',
    backgroundColor: 'rgba(0, 0, 50, 0.5)', 
    zIndex: 10500,
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    opacity: 0,
    transition: 'opacity 0.3s ease',
    pointerEvents: 'auto',
  });

  // 3. MODÁLIS ABLAK (Tartalom konténer) LÉTREHOZÁSA
  const modal = document.createElement('div');
  Object.assign(modal.style, {
    backgroundColor: 'rgba(200, 220, 255, 0.85)', 
    borderRadius: '16px',
    padding: '30px',
    width: '450px',
    height: '700px',
   // left: '90px',
    boxShadow: '0 12px 48px rgba(0,0,80,0.3)',
    position: 'relative',
    transform: 'scale(0.9)',
    transition: 'transform 0.3s ease',
    fontSize: '18px',
    fontFamily: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
    color: '#0a0a23',
  });

  // Animáció: modál beúszása
  setTimeout(() => {
    overlay.style.opacity = '1';
    modal.style.transform = 'scale(1)';
  }, 10);

  // 4. CÍM
  const title = document.createElement('h2');
  title.textContent = 'ReadTextInfinite Options';
  Object.assign(title.style, {
    marginTop: 0, // MARAD
    marginBottom: '20px',
    fontWeight: '700',
    fontSize: '1.8rem',
    color: '#05294d',
    textAlign: 'center',
  });

  // --- DELAY MÓD BEÁLLÍTÁS ---

  const delayBlock = document.createElement('div');
  // MÓDOSÍTÁS: marginTop az elválasztáshoz
  Object.assign(delayBlock.style, {
      marginTop: '60px', // ÚJ: Elválasztás felülről
      marginBottom: '10px' // Részleges marginBottom megtartása
  });

  const delayLabel = document.createElement('label');
  delayLabel.textContent = 'Delay mód arány (nodelay valószínűsége):';
  delayLabel.htmlFor = 'delayRatioSlider';
  delayLabel.style.display = 'block';
  delayLabel.style.marginBottom = '10px';
  delayLabel.style.fontSize = '1.1rem';

  const delaySlider = document.createElement('input');
  delaySlider.type = 'range';
  delaySlider.min = '0';
  delaySlider.max = '1';
  delaySlider.step = '0.01';
  delaySlider.value = localStorage.getItem('delayRatio') ?? 0.6;
  delaySlider.id = 'delayRatioSlider';
  
  // SLIDER STÍLUS
  Object.assign(delaySlider.style, {
    width: '100%',
    marginTop: '180px', // MARAD
  });

  const delayValue = document.createElement('div');
  delayValue.textContent = `${(parseFloat(delaySlider.value) * 100).toFixed(0)}%`;
  delayValue.style.textAlign = 'right';
  delayValue.style.fontWeight = 'bold';
  delayValue.style.fontSize = '1.05rem';
  delayValue.style.marginBottom = '7px';

  // Automatikus mentés pipálható checkbox és label
  const autoSaveContainer = document.createElement('div');
  Object.assign(autoSaveContainer.style, {
    display: 'flex',
    alignItems: 'center',
  });

  const autoSaveCheckbox = document.createElement('input');
  autoSaveCheckbox.type = 'checkbox';
  autoSaveCheckbox.id = 'autoSaveCheckbox';
  autoSaveCheckbox.checked = localStorage.getItem('autoSaveEnabled') === 'true';

  const autoSaveLabel = document.createElement('label');
  autoSaveLabel.textContent = 'Automatikus mentés';
  autoSaveLabel.htmlFor = 'autoSaveCheckbox';
  autoSaveLabel.style.marginLeft = '50px';
  autoSaveLabel.style.userSelect = 'none';
  autoSaveLabel.style.fontSize = '1rem';
  autoSaveLabel.style.marginTop = '40px';

  autoSaveContainer.appendChild(autoSaveCheckbox);
  autoSaveContainer.appendChild(autoSaveLabel);

  // Delay eseménykezelők
  delaySlider.addEventListener('input', () => {
    delayValue.textContent = `${(parseFloat(delaySlider.value) * 100).toFixed(0)}%`;
    if (autoSaveCheckbox.checked) {
      localStorage.setItem('delayRatio', delaySlider.value);
    }
  });

  autoSaveCheckbox.addEventListener('change', () => {
    localStorage.setItem('autoSaveEnabled', autoSaveCheckbox.checked);
    if (autoSaveCheckbox.checked) {
      localStorage.setItem('delayRatio', delaySlider.value);
    }
  });

  delayBlock.appendChild(delayLabel);
  delayBlock.appendChild(delaySlider);
  delayBlock.appendChild(delayValue);
  delayBlock.appendChild(autoSaveContainer);

  // --- SEBESSÉG BEÁLLÍTÁS ---

  const speedBlock = document.createElement('div');
  // MÓDOSÍTÁS: marginTop az elválasztáshoz
  Object.assign(speedBlock.style, {
    marginTop: '20px', // ÚJ: Elválasztás felülről
    marginBottom: '10px' // Részleges marginBottom megtartása
  });

  const speedLabel = document.createElement('label');
  speedLabel.textContent = 'Olvasási sebesség:';
  speedLabel.htmlFor = 'readSpeedSlider';
  speedLabel.style.display = 'block';
  speedLabel.style.marginBottom = '10px';
  speedLabel.style.fontSize = '1.1rem';

  const speedSlider = document.createElement('input');
  speedSlider.type = 'range';
  speedSlider.min = '0.1';
  speedSlider.max = '5';
  speedSlider.step = '0.1';
  speedSlider.value = localStorage.getItem('olvassebesseg') ?? 1;
  speedSlider.id = 'readSpeedSlider';

  // SLIDER STÍLUS
  Object.assign(speedSlider.style, {
    width: '100%',
    marginTop: '129px', // MARAD
  });

  const speedValue = document.createElement('div');
  speedValue.textContent = speedSlider.value;
  speedValue.style.textAlign = 'right';
  speedValue.style.fontWeight = 'bold';
  speedValue.style.fontSize = '1.05rem';

  // Speed eseménykezelő
  speedSlider.addEventListener('input', () => {
    speedValue.textContent = speedSlider.value;
    localStorage.setItem('olvassebesseg', speedSlider.value);
  });

  speedBlock.appendChild(speedLabel);
  speedBlock.appendChild(speedSlider);
  speedBlock.appendChild(speedValue);

  // *** Eltávolítottam a Bezárás gombot. ***

  // 5. DOM-BAN VALÓ ELHELYEZÉS
  modal.appendChild(title);
  modal.appendChild(delayBlock);
  modal.appendChild(speedBlock);
  // *** Eltávolítottam a 'closeButton' hozzáadását a modálhoz. ***
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  // MÓDOSÍTÁS: Automatikus bezárás 6 másodperc (6000 ms) után
  setTimeout(closeReadTextInfiniteOptionsModal, 6000);
}

function closeReadTextInfiniteOptionsModal() {
  const overlay = document.getElementById('readTextInfiniteOptionsModal');
  if (overlay) {
    const modal = overlay.firstChild;
    overlay.style.opacity = '0';
    modal.style.transform = 'scale(0.9)';
    setTimeout(() => {
      if (document.body.contains(overlay)) {
        document.body.removeChild(overlay);
      }
    }, 300);
  }
}










function stopReadInfiniteTranslated() {
  isReadingInfinite = false;
  speechSynthesis.cancel(); // Stop the current speech synthesis
  clearTimeout(timeoutId); // Cancel the next scheduled reading

  // Reset the current reading function
  currentReadingFunction = null; 
}



// folyamatosan angolul és magyarul is

function studyreadTextinfiniteTranslated() {
  // Step 1: Read the selected text in Hungarian
  var textToRead = document.getElementById('selectedtextblock').innerText;

  if (textToRead.length > 1000) {
    startTypingAnimation('paragraphId', 'divId', 'The text to be read is too long (more than 1000 words).');
    return; // Exit the function if text is too long
  }

  var lang = 'en-ENG';
  
  if (winner === "hu") {
    lang = 'hu-HUN';
  }
  
  var audio = new SpeechSynthesisUtterance(textToRead);
  audio.lang = lang;
  audio.rate = Math.random() * 0.4 + 0.3; // Random rate between 0.3 and 0.7
  
  
  if (winner === "hu") {
    audio.rate = Math.random() * 0.5 + 0.5; // Random rate between 0.5 and 1
  }
  
  audio.volume = 1;
  audio.pitch = 1.0;

  audio.onend = function(event) {
    // Step 2: After reading Hungarian text, translate and read the English version
    twotoinfiniteread(); // Call the translation function

    setTimeout(function() {
      translatedText = document.getElementById('translated').innerText;

      if (translatedText.length > 1000) {
        startTypingAnimation('paragraphId', 'divId', 'The text to be read is too long (more than 1000 words).');
        return; // Exit the function if text is too long
      }



      var translatedLang = 'hu-HUN';
  if (winner === "hu") {
    translatedLang = 'en-ENG';
  }
  
      var translatedAudio = new SpeechSynthesisUtterance(translatedText);
      translatedAudio.lang = translatedLang;
      
      translatedAudio.rate = Math.random() * 0.5 + 0.5; // Random rate between 0.5 and 1
      
      if (winner === "hu") {
    translatedAudio.rate = Math.random() * 0.4 + 0.3; // Random rate between 0.3 and 0.7 vagyis lassabb
  }
      
      translatedAudio.volume = 1;
      translatedAudio.pitch = 1.0;

      translatedAudio.onend = function(event) {
        // Step 3: Proceed to the next sentence after reading the translation
        var delay = Math.floor(Math.random() * 4) + 2; // Random delay between 2 and 6
        timeoutId = setTimeout(function() {
          threeinfinitenek(); // Move to the next sentence
          studyreadTextinfiniteTranslated(); // Recursive call after delay
        }, delay * 1000); // Call after the random delay
      }

      speechSynthesis.speak(translatedAudio);

      translatedAudio.onerror = function(event) {
        clearTimeout(timeoutId); // Cancel the next scheduled reading on error
      }

    }, 2000); // Wait for 2 seconds for twotoinfiniteread to complete
  }

  speechSynthesis.speak(audio);

  audio.onerror = function(event) {
    clearTimeout(timeoutId); // Cancel the next scheduled reading on error
  }

  isReadingInfinite = true;
  currentReadingFunction = 'translated'; // Set the current reading function
}

    
    
    
    
    
    
    function readTranslatedText() {
    	
    	setTimeout(function() {
    var textToRead = document.getElementById('translated').innerText;
    
    if (textToRead.length > 1000) {
  	
  startTypingAnimation('paragraphId', 'divId', 'The text to be read is too long (more than 1000 words).');
  
   // alert("A felolvasandó szöveg túl hosszú (több mint 1000 karakter).");
    return; // Kilépünk a funkcióból, nem olvassuk fel a szöveget
  }
    
    var lang = 'hu-HUN';
    
if (winner === "hu") {
  var lang = 'en-ENG';
}
    
var audio = new SpeechSynthesisUtterance(textToRead);
audio.lang = lang;
audio.rate = 0.8 + Math.random() * 0.1; // 0.8 és 0.9 között random érték
audio.volume = 1;
audio.pitch = 1.0;

speechSynthesis.speak(audio)

    }, 1600); // 2 másodperc várakozás mert egyszerűen nem látja
}





    
    
function readrepeatText() {
	
      var textToRead = document.getElementById('selectedtextblock').innerText; // A kiválasztott szöveg lekérése
         if (winner === "hu") {
      //var textToRead = document.getElementById('translated').innerText;
      // változtatva a magyart olvassa inkább
      var textToRead = document.getElementById('selectedtextblock').innerText;
        }
      
      var lang = 'en-ENG';
      if (winner === "hu") {
        var lang = 'en-ENG';
         // változtatva ez is a magyarul
         var lang = 'hu-HUN';
        }
        
      //var lang = 'en-ENG';
      //var lang = 'hu-HUN'; // Alapértelmezett nyelv beállítása
      //var lang = 'de-DE';
      //var lang = 'es-ES';
      var audio = new SpeechSynthesisUtterance(textToRead);
      audio.lang = lang;
      audio.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
      audio.pitch = 1.0;
      
      var randomRate = 0.2 + Math.random() * 0.8;
audio.rate = randomRate;
  if (winner === "hu") {
        
         // változtatva még ez is magyarul nem kell annyira lassítani
         var randomRate = 0.7 + Math.random() * 0.25; //0.7 és 0.95 közötti intervallumra
         console.log(randomRate);
    //  var randomRate = 1.3;
      audio.rate = randomRate;
        }

      speechSynthesis.speak(audio);
    }
    
    
    function readrepeatTextfor4button() {
	// kicsit gyorsabb legyen
	
      var textToRead = document.getElementById('selectedtextblock').innerText; // A kiválasztott szöveg lekérése
         if (winner === "hu") {
      //var textToRead = document.getElementById('translated').innerText;
      // változtatva a magyart olvassa inkább
      var textToRead = document.getElementById('selectedtextblock').innerText;
        }
      
      var lang = 'en-ENG';
      if (winner === "hu") {
        var lang = 'en-ENG';
         // változtatva ez is a magyarul
         var lang = 'hu-HUN';
        }
        
      //var lang = 'en-ENG';
      //var lang = 'hu-HUN'; // Alapértelmezett nyelv beállítása
      //var lang = 'de-DE';
      //var lang = 'es-ES';
      var audio = new SpeechSynthesisUtterance(textToRead);
      audio.lang = lang;
      audio.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
      audio.pitch = 1.0;
      
      var randomRate = 0.8 + Math.random() * 0.1;
audio.rate = randomRate;
  if (winner === "hu") {
        
         // változtatva még ez is magyarul nem kell annyira lassítani
         var randomRate = 0.7 + Math.random() * 0.25; //0.7 és 0.95 közötti intervallumra
         console.log(randomRate);
    //  var randomRate = 1.3;
      audio.rate = randomRate;
        }

      speechSynthesis.speak(audio);
    }
    
    
    // -----   soundbank  ------
    
    
function stopMusic() {
    if (currentSound) {
        currentSound.pause(); // Megállítja a hang lejátszását
        currentSound.currentTime = 0; // Visszaállítja a hangot az elejére
    }
}
    
    
 var sound1 = new Audio('snd/noleftpage2.wav');
 var sound2 = new Audio('snd/noleftpage1.mp3');

// Hangerő beállítása mindkét hangfájl esetén 50%-ra
sound1.volume = 1;
sound2.volume = 1;

function playRandomSound() {
    var randomIndex = Math.random() < 0.5 ? sound1 : sound2;
    randomIndex.play();
    randomIndex.onended = function() {
        // Esemény utáni teendők
    };
}

// oldalfrissítéskori sound
function playrefreshSound() {
	/*
    var randomIndex = Math.random() < 0.5 ? sound1 : sound2;
    randomIndex.play();
    randomIndex.onended = function() {
        // A hang lejátszása után történő oldalfrissítés
       // location.reload();
        
        window.location.href = "reader a 3.html";
        
        
    };
    */
    navigator.clipboard.writeText("");
        window.location.href = "reader a 3.html";
}



    var sound3 = new Audio('snd/atmospheric-metallic-swipe-9-195752.mp3');
    var sound4 = new Audio('snd/atmospheric-metallic-swipe-8-195750.mp3');
    var sound5 = new Audio('snd/atmospheric-metallic-swipe-11-195754.mp3');

// Hangerő beállítása mindkét hangfájl esetén 50%-ra
sound3.volume = 1;
sound4.volume = 1;
sound5.volume = 1;

function playRandomSound3() {
	var sounds = [sound3, sound4, sound5];
    var randomIndex = Math.floor(Math.random() * sounds.length);
    sounds[randomIndex].play();
    sounds[randomIndex].onended = function() {
        // Esemény utáni teendők
    };
}


    var sound6 = new Audio('snd/atmospheric-metallic-swipe-15-195757.mp3');
    var sound7 = new Audio('snd/atmospheric-metallic-swipe-11-195754 pitch -4,10 - tempo 176.mp3');
    
// Hangerő beállítása mindkét hangfájl esetén 50%-ra
sound6.volume = 0.57;
sound7.volume = 1;


    function playRandomSound6() {
	var sounds = [sound6, sound7];
    var randomIndex = Math.floor(Math.random() * sounds.length);
    sounds[randomIndex].play();
    sounds[randomIndex].onended = function() {
        // Esemény utáni teendők
    };
}
    
    
    var sound8 = new Audio('snd/i-am-dreaming-or-final-fantasy-menu-kinda-thing-29173.mp3');
    var sound9 = new Audio('snd/imagefilm-049-by-sascha-ende-from-filmmusic-io.mp3');
    var sound10 = new Audio('snd/loop-menu-preview-109594.mp3');
   var sound11 = new Audio('snd/snd/music 1 science-documentary-169621.mp3');
   var sound12 = new Audio('snd/music 2 solitude-dark-ambient-electronic-197737.mp3');
   var sound13 = new Audio('snd/music 3 bensound-moonlightdrive.mp3');
   
//playany(['snd/music 3 bensound-moonlightdrive.mp3', 'snd/music 2 solitude-dark-ambient-electronic-197737.mp3', 'snd/music 1 science-documentary-169621.mp3', 'snd/loop-menu-preview-109594.mp3', 'snd/imagefilm-049-by-sascha-ende-from-filmmusic-io.mp3', 'snd/i-am-dreaming-or-final-fantasy-menu-kinda-thing-29173.mp3'], 0.1);




// Hangerő beállítása mindkét hangfájl esetén 50%-ra
sound8.volume = 0.2;
sound9.volume = 0.2;
sound10.volume = 0.2;
sound11.volume = 0.2;
sound12.volume = 0.2;
sound13.volume = 0.2;

function playRandomSound8() {
	var sounds = [sound8, sound9, sound10, sound11, sound12, sound13];
    var randomIndex = Math.floor(Math.random() * sounds.length);
    currentSound = sounds[randomIndex]; // Az aktuálisan játszott hang mentése
    currentSound.play();
    
    currentSound.onended = function() {
    	
    /*
    
    	      // Esemény utáni teendők
        // Itt adhatja meg azokat a műveleteket, amelyeket a hang lejátszásának befejezése után szeretne végrehajtani
    this.currentTime = 0; // Visszaállítja a hangot az elejére
    var pauseDuration = Math.random() * (3000 - 1000) + 1000; // 1 és 3 másodperc közötti véletlenszerű szünet
    setTimeout(() => {
        this.play(); // Újraindítja a hang lejátszását a szünet után
    }, pauseDuration);
    
    */
    
};

}




    
    var sound11 = new Audio('snd/notification-for-game-scenes-132473.mp3');
    var sound12 = new Audio('snd/mixkit-tech-click-1140.wav');
    
// Hangerő beállítása mindkét hangfájl esetén 50%-ra
sound11.volume = 1;
sound12.volume = 1;


    function playRandomSound11() {
	var sounds = [sound11, sound12];
    var randomIndex = Math.floor(Math.random() * sounds.length);
    sounds[randomIndex].play();
    sounds[randomIndex].onended = function() {
        // Esemény utáni teendők
    };
}

var sound13 = new Audio('snd/melancholy-ui-chime-47804.mp3');
    var sound14 = new Audio('snd/beepd-86247.mp3');
    var sound15 = new Audio('snd/beepd-86247.mp3');
    
// Hangerő beállítása mindkét hangfájl esetén 50%-ra
sound13.volume = 1;
sound14.volume = 1;
sound15.volume = 1;


    function playRandomSound13() {
	var sounds = [sound13, sound14, sound15];
    var randomIndex = Math.floor(Math.random() * sounds.length);
    sounds[randomIndex].play();
    sounds[randomIndex].onended = function() {
        // Esemény utáni teendők
    };
}


var sound16 = new Audio('snd/wet-click-low-atmospheric.wav');
    var sound17 = new Audio('snd/Zapsplat High tech beep 2.mp3');
    var sound18 = new Audio('snd/Zapsplat High tech beep with reverb 4.mp3');
    
// Hangerő beállítása mindkét hangfájl esetén 50%-ra
sound16.volume = 1;
sound17.volume = 1;
sound18.volume = 1;


    function playRandomSound16() {
	var sounds = [sound16, sound17, sound18];
    var randomIndex = Math.floor(Math.random() * sounds.length);
    sounds[randomIndex].play();
    sounds[randomIndex].onended = function() {
        // Esemény utáni teendők
    };
}

   var sound19 = new Audio('snd/system-error-notice-132470.mp3');
    var sound20 = new Audio('snd/system-error-notice-132470.mp3');
    
// Hangerő beállítása mindkét hangfájl esetén 50%-ra
sound19.volume = 1;
sound20.volume = 1;


    function playRandomSound20() {
	var sounds = [sound19, sound20];
    var randomIndex = Math.floor(Math.random() * sounds.length);
    sounds[randomIndex].play();
    sounds[randomIndex].onended = function() {
        // Esemény utáni teendők
    };
}



    
    
    function slowextraText() {
  var textToRead = document.getElementById('selectedtextblock').innerText; // A kiválasztott szöveg lekérése
  if (winner === "hu") {
    var textToRead = document.getElementById('translated').innerText; // A kiválasztott szöveg lekérése
  }

  var lang = 'en-ENG';
  if (winner === "hu") {
    var lang = 'en-ENG';
  }

  var audio = new SpeechSynthesisUtterance(textToRead);
  audio.lang = lang;
  audio.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
  audio.pitch = 1.0;

// a randomRate 0.1 és 0.5 közötti érték legyen 
 var randomRate = 0.0 + Math.random() * 0.2;
// console.log(randomRate);
  //var randomRate = 0.0;
  // var randomRate = 0.2 + Math.random() * 0.8;
  audio.rate = randomRate;

  speechSynthesis.speak(audio);
}






const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function middleslowextraText() {
  await sleep(2000); // Várakozás 2 másodpercet a függvény elején

  var textToRead = document.getElementById('selectedtextblock').innerText; 
  if (winner === "hu") {
    textToRead = document.getElementById('translated').innerText;
  }

  var lang = 'en-ENG';
  if (winner === "hu") {
    lang = 'en-ENG';
  }

  var audio = new SpeechSynthesisUtterance(textToRead);
  audio.lang = lang;
  audio.volume = 1;
  audio.pitch = 1.0;

  var randomRate = 0.4 + Math.random() * 0.3;
  audio.rate = randomRate;

  speechSynthesis.speak(audio);
}




function readanytext() {
		// FIGYELEM! BUTTON NÉLKÜL NEM MEGY
	//	readany = ("yeah."); // lehet funkción kívül, de a funkció nevekre figyelni és buttonkell
        //    readanyhun = ('Bitcoin price is greater than 71,500!');
            var textToRead = readany;

            var lang = 'en-ENG';
       /* ez csak ott működik ahol ez globálisan van már     
  if (winner === "hu") {
    lang = 'hu-HUN';
  }
  */
            var audio = new SpeechSynthesisUtterance(textToRead);
            audio.lang = lang;
            audio.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
            audio.pitch = 1.0;
// A randomRate értékének beállítása 0.6 és 0.9 között
  var randomRate = 0.6 + Math.random() * 0.3;
  audio.rate = randomRate;
  
speechSynthesis.speak(audio);
      
	}
	

function readanytexthun() {
    // FIGYELEM! BUTTON NÉLKÜL NEM MEGY
    // Feltételezzük, hogy a "readany" változó tartalmazza a felolvasandó szöveget
    var textToRead = readany || "Nincs mit felolvasni.";

    var lang = 'hu-HU'; // Magyar nyelv

    var audio = new SpeechSynthesisUtterance(textToRead);
    audio.lang = lang;
    audio.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
    audio.pitch = 1.0;

    // Az olvasási sebesség beállítása a globális olvassebesseg változó alapján
    // Ha nincs definiálva, akkor 1.0 az alapértelmezett
    audio.rate = typeof olvassebesseg === "number" ? olvassebesseg : 1.0;

    speechSynthesis.speak(audio);
}


	
// kussoltat
const synth = window.speechSynthesis;

function stopSpeaking() {
  if (synth.speaking) {
    synth.cancel();
  }
}

// Használata:
//stopSpeaking();  
// Ez azonnal leállítja a beszédet


// szavanként olvas
// megváltoztatva, csak a szavat olvassa 2024/05/27 14:19
    
let wordsList = [];
let currentWordIndex = 0;
let previousWordToRead = '';

let textToRead2;
let word;

function wordread() {
	
textToRead2 = olvasni
//alert(word);  ezt a változót kell fordítani a Google API-val, majd beleírni a fordítást a translate 
var lang2 = 'en-ENG';
if (winner === "hu") {
var lang2 = 'en-ENG';
}
var audio2 = new SpeechSynthesisUtterance(textToRead2);
audio2.lang = lang2;
audio2.rate = 0.8;
audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
audio2.pitch = 1.0;
speechSynthesis.speak(audio2);
}




function speakWord(word) {
	
      var textToRead = word
      var lang = 'en-ENG';
      if (winner === "hu") {
        var lang = 'en-ENG';
        }
        
      //var lang = 'en-ENG';
      //var lang = 'hu-HUN';
      
      var audio = new SpeechSynthesisUtterance(textToRead);
      audio.lang = lang;
      audio.rate = 0.8;
      audio.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
      audio.pitch = 1.0;

      speechSynthesis.speak(audio);

  //const synth = window.speechSynthesis;
  //const utterance = new SpeechSynthesisUtterance(word);
  //synth.speak(utterance);
}
    
    
    
    
    
    
    
    
    // Egyedi szavanként lebetűző szkript
    
    
    
let listOfWords = [];
let indexCurrentWord = 0;
let wordPreviouslyRead = '';

function initiateSpelling() {
  let textToSpell = document.getElementById('selectedtextblock').innerText;

  if (winner === "hu") {
    textToSpell = document.getElementById('translated').innerText;
  }

  if (textToSpell !== wordPreviouslyRead) {
    listOfWords = textToSpell.split(' ');
    console.log(listOfWords);
    indexCurrentWord = 0;
  }

  if (listOfWords.length > 0) {
    spellOutWord(listOfWords[indexCurrentWord]);
    indexCurrentWord = (indexCurrentWord + 1) % listOfWords.length;
  }

  wordPreviouslyRead = textToSpell;
}

// Globális változó a setTimeout azonosítójának tárolására
var spellingTimeoutId;

// Tömb az aktív setTimeout azonosítók tárolására
var activeTimeouts = [];

function spellOutWord(word) {
  // Megszakítjuk az előző betűzéseket
  stopSpelling();

  // Először olvassa fel a szót egyben
  let utteranceWholeWord = new SpeechSynthesisUtterance(word);
  setUtteranceProperties(utteranceWholeWord, 0.6); // Gyorsabb felolvasás a teljes szóhoz
  speechSynthesis.speak(utteranceWholeWord);

  // Késleltetés a betűzés előtt
  var wordTimeoutId = setTimeout(() => {
    // Betűk felolvasása egyesével
    for (let i = 0; i < word.length; i++) {
      (function(index) {
        var letterTimeoutId = setTimeout(function() {
          let letter = word.charAt(index);
          let utteranceLetter = new SpeechSynthesisUtterance(letter);
          setUtteranceProperties(utteranceLetter, 1); // Normál sebesség a betűkhöz
          speechSynthesis.speak(utteranceLetter);
          // Frissítjük a dinamikus paragrafust az aktuális betűvel
          document.getElementById('current-letter').textContent = letter;
        }, i * 750); // 750 milliszekundumos késleltetés minden betű között
        // Hozzáadjuk az azonosítót az aktív időzítők tömbjéhez
        activeTimeouts.push(letterTimeoutId);
      })(i);
    }
  }, 1000); // 1 másodperces késleltetés a teljes szó felolvasása után
  // Hozzáadjuk az azonosítót az aktív időzítők tömbjéhez
  activeTimeouts.push(wordTimeoutId);

  // Késleltetés a teljes szó kiírása előtt
  var finalWordTimeoutId = setTimeout(function() {
    // Kiírjuk a teljes szót a dinamikus paragrafusba
    document.getElementById('current-letter').textContent = word;
  }, (word.length * 750) + 1000); // A betűzés ideje + 1 másodperc
  activeTimeouts.push(finalWordTimeoutId);
}

// Frissített funkció az összes aktív setTimeout leállítására
function stopSpelling() {
  // Megszakítjuk az összes aktív setTimeout-ot
  activeTimeouts.forEach(function(timeoutId) {
    clearTimeout(timeoutId);
  });
  // Ürítjük az aktív időzítők tömbjét
  activeTimeouts = [];
  
  // Megállítjuk a szövegfelolvasást
  speechSynthesis.cancel();
  
  // Töröljük a dinamikus paragrafus tartalmát
  document.getElementById('current-letter').textContent = '';
}

function setUtteranceProperties(utterance, rate) {
  let selectedLang = 'en-ENG';
  if (winner === "hu") {
    selectedLang = 'en-ENG';
  }
  utterance.lang = selectedLang;
  utterance.rate = rate; // A felolvasás sebességének beállítása
  utterance.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
  utterance.pitch = 1.0;
}



      // szavanként lebetűz vége
    
    
    
    
    
    
    
    
    
    // szavankén fordít is meg felolvas is
    

	
let szoforditas;
let olvasni;
let wordsList2 = [];
let currentWordIndex2 = 0;
let previousWordToRead2 = '';
//let winner = "hu"; // Például, ezt állítsd a tényleges nyelvválasztás szerint



function wordread2() {
    stopMonitoring();
    let wordToRead2 = document.getElementById('selectedtextblock').innerText;
    if (winner === "hu") {
        wordToRead2 = document.getElementById('translated').innerText;
    }

    if (wordToRead2 !== previousWordToRead2) {
        wordsList2 = wordToRead2.split(' ');
        console.log("Szavak listája:", wordsList2);
        currentWordIndex2 = 0;
    }

    if (wordsList2.length > 0) {
        speakAndTranslateWord(wordsList2[currentWordIndex2]);
        currentWordIndex2 = (currentWordIndex2 + 1) % wordsList2.length;
    }

    previousWordToRead2 = wordToRead2;
}

function speakAndTranslateWord(word) {
    olvasni = word;

    // A kívánt szöveg, amit a szó elé szeretnél írni
    const prefixText = "fordítsd magyarra és értelmezd és mondj szinonim szavakat és mondj ezzel példamondatokat és képötleteket. És csinálj ilyen témájú képet.";

    // A teljes szöveg, amit a vágólapra másolunk
    const textToCopy = prefixText + word;

    // Másolás vágólapra biztonságos módon
    if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(textToCopy)
            .then(() => {
                console.log("Szöveg másolva a vágólapra:", textToCopy);
            })
            .catch(err => {
                console.error("Nem sikerült a vágólapra másolás:", err);
            });
    } else {
        const textArea = document.createElement("textarea");
        textArea.value = textToCopy;
        textArea.style.position = "fixed";
        textArea.style.left = "-999999px";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        try {
            document.execCommand('copy');
            console.log("Szöveg másolva a vágólapra (fallback):", textToCopy);
        } catch (err) {
            console.error("Nem sikerült a vágólapra másolás (fallback):", err);
        }
        document.body.removeChild(textArea);
    }

    // Felolvasás angolul (vagy forrás nyelven)
    let lang2 = 'en-ENG';
    if (winner === "hu") {
        lang2 = 'en-ENG';
    }

    let utterance = new SpeechSynthesisUtterance(word);
    utterance.lang = lang2;
    utterance.rate = 0.8;
    utterance.volume = 1;
    utterance.pitch = 1.0;
    speechSynthesis.speak(utterance);

    // Fordítás lekérése
    const inputText = word;
    let inputLanguage = "en";
    let outputLanguage = "hu";

    if (winner === "hu") {
        inputLanguage = "en";
        outputLanguage = "hu";
    }

    const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=${inputLanguage}&tl=${outputLanguage}&dt=t&q=${encodeURIComponent(inputText)}`;

    fetch(url)
        .then(response => response.json())
        .then(json => {
            szoforditas = json[0].map(item => item[0]).join("");
            console.log("Fordítás:", szoforditas);

            // Felolvasás magyarul
            let lang2 = 'hu-HUN';
            if (winner === "hu") {
                lang2 = 'hu-HUN';
            }
            let audio2 = new SpeechSynthesisUtterance(szoforditas);
            audio2.lang = lang2;
            audio2.rate = 0.8;
            audio2.volume = 1;
            audio2.pitch = 1.0;
            speechSynthesis.speak(audio2);
        })
        .catch(error => {
            console.error("Fordítási hiba:", error);
        });
}






        // a háromszavas fordítása nagy az igény

let fordítottSzöveg;
let szavakListája = [];
let aktuálisSzóIndex = 0;
let előzőSzó = '';
let utolsóFelolvasottSzócsoport = '';

function háromszóOlvasás() {
  let olvasandóSzó = document.getElementById('selectedtextblock').innerText;
  if (winner === "hu") {
    olvasandóSzó = document.getElementById('translated').innerText;
  }

  if (olvasandóSzó !== előzőSzó) {
    szavakListája = olvasandóSzó.split(' ');
    aktuálisSzóIndex = 0;
  }

  let szócsoport = szavakListája.slice(aktuálisSzóIndex, aktuálisSzóIndex + 3).join(' ');
  
  
  stopMonitoring();
// A kívánt szöveg, amit a szó elé szeretnél írni
const prefixText = "fordítsd magyarra és értelmezd és mondj szinonim szavakat és mondj ezzel példamondatokat és képötleteket. És csinálj ilyen témájú képet.";

// A teljes szöveg, amit a vágólapra másolunk
const textToCopy = prefixText + szócsoport;

// Másolás vágólapra biztonságos módon
if (navigator.clipboard && window.isSecureContext) {
    navigator.clipboard.writeText(textToCopy)
        .then(() => {
            //console.log("Szöveg másolva a vágólapra:", textToCopy);
        })
        .catch(err => {
            console.error("Nem sikerült a vágólapra másolás:", err);
        });
} // <-- ez a zárójel hiányzott

  
  if (szócsoport.length > 0) {
    szóKimondás(szócsoport);
    utolsóFelolvasottSzócsoport = szócsoport; // Frissíti az utolsó felolvasott szócsoportot
    aktuálisSzóIndex = (aktuálisSzóIndex + 1) % szavakListája.length;
  }
  előzőSzó = olvasandóSzó;
}

function szóKimondás(szócsoport, fordítés = true) {
  var nyelvKód = 'en-ENG';
  if (winner === "hu") {
    nyelvKód = 'en-ENG';
  }
  let hang = new SpeechSynthesisUtterance(szócsoport);
  hang.lang = nyelvKód;
  hang.rate = 0.8;
  hang.volume = 1;
  hang.pitch = 1.0;
  speechSynthesis.speak(hang);

  if (fordítés) {
    const bemenetiSzöveg = szócsoport;
    let bemenetiNyelv = "en";
    let kimenetiNyelv = "hu";

    if (winner === "hu") {
      bemenetiNyelv = "en";
      kimenetiNyelv = "hu";
    }

    const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=${bemenetiNyelv}&tl=${kimenetiNyelv}&dt=t&q=${encodeURI(bemenetiSzöveg)}`;

    fetch(url)
      .then(válasz => válasz.json())
      .then(json => {
        fordítottSzöveg = json[0][0][0];
        
        var nyelvKód = 'hu-HUN';
        if (winner === "hu") {
          var nyelvKód = 'hu-HUN';
        }
        
        let hangFordított = new SpeechSynthesisUtterance(fordítottSzöveg);
        hangFordított.lang = nyelvKód;
        hangFordított.rate = 0.8;
        hangFordított.volume = 1;
        hangFordított.pitch = 1.0;
        speechSynthesis.speak(hangFordított);
      })
      .catch(hiba => {
        console.error(hiba);
      });
  }
}

function haromszorepeat() {
  if (utolsóFelolvasottSzócsoport.length > 0) {
    szóKimondás(utolsóFelolvasottSzócsoport, false); // Nem fordítja le a szavakat
  }
}











    
    
    
    
    
    
    
    
    
    
    
    
    
function one() {
	 
bookmarksave();
	
    if (currentsentencenumber > 1) {
        currentsentencenumber--; // Csökkentjük a jelenlegi mondat sorszámát eggyel
        displaysentence = getSelectedSentence(currentsentencenumber); // Az új kiválasztott mondat lekérése

        if (displaysentence) {
            document.getElementById('selectedtextblock').innerText = displaysentence; // Az új kiválasztott mondat megjelenítése
        }

        updateContextBlock(); // Frissítjük a kontextus blokkot az új kiválasztott mondat körül
        document.getElementById('counter').textContent = currentsentencenumber; // Frissítjük a számlálót az új mondat sorszámával
        setSliderToCurrentSentence();
        readText();
        
        if (currentsentencenumber === 1) {
            playRandomSound();
        }
    }
   else if (currentsentencenumber === 1) { 
    	playRandomSound();
    }
    
    bookpercent2();
}


function getSelectedSentence(sentenceNumber) {
    if (origcontent) {
        //let cleanedText = origcontent;
        let sentences = origcontent.match(/[^.!?]+(?:\.|!|\?)(?=\s|$)/g); // Tisztított szöveg mondatokra bontása

        if (sentences && sentences.length >= sentenceNumber) {
            return sentences[sentenceNumber - 1]; // Kiválasztott mondat visszaadása
        }
    }
    return null;
}

function updateContextBlock() {
    if (origcontent) {
        let sentences = origcontent.match(/[^.!?]+(?:\.|!|\?)(?=\s|$)/g); // Összes mondat kinyerése

        if (sentences && sentences.length > 0) {
            let startIndex = Math.max(0, currentsentencenumber - 3); // Az előtte levő két mondat indexe
            let endIndex = Math.min(sentences.length, currentsentencenumber + 2); // Az utána levő két mondat indexe

            let contextText = sentences.slice(startIndex, endIndex).join(' '); // Összes releváns mondat összefűzése

            document.getElementById('contextblock').innerText = contextText; // Context block frissítése
        }
    }
}

        function two() {
    const translateBtn = document.getElementById('translateBtn');
    
    // Szimuláljuk a gombra kattintást
    translateBtn.click();
    //readTranslatedText();
    
    // Sleep függvény, ami 2 másodpercet vár
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// Aszinkron függvény, ami használja a sleep-et
async function delayedReadTranslatedText() {
  await sleep(500);    // 0.5 másodperc várakozás
  readTranslatedText(); // Ezután fut le
}

delayedReadTranslatedText();

    
}


const translateBtn = document.getElementById('translateBtn');

translateBtn.addEventListener("click", (e) => {
	
	// innen a google fordító
	
	// a bemenet, ami lehet var is  a const inputText = 
    const inputText = document.getElementById('selectedtextblock').innerText;
    let inputLanguage = "en"; // Alapértelmezett érték
    let outputLanguage = "hu"; // Alapértelmezett érték

    if (winner === "hu") {
        inputLanguage = "hu"; // Ha a nyertes nyelv "hu", akkor az input nyelv legyen "hu"
        outputLanguage = "en";
    }

    const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=${inputLanguage}&tl=${outputLanguage}&dt=t&q=${encodeURI(inputText)}`;
  // a translated sor a kimeneti rész
    fetch(url)
        .then((response) => response.json())
        .then((json) => {
            document.getElementById('translated').innerText = json[0].map((item) => item[0]).join("");
        })
        .catch((error) => {
            console.error(error);
        });
        
        
        // idági tart a google fordító
        
});







// hangfelismerő fordítás érintés touch

// touch bal közép hangfordításnak

document.addEventListener('click', function(event) {
    if (event.isTrusted) {
        // A böngésző ablakának szélessége és magassága
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;

        // Az érintési terület függőleges határai (képernyő közép ±100 px)
        const yTop = (windowHeight / 2) - 100;
        const yBottom = (windowHeight / 2) + 100;
        
        if (
            event.clientX >= 0 && event.clientX < 90 &&       // bal oldali 0-90px sáv
            event.clientY >= yTop && event.clientY < yBottom   // középső 200px magas sáv
        ) {
            // kattintás a baloldali 0-100 px és középen lévő 200 px magas területen

            stopSpeaking(); 
            stopMusic();
            stopPlayany();
            muteRadio();

            if (optionsopen === 0) {
                // firstdomload változó beállítása
                firstdomload = 3;
                
                if (optionsopen === 1) {
                    // semmi
                } else {
                    
                    inditHangfelismeresForditas(inputLang = 'en', outputLang = 'hu');
                    
                }
            }

            if (optionsopen === 1) {
                // most nem csinál semmit
            }

            //enterFullscreen();

            // Az érintett terület vizuális kiemelése
            const highlightArea = document.createElement('div');
            highlightArea.style.position = 'absolute';
            highlightArea.style.left = '0px';                       // bal oldali érintési terület
            highlightArea.style.top = yTop + 'px';                  // érintési terület teteje
            highlightArea.style.width = '90px';                     // szélesség: 100px
            highlightArea.style.height = (yBottom - yTop) + 'px';   // magasság: 200px
            highlightArea.style.backgroundImage = 'url("./picture/1753348644070.jpg")';
            highlightArea.style.backgroundSize = 'cover';           // teljes lefedés torzítás nélkül
            highlightArea.style.backgroundRepeat = 'no-repeat';
            highlightArea.style.backgroundPosition = 'center';
            highlightArea.style.borderRadius = '10px';
            highlightArea.style.opacity = '0.3';
            highlightArea.style.zIndex = '9999';
            highlightArea.style.animation = 'fadeOut 1s ease-in-out';

            document.body.appendChild(highlightArea);

            // 1,333 mp után eltávolítjuk a kiemelést
            setTimeout(() => document.body.removeChild(highlightArea), 1333);
        }
    }
});



// Hangfelismerő fordítás fordító translator hhhhh

//let translatedText;

function inditHangfelismeresForditas(inputLang = 'en', outputLang = 'hu') {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SpeechRecognition) {
    alert('A böngésződ nem támogatja a Web Speech API-t.');
    return;
  }

  const recognition = new SpeechRecognition();
  recognition.lang = inputLang === 'hu' ? 'hu-HU' : 'en-US'; // Egyszerű váltás
  recognition.interimResults = false;
  recognition.maxAlternatives = 1;

  recognition.onresult = (event) => {
    if (!event.results || event.results.length === 0) {
      alert('Nem sikerült felismerni semmit. Lehet, hogy a beszéd nyelve eltér a beállítottól.');
      return;
    }

    const transcript = event.results[0][0].transcript.trim();
    if (!transcript) {
      alert('Nem hallottunk semmit. Lehet, hogy magyarul beszéltél, miközben angol nyelvre volt állítva a felismerés.');
      return;
    }

    const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=${inputLang}&tl=${outputLang}&dt=t&q=${encodeURIComponent(transcript)}`;

fetch(url)
  .then(response => response.json())
  .then(json => {
    translatedText = json[0].map(item => item[0]).join('');
    
    // Felolvasás magyarul
    const utterance = new SpeechSynthesisUtterance(translatedText);
    utterance.lang = 'hu-HU';  // itt állítjuk a magyar nyelvet
    speechSynthesis.speak(utterance);

    // (opcionális) értesítés a felhasználónak
    // alert(`Felismert szöveg: "${transcript}"\nFordítás: "${translatedText}"`);
  })

      .catch(err => {
        console.error(err);
        alert('Hiba történt a fordítás során.');
      });
  };

  recognition.onerror = (event) => {
    alert('Hiba a beszédfelismerés során: ' + event.error + '. Valószínűleg nem az elvárt nyelven beszéltél.');
  };

  recognition.onend = () => {
    // Beszédfelismerés vége értesítés és hanghatás
    showBubble("Beszédfelismerés vége.", "rgba(33,150,243,0.9)", [100, 50]);
   // playany(['snd/button/Page 18 Search Smooth Soundsnap.mp3'], 1);
    // Ne indítsunk felolvasást itt, mert a fordítás nem feltétlen kész még
  };

  showBubble(`Kérlek, beszélj ${inputLang === 'hu' ? 'magyarul' : 'angolul'}!`, "rgb(151,51,151)");

  recognition.start();
}

// Csak akkor csatoljuk az eseményt, ha a gomb létezik
const gomb = document.getElementById('startRecognition');
if (gomb) {
  gomb.addEventListener('click', () => {
    inditHangfelismeresForditas('en', 'hu');
  });
}





function twotoinfiniteread() {
    //const translateBtn = document.getElementById('translateBtn');
    
    // Szimuláljuk a gombra kattintást
    translateBtn.click();
    //readTranslatedText();
}


//const translateBtn = document.getElementById('translateBtn');

translateBtn.addEventListener("click", (e) => {
	
	// innen a google fordító
	
	// a bemenet, ami lehet var is  a const inputText = 
    const inputText = document.getElementById('selectedtextblock').innerText;
    let inputLanguage = "en"; // Alapértelmezett érték
    let outputLanguage = "hu"; // Alapértelmezett érték

    if (winner === "hu") {
        inputLanguage = "hu"; // Ha a nyertes nyelv "hu", akkor az input nyelv legyen "hu"
        outputLanguage = "en";
    }

    const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=${inputLanguage}&tl=${outputLanguage}&dt=t&q=${encodeURI(inputText)}`;
  // a translated sor a kimeneti rész
    fetch(url)
        .then((response) => response.json())
        .then((json) => {
            document.getElementById('translated').innerText = json[0].map((item) => item[0]).join("");
        })
        .catch((error) => {
            console.error(error);
        });
        
        
        // idági tart a google fordító
        
});






        function three() {
        	
        bookmarksave();
        
        if (currentsentencenumber === allsentencenumber) { 
    	playRandomSound();}//ide jöhet system AI szöveg
   
    	 if (currentsentencenumber === (allsentencenumber-1)) { 
    	playRandomSound();}
    if (currentsentencenumber < allsentencenumber) {
        currentsentencenumber++; // Növeljük a jelenlegi mondat sorszámát eggyel
        displaysentence = getSelectedSentence(currentsentencenumber); // Az új kiválasztott mondat lekérése

        if (displaysentence) {
            document.getElementById('selectedtextblock').innerText = displaysentence; // Az új kiválasztott mondat megjelenítése
        }

        updateContextBlock(); // Frissítjük a kontextus blokkot az új kiválasztott mondat körül
        document.getElementById('counter').textContent = currentsentencenumber; // Frissítjük a számlálót az új mondat sorszámával
        setSliderToCurrentSentence(); // Frissítjük a slidert is
        
        
        
       var currsen = document.getElementById('selectedtextblock').innerText;

    if (currsen.includes('?')) {
    
readany = ("Kérdő mondat. ");	
    readanytexthun();
        
}
if (currsen.includes('!')) {
    
      readany = ("Felkiáltó mondat. ");	
    readanytexthun();

        
}
 else {
    // más esetek kezelése
}
        
        readText();
    }
    bookpercent2();
}

let clickCounter = 0;

document.getElementById('selectedtextblock').addEventListener('click', function() {
  stopMonitoring();

  var currentreadText = document.getElementById('selectedtextblock').textContent;

  if (clickCounter === 0) {
    gamePlaySound(['snd/button/Solar Sound Effects Download SFX Library Soundsnap.mp3'], 1);
    navigator.clipboard.writeText('"' + currentreadText + '" direct translate magyarra és utána értelmezd, majd írj hasonló értelmű szöveget más szavakkal.').then(function() {
      console.log('A szöveg sikeresen másolva lett a vágólapra: "' + currentreadText + '" direct translate magyarra és utána értelmezd, majd írj hasonló értelmű szöveget más szavakkal.');
      startTypingAnimation('paragraphId', 'divId', 'értelmezd');
    }, function(err) {
      console.error('Hiba történt a vágólapra másolás közben: ', err);
    });
    
    } 




else if (clickCounter === 1) {
  
  gamePlaySound([
    'snd/picture ttsmaker geniusgirl.mp3',
    'snd/picture ttsmaker3 stefan.mp3',
    'snd/picture ttsmaker.mp3',
    'snd/picture ttsmaker1.mp3',
    'snd/make a picture Chole lovo.wav',
    'snd/make a picture Ryan.wav'
  ], 1);

  showRandomImage2025(
    2500,
    100,
    "./picture/orig size pic/unnamed (1).jpg", "20px",
    "./picture/orig size pic/unnamed (2).jpg", "20px",
    "./picture/orig size pic/unnamed (3).jpg", "20px",
    "./picture/orig size pic/unnamed (4).jpg", "20px",
    "./picture/orig size pic/unnamed (5).jpg", "20px"
  );

  let baseText = 'Készíts ilyen témájú képet magas minőségben, 3D-s digitális illusztráció. Ezt a stílust a térbeli megjelenítés, a lekerekített formák és a fény-árnyék hatások jellemzik, ami egyedi és látványos eredményt ad. ';
  let textToCopy2 = baseText + '"' + currentreadText + '"';

  // Eredeti szöveg másolása a vágólapra
  navigator.clipboard.writeText(textToCopy2).then(function() {
    console.log('A szöveg sikeresen másolva lett a vágólapra: ' + textToCopy2);

    // Eredeti buborék létrehozása
    const bubbleOriginal = document.createElement("div");
    bubbleOriginal.textContent = textToCopy2;
    bubbleOriginal.style.position = "fixed";
    bubbleOriginal.style.top = "350px";
    bubbleOriginal.style.left = "100px";
    bubbleOriginal.style.backgroundColor = "rgba(25, 125, 112, 0.35)"; // éjkék
    bubbleOriginal.style.color = "white";
    bubbleOriginal.style.fontSize = "18px";
    bubbleOriginal.style.fontWeight = "bold";
    bubbleOriginal.style.padding = "12px 16px";
    bubbleOriginal.style.borderRadius = "8px";
    bubbleOriginal.style.cursor = "pointer";
    bubbleOriginal.style.zIndex = 10200;
    document.body.appendChild(bubbleOriginal);

    // Eredeti buborék eltűnése 6 mp múlva
    setTimeout(() => {
      if (bubbleOriginal.parentNode) {
        bubbleOriginal.parentNode.removeChild(bubbleOriginal);
      }
    }, 6000);

    // Eredeti buborék kattintás eseménykezelője
    bubbleOriginal.addEventListener("click", () => {
      navigator.clipboard.writeText(textToCopy2).then(() => {
        console.log("Eredeti szöveg másolva a vágólapra:", textToCopy2);
        window.open("https://www.decohere.ai/quality-image", "_blank");
        setTimeout(() => {
          window.open("https://gemini.google.com/app", "_blank");
        }, 333);
        playOscillatorSound(440, 300);
      }).catch(err => {
        console.error("Nem sikerült a másolás:", err);
      });

      if (bubbleOriginal.parentNode) {
        bubbleOriginal.parentNode.removeChild(bubbleOriginal);
      }
    });

    // Fordítás és fordított buborék létrehozása
    universalTranslate(textToCopy2, translatedText => {
      const bubbleTranslated = document.createElement("div");
      bubbleTranslated.textContent = translatedText;
      bubbleTranslated.style.position = "fixed";
      bubbleTranslated.style.top = "450px";
      bubbleTranslated.style.left = "400px";
      bubbleTranslated.style.backgroundColor = "rgba(128, 18, 90, 0.35)"; // olívazöld
      bubbleTranslated.style.color = "white";
      bubbleTranslated.style.fontSize = "18px";
      bubbleTranslated.style.fontWeight = "bold";
      bubbleTranslated.style.padding = "12px 16px";
      bubbleTranslated.style.borderRadius = "8px";
      bubbleTranslated.style.cursor = "pointer";
      bubbleTranslated.style.zIndex = 10200;
      document.body.appendChild(bubbleTranslated);

      // Fordított buborék eltűnése 6 mp múlva
      setTimeout(() => {
        if (bubbleTranslated.parentNode) {
          bubbleTranslated.parentNode.removeChild(bubbleTranslated);
        }
      }, 6000);

      // Kattintásra másolás, linkek megnyitása, hangjelzés
      bubbleTranslated.addEventListener("click", () => {
        navigator.clipboard.writeText(translatedText).then(() => {
          console.log("Fordított szöveg másolva a vágólapra:", translatedText);
          window.open("https://www.decohere.ai/quality-image", "_blank");
          setTimeout(() => {
            window.open("https://gemini.google.com/app", "_blank");
          }, 333);
          playOscillatorSound(440, 300);
        }).catch(err => {
          console.error("Nem sikerült a másolás:", err);
        });
      });
    });

  }, function(err) {
    console.error('Hiba történt a vágólapra másolás közben: ', err);
  });

  // Fordító függvény
  function universalTranslate(text, callback) {
    const hungarianChars = /[áéíóöőúüű]/i;
    const inputLanguage = hungarianChars.test(text.toLowerCase()) ? "hu" : "en";
    const outputLanguage = inputLanguage === "hu" ? "en" : "hu";
    const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=${inputLanguage}&tl=${outputLanguage}&dt=t&q=${encodeURIComponent(text)}`;

    fetch(url)
      .then(response => response.json())
      .then(json => {
        translatedText = json[0].map(item => item[0]).join("");
        callback(translatedText);
      })
      .catch(error => {
        console.error("Fordítási hiba:", error);
        callback(text);
      });
  }
}






else if (clickCounter === 2) {
    //playany(['snd/button/Free Switch Sound Effect Download SFX MP3 Library Soundsnap.mp3', 'snd/button/Page 2 Switch Soundsnap.mp3'], 1);
    
    playany(['snd/Page 3 J Sound Effects Download SFX Library Soundsnap.mp3'], 1);
    
    let textToCopy = 'fordítsd magyarra és értelmezd és mondj szinonim szavakat és mondj ezzel példamondatokat és képötleteket.  ' + currentreadText;  // ide írtam a "kép " előtagot
    navigator.clipboard.writeText(textToCopy).then(function() {
      console.log('A szöveg sikeresen másolva lett a vágólapra: ' + textToCopy);
      //startTypingAnimation('paragraphId', 'divId', textToCopy);
      
      
showBubble(
  textToCopy,
  "rgba(20,98,175,0.85)",
  [300, 100],
  { dx: 1, dy: 0, interval: 20, maxDistance: 20 },
  () => {
    window.open("https://gemini.google.com/app", "_blank");
    playOscillatorSound(440, 300);
    // Itt tetszőleges kódot futtathatsz
  }
);
      
    }, function(err) {
      console.error('Hiba történt a vágólapra másolás közben: ', err);
    });
  } else if (clickCounter === 3) {
  //  playany(['snd/button/Free Switch Sound Effect Download SFX MP3 Library Soundsnap.mp3', 'snd/button/Page 2 Switch Soundsnap.mp3'], 1);
  
  playany(['snd/Mobile app video game - fantasy magic - rounded menu select Soundsnap.mp3'], 1);
    navigator.clipboard.writeText(currentreadText).then(function() {
      console.log('Negyedik érintés: a szöveg sikeresen másolva lett a vágólapra: ' + currentreadText);
      startTypingAnimation('paragraphId', 'divId', currentreadText);
    }, function(err) {
      console.error('Hiba történt a vágólapra másolás közben: ', err);
    });
  }

  clickCounter = (clickCounter + 1) % 4; // 4 állapot között váltunk


  
  document.body.focus(); // Fókusz visszaállítása a dokumentumra
})

//készíts egy verziót a két ujjal érintésre, ahol legyen egy alert is.

// contextblock copy

document.getElementById('contextblock').addEventListener('click', function() {
  stopMonitoring();
  
  var currentreadText = document.getElementById('contextblock').textContent;
//  console.log(currentreadText);
  
  
  //
  currentreadText = "kép style prompt: digital art, high quality raytracing, hyper detailed, art by greg rutkowski. Téma: " + "\n" + currentreadText


//currentreadText = "mondj képötleteket. És csinálj ilyen témájú fantasy képet magas minőségben " + bookname + "\n" + new Date().toLocaleDateString() + "\n" + currentreadText;
  
  navigator.clipboard.writeText(currentreadText).then(function() {
    console.log('A context szöveg sikeresen másolva lett a vágólapra: ' + currentreadText);
  }, function(err) {
    console.error('Hiba történt a vágólapra másolás közben: ', err);
  });
  
  document.body.focus(); // Fókusz visszaállítása a dokumentumra
  
  startTypingAnimation('paragraphId', 'divId', 'A szöveg sikeresen másolva lett a vágólapra');
  
});








// 2 ujjas context copy



document.getElementById('contextblock').addEventListener('touchstart', function(event) {
  if (event.touches.length === 2) {
    stopMonitoring();

    if (origcontent) {
      let sentences = origcontent.match(/[^.!?]+(?:\.|!|\?)(?=\s|$)/g); // Összes mondat kinyerése

      if (sentences && sentences.length > 0) {
        let startIndex = Math.max(0, currentsentencenumber - 3); // Az előtte levő két mondat indexe
        let endIndex = Math.min(sentences.length, currentsentencenumber + 20); // Az utána levő két mondat indexe

        let contextText = sentences.slice(startIndex, endIndex).join(' '); // Összes releváns mondat összefűzése




        let currentreadText = bookname + "\nsentence " + currentsentencenumber + "\n" + new Date().toLocaleDateString() + "\n" + ('"' + contextText + "\n" + '" direct translate magyarra és utána értelmezd, majd írj hasonló értelmű szöveget más szavakkal. És mondj szinonim szavakat és mondj ezzel példamondatokat és képötleteket. És csinálj ilyen témájú fantasy képet.');

        navigator.clipboard.writeText(currentreadText).then(function() {
          console.log('A szöveg sikeresen másolva lett a vágólapra: ' + currentreadText);
          startTypingAnimation('paragraphId', 'divId', 'A nagy context szöveg és értelmezés másolva lett a vágólapra ');
        }, function(err) {
          console.error('Hiba történt a vágólapra másolás közben: ', err);
          alert('Hiba történt a vágólapra másolás közben!');
        });

        document.body.focus(); // Fókusz visszaállítása a dokumentumra
      }
    }
  }
});




/////// képet

function kepet() {
stopMonitoring();
  
  var currentreadText = document.getElementById('selectedtextblock').textContent;
//  console.log(currentreadText);
  
  
  //
  currentreadText = "kép style prompt: digital art, 4 k raytracing, hyper detailed, art by greg rutkowski. Téma: " + "\n" + currentreadText


//currentreadText = "mondj képötleteket. És csinálj ilyen témájú fantasy képet magas minőségben " + bookname + "\n" + new Date().toLocaleDateString() + "\n" + currentreadText;
  
  navigator.clipboard.writeText(currentreadText).then(function() {
    console.log('A context szöveg sikeresen másolva lett a vágólapra: ' + currentreadText);
  }, function(err) {
    console.error('Hiba történt a vágólapra másolás közben: ', err);
  });
  window.open("https://gemini.google.com/app", "_blank");
    playOscillatorSound(440, 300);
}


///////////////////
//swipe lapozás
// van style és dom is itt: contextSwipeArea


const contextSwipeArea = document.getElementById('contextSwipeArea');
let startY = 0;
let isSwipeValid = false;
let isSwipeDownValid = false;

contextSwipeArea.addEventListener('touchstart', (event) => {
  startY = event.touches[0].clientY;
});

contextSwipeArea.addEventListener('touchmove', (event) => {
  const currentY = event.touches[0].clientY;
  const deltaY = startY - currentY;

  // Felülről lefelé swipe detekció
  if (deltaY < -50 && currentY < window.innerHeight * 0.8) {
    isSwipeDownValid = true;
  } else {
    isSwipeDownValid = false;
  }

  // Lentről felfelé swipe detekció
  if (deltaY > 50 && currentY > window.innerHeight * 0.2) {
    isSwipeValid = true;
  } else {
    isSwipeValid = false;
  }
});

contextSwipeArea.addEventListener('touchend', () => {
  if (isSwipeValid) {
   // alert('Lentről felfelé swipe detektálva!');
    
    
    
    
    
          if (instanttranslate === 1) 
          {
                   // Első funkció meghívása
                       three();
                       stopSpeaking(); 
                // Fél másodperc várakozás
                    setTimeout(function() {
              // Második funkció meghívása
                       two();
}, 100);
four();
                   return;
                                                }
    
            stopSpeaking(); 
 
                       three();

    
    
  } else if (isSwipeDownValid) {
   // alert('Felülről lefelé swipe detektálva!');
   stopSpeaking(); 
   one();
  }
  isSwipeValid = false;
  isSwipeDownValid = false;
});




function threeinfinitenek() {
        	
        
        if (currentsentencenumber === allsentencenumber) { 
    	playRandomSound();}//ide jöhet system AI szöveg
   
    	 if (currentsentencenumber === (allsentencenumber-1)) { 
    	playRandomSound();}
    if (currentsentencenumber < allsentencenumber) {
        currentsentencenumber++; // Növeljük a jelenlegi mondat sorszámát eggyel
        displaysentence = getSelectedSentence(currentsentencenumber); // Az új kiválasztott mondat lekérése

        if (displaysentence) {
            document.getElementById('selectedtextblock').innerText = displaysentence; // Az új kiválasztott mondat megjelenítése
        }

        updateContextBlock(); // Frissítjük a kontextus blokkot az új kiválasztott mondat körül
        document.getElementById('counter').textContent = currentsentencenumber; // Frissítjük a számlálót az új mondat sorszámával
        setSliderToCurrentSentence(); // Frissítjük a slidert is
      //  readText();
    }
}

       
       
       
       
       
function four() {
	
	// csak első randfavoritkor bookname speak
	   if (firstdomload === 9999) {  //nem kell ez
	firstdomload = 0;
	
	      //bookname speak

        var textToRead = bookname;
         if (winner === "hu") {
      //var textToRead = document.getElementById('translated').innerText;
      // változtatva a magyart olvassa inkább
      var textToRead = bookname;
        }
      
      var lang = 'en-ENG';
      if (winner === "hu") {
        var lang = 'en-ENG';
         // változtatva ez is a magyarul
         var lang = 'hu-HUN';
        }
        
      //var lang = 'en-ENG';
      //var lang = 'hu-HUN'; // Alapértelmezett nyelv beállítása
      //var lang = 'de-DE';
      //var lang = 'es-ES';
      var audio = new SpeechSynthesisUtterance(textToRead);
      audio.lang = lang;
      audio.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
      audio.pitch = 1.0;
      
      var randomRate = 0.8 + Math.random() * 0.1;
audio.rate = randomRate;
  if (winner === "hu") {
        
         // változtatva még ez is magyarul nem kell annyira lassítani
         var randomRate = 0.7 + Math.random() * 0.25; //0.7 és 0.95 közötti intervallumra
        // console.log(randomRate);
    //  var randomRate = 1.3;
      audio.rate = randomRate;
        }

      speechSynthesis.speak(audio);
      
      //bookname speak end
	} 	// csak első randfavoritkor bookname speak
	
	readrepeatTextfor4button() // kicsit gyorsabb legyen
            //readrepeatText();
        }
        
        
function dpadup() {
}

function dpaddown() {
}

function dpadleft() {
	stopSpeaking();  
    // kiszámolni az ugrás mértékét
        // Számoljuk ki az allsentencenumber 5 százalékát
let jumpPad = Math.round(allsentencenumber * 0.05);
       // console.log(jumpPad);
        
    if (currentsentencenumber > jumpPad) {
        // Decrease current sentence number by jumpPad
        currentsentencenumber -= jumpPad;
        displaysentence = getSelectedSentence(currentsentencenumber);

        if (displaysentence) {
            document.getElementById('selectedtextblock').innerText = displaysentence;
        }

        updateContextBlock();
        document.getElementById('counter').textContent = currentsentencenumber;
        setSliderToCurrentSentence();
        percentread();
        bookpercent2();
        readText();

        if (currentsentencenumber === 1) {
            playRandomSound();
        }
    } else if (currentsentencenumber > 1 && currentsentencenumber <= jumpPad) {
        // If the number is between 1 and 10
        currentsentencenumber = 1; // Set the smallest value to 1
        displaysentence = getSelectedSentence(currentsentencenumber);

        if (displaysentence) {
            document.getElementById('selectedtextblock').innerText = displaysentence;
        }

        updateContextBlock();
        document.getElementById('counter').textContent = currentsentencenumber;
        setSliderToCurrentSentence();
        
        readText();

        if (currentsentencenumber === 1) {
            playRandomSound();
        }
    }
    // Additional logic or system AI text can be added here
}

function dpadright() {
	stopSpeaking();  
	if (jumpcount === 1) {
                jumpcount = 0;
	
    three();
                                        }
    else {
    

    //alert(allsentencenumber);
    //alert(currentsentencenumber);  tudja mindkettőt ok
      // kiszámolni az ugrás mértékét
        // Számoljuk ki az allsentencenumber 5 százalékát
let jumpPad = Math.round(allsentencenumber * 0.05);
        //console.log(jumpPad);
    
    if (currentsentencenumber === allsentencenumber) {
        playRandomSound(); // System AI text can be added here
    }

    if (currentsentencenumber === allsentencenumber - 1) {
        playRandomSound(); // System AI text can be added here
    }

       
       // A jumpPad változót helyezzük bele a feltételbe és a növelésbe
    if (currentsentencenumber < allsentencenumber - jumpPad) {
       // Növeljük a currentsentencenumber értékét a jumpPad értékével
    currentsentencenumber += jumpPad;
        displaysentence = getSelectedSentence(currentsentencenumber);

        if (displaysentence) {
            document.getElementById('selectedtextblock').innerText = displaysentence;
        }

        updateContextBlock();
        document.getElementById('counter').textContent = currentsentencenumber;
        setSliderToCurrentSentence();
        percentread();
        bookpercent2();
        readText();
    } else if (currentsentencenumber >= allsentencenumber - jumpPad && currentsentencenumber <= allsentencenumber) {
        // If the number is between allsentencenumber - 10 and allsentencenumber
        currentsentencenumber = allsentencenumber; // Set the largest value to allsentencenumber
        displaysentence = getSelectedSentence(currentsentencenumber);

        if (displaysentence) {
            document.getElementById('selectedtextblock').innerText = displaysentence;
        }

        updateContextBlock();
        document.getElementById('counter').textContent = currentsentencenumber;
        setSliderToCurrentSentence();
        readText();
        
    }
    // Additional logic or system AI text can be added here
    
    } // a jumpcount bezárója
}

function percentread(){
	let readpercentage = Math.round((currentsentencenumber / allsentencenumber) * 100);
        readpercentage = (readpercentage + " percent");
        //console.log(readpercentage); 
      //  alert(currentsentencenumber); 
      //  alert(allsentencenumber); 
      //  alert(readpercentage); 
        
        var textToRead2 = readpercentage;
        var lang2 = 'en-ENG';
        var audio2 = new SpeechSynthesisUtterance(textToRead2);
        audio2.lang = lang2;
        audio2.rate = 0.8;
        audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
        audio2.pitch = 1.0;
        speechSynthesis.speak(audio2);
	}



let formattedContent;
function saveToFile() {
  


  console.log(legorigabbcontent);
  //alert(origcontent);

  let savetofilename = bookname;
  savetofilename = savetofilename.replace(/clipboard$/, 'web');

  // Szűrjük ki a speciális karaktereket a fájlnévből
  // ez bennehagyja a szóközöket és ékezeteket good
  let fileName = savetofilename.replace(/[^a-zA-Z0-9áéíóöőúüűÁÉÍÓÖŐÚÜŰ]+/g, ' ');
  //  let fileName = savetofilename.replace(/[^a-zA-Z0-9áéíóöőúüűÁÉÍÓÖŐÚÜŰ]+/g, '');

  let blob = new Blob([legorigabbcontent], { type: 'text/plain' });

  let a = document.createElement('a');
  a.download = fileName;
  a.href = URL.createObjectURL(blob);
  a.click();
}
    
    
    
    
    
    
function toggleSearchPopup() {
	disableKeydownListener();
	
    let searchPopup = document.getElementById('searchPopup');
    searchPopup.style.display = searchPopup.style.display === 'none' ? 'block' : 'none';
}



function togglecleanPopup() {
    let cleanPopup = document.getElementById('cleanPopup');
    cleanPopup.style.display = cleanPopup.style.display === 'none' ? 'block' : 'none';
}



// favorit kezelése


function togglefavoritPopup() {
	
	disableKeydownListener();
	
	stopMonitoring();
	
    let favoritPopup = document.getElementById('favoritPopup');
    let favoritInput = document.getElementById('favoritInput');

    // Ellenőrizzük, hogy van-e 'favoritstorage' bejegyzés a localStorage-ban
    if (localStorage.getItem('favoritstorage') === null) {
        // Ha nincs, akkor hozzunk létre egyet a megadott értékkel
        localStorage.setItem('favoritstorage', '/storage/emulated/0/work new/reader translator tts joy/myText/info start.txt');
    }

    // Olvassuk ki a 'favoritstorage' bejegyzés tartalmát
    favoritInput.value = localStorage.getItem('favoritstorage');

    // Állítsuk be a favoritInput betűméretét
    favoritInput.style.fontSize = '18px'; // vagy bármilyen más méret, amit szeretnél

    // Váltás a popup megjelenítése és elrejtése között
    favoritPopup.style.display = favoritPopup.style.display === 'none' ? 'block' : 'none';
}



function kalandlap() {
	
	disableKeydownListener();
	
	stopMonitoring();
	
    let kalandlapPopup = document.getElementById('kalandlapPopup');
    let kalandlapInput = document.getElementById('kalandlapInput');

    // Ellenőrizzük, hogy van-e 'kalandlapstorage' bejegyzés a localStorage-ban
    if (localStorage.getItem('kalandlapstorage') === null) {
        // Ha nincs, akkor hozzunk létre egyet a megadott értékkel
        localStorage.setItem('kalandlapstorage', '/sto');
    }

    // Olvassuk ki a 'kalandlapstorage' bejegyzés tartalmát
    kalandlapInput.value = localStorage.getItem('kalandlapstorage');

    // Állítsuk be a kalandlapInput betűméretét
    kalandlapInput.style.fontSize = '18px'; // vagy bármilyen más méret, amit szeretnél

    // Váltás a popup megjelenítése és elrejtése között
    kalandlapPopup.style.display = kalandlapPopup.style.display === 'none' ? 'block' : 'none';
}



function kalandlapsave() {
    // A 'textarea' tartalmának kiolvasása
    let kalandlapContent = document.getElementById('kalandlapInput').value;

    // A 'kalandlapstorage' bejegyzés frissítése a 'localStorage'-ban
    localStorage.setItem('kalandlapstorage', kalandlapContent);

    // Felhasználó értesítése
    alert('A kalandlap mentése megtörtént.');
}


function kalandlapsavetofile() {
    let kalandlapContent = localStorage.getItem('kalandlapstorage');
    let blob = new Blob([kalandlapContent], { type: 'text/plain' });
    let url = URL.createObjectURL(blob);
    let link = document.createElement('a');
    link.href = url;
    
    let currentDate = new Date().toLocaleString();
    
    link.download = 'kalandlap_files   ' + currentDate + '   kalandlap_files.txt';
    link.click();
    URL.revokeObjectURL(url);
    
}




function kalandlapclose() {
	
	enableKeydownListener();
	
    let kalandlapPopup = document.getElementById('kalandlapPopup');
    kalandlapPopup.style.display = 'none'; // Az ablak elrejtése
}

function kalandlapclean() {
    // Megkérdezi a felhasználót, hogy biztosan törölni akarja-e az összes tartalmat
    const confirmation = confirm("Biztosan törölni akarja a kalandlap összes tartalmát?");

    // Ha a felhasználó megerősíti a törlést
    if (confirmation) {
    	kalandlapsavetofile();
    
        // Törli a 'kalandlapInput' tartalmát
        document.getElementById('kalandlapInput').value = '';

        // Törli a 'kalandlapstorage' bejegyzést a 'localStorage'-ból
        localStorage.removeItem('kalandlapstorage');

        // Opcióként értesítheted a felhasználót a sikeres törlésről
        alert("A tartalom sikeresen törölve lett.");
    } else {
        // Ha a felhasználó nem erősíti meg, értesítheted őt
        alert("A törlés megszakítva.");
    }
}





// favoritload kezelése frissítve 05 27



 /*          
   ha rákattintok egy listaelemre, akkor az az elem legyen kiválasztható és jelenítse meg alert-ben a listaelem teljes nevét (elérési útvonalát).
Ehhez hasonló megoldás kell:
document.getElementById('fileContent').addEventListener('click', function(event) {
  if (event.target.tagName === 'P') {...
*/

        
//itt a fő funkció kód
// itt a touch favoritload !
// a stopPlayany() sajnos nem működik!?



let favoritContainer; // Globális változó a favoritContainer elem tárolására

function togglefavoritLoadPopup() {
	
	toggleFullscreen();
	
	stopMusic();
	stopPlayany();
    favpopuploadwide = 1;
    favpopuploadForJoy1 = 1;

    let favoritPopup = document.getElementById('favoritLoadPopup');

    // Ellenőrizzük, hogy van-e 'favoritstorage' bejegyzés a localStorage-ban
    if (localStorage.getItem('favoritstorage') === null) {
        // Ha nincs, akkor hozzunk létre egyet a megadott értékkel
        localStorage.setItem('favoritstorage', '/storage/emulated/0/work new/reader translator tts joy/myText/info start.txt');
    }

    // Olvassuk ki a 'favoritstorage' bejegyzés tartalmát
    let favoritStorageContent = localStorage.getItem('favoritstorage');
    let favoritItems = favoritStorageContent.split('\n'); // Feltételezve, hogy minden sor egy elem

    // Töröljük a korábbi elemeket, ha vannak
    favoritPopup.innerHTML = '';

    // Létrehozzuk a megjelenítendő elemet
    favoritContainer = document.createElement('div'); // Globális változóként deklaráljuk
    favoritContainer.className = 'favoritContainer'; // Osztály hozzáadása a kereséshez
    favoritContainer.style.position = 'fixed';
    favoritContainer.style.top = '0';
    favoritContainer.style.left = '0';
    favoritContainer.style.width = '100%';
    favoritContainer.style.height = '100%';
    favoritContainer.style.backgroundColor = 'rgba(90, 150, 210, 0.3)';
    favoritContainer.style.display = 'flex';
    favoritContainer.style.justifyContent = 'center';
    favoritContainer.style.alignItems = 'center';
    favoritContainer.style.zIndex = '10909';
    favoritContainer.style.opacity = '0';
    favoritContainer.style.transition = 'opacity 0.5s ease-in-out';

    // Létrehozzuk a tartalmat tartalmazó elemet
    const favoritContent = document.createElement('div');
    favoritContent.style.backgroundColor = 'rgba(10, 150, 210, 0.8)';
    favoritContent.style.padding = '20px';
    favoritContent.style.borderRadius = '5px';
    favoritContent.style.maxWidth = '80%';
    favoritContent.style.maxHeight = '80%';
    favoritContent.style.overflowY = 'auto';
    favoritContent.style.fontSize = '18px'; // Betűméret beállítása




// Hozzáadjuk a kedvenceket a tartalomhoz
favoritItems.forEach((item, index) => {
    const itemElement = document.createElement('p');
    
    // Kiemelés a fájlnév utolsó perjel utáni részével
    const fileName = item.split('/').pop();
    itemElement.textContent = `${fileName} (${index + 1})`;
    
    // Piros színű elemek
    if (index % 2 === 0) {
        itemElement.style.color = 'rgb(128, 228, 248)';
    }
    
    
    // itt a paragraph handler eleje
    // Kattintásra az elem teljes nevét jelenítse meg alert-ben
    itemElement.addEventListener('click', () => {
        //alert(item);
        stopPlayany();// sajnos nem működik!
stopMusic();
	






//bezár mindent
favcontclose();
        optionsApopupButtonFunction();
        stopSpelling();
        stopSpeaking(); 
        //stopzagor();
        //stopmanualfavoritdelete();
        stopMusic();
        stopPlayany();




async function Bookload(recogbookNum) {
    
//alert(item);
        filePath = item;
      
      
      
    
    
    let bookname = filePath.substring(filePath.lastIndexOf('/') + 1); // Csak a fájl nevét tároljuk a readPath változóban
    
// A bookname faszságai
// Nemkívánatos speciális karakterek
const undesiredSpecialChars = ['+', '-', '_', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];

// Tisztítás
let filteredContent = bookname.split('').map(char => undesiredSpecialChars.includes(char) ? ' ' : char).join('');

// Visszahelyezés a kiszedett karakterek helyére egy space-szel
bookname = filteredContent;
        
//alert(bookname);

//alert(bookname);



// Várakozás
console.log('Várakozás a bookname és az origcontent elérhetőségére...');
  try {
    const message = await waitForContent();
    console.log(message);
    // Itt folytathatod a kód futtatását, miután a bookname és az origcontent elérhető és vártunk egy másodpercet
  } catch (error) {
    console.error('Hiba történt: ', error);
  }





        
        let readPath = filePath.substring(filePath.lastIndexOf('/') + 1); // Csak a fájl nevét tároljuk a readPath változóban
        // itt nem booknamezünk, mert nem biztos hogy ki lesz választva
        //ezért
        // itt kel feltölteni local readpath
        localStorage.setItem('readpathstorage', readPath);
        // readpath kis formázása
        // Kívánatos speciális karakterek
        const desiredSpecialChars = ['?', '!', '.', ',', '\n'];
        // Nemkívánatos speciális karakterek
        const undesiredSpecialChars2 = ['+', '-', '_', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];
        // Számolja meg a nemkívánatos speciális karaktereket
        let undesiredCharCount2 = 0;
        for (let i = 0; i < readPath.length; i++) {
            if (undesiredSpecialChars2.includes(readPath[i])) {
                undesiredCharCount2++;
            }
        }
        // Számolja ki az eredeti tartalom 0.015%-át
        const threshold = readPath.length * 0.00015;
        // Értesítse a felhasználót, ha a limitet túllépték
        if (undesiredCharCount2 > threshold) {
            //  console.log('Figyelem: A nemkívánatos speciális karakterek száma meghaladja a readPath 0.015%-át.' + readPath);
            // tisztítás
            const filteredContent = filterSpecialCharacters(readPath);
            readPath = filteredContent; // replace the original content with
        } else {
            //  console.log('A readPath tartalom megfelelő.');
        }
        // language recog ai for bookname
        let hungarianlanguage = 0;
        let englishlanguage = 0;
        let magyarEkezetesBetukSzama = 0;
        let esSzavakSzama = 0;
        let theSzavakSzama = 0;
        let lapozzSzavakSzama = 0;
        // Magyar ékezetes betűk és "és" szavak számolása
        for (let i = 0; i < readPath.length; i++) {
            let currentChar = readPath[i];
            if (/[áéíóöőúüűÁÉÍÓÖŐÚÜŰ]/.test(currentChar)) {
                magyarEkezetesBetukSzama++;
            }
        }
    
        // "és" szavak számolása
        let szavak = readPath.split(" ");
        for (let j = 0; j < szavak.length; j++) {
            if (szavak[j] === "és") {
                esSzavakSzama++;
            }
        }
        // "the" szavak számolása
        for (let j = 0; j < szavak.length; j++) {
            if (szavak[j] === "the") {
                theSzavakSzama++;
            }
        }
        
        
        
        
        // Ha több, mint 0 magyar ékezetes betű van az origcontent-ben, növeljük a hungarianlanguage változót
        if (magyarEkezetesBetukSzama > 0) {
            hungarianlanguage += 40;
        }
        // Ha nincs magyar ékezetes betű van az origcontent-ben
        if (magyarEkezetesBetukSzama < 1) {
            englishlanguage += 20;
        }
        // Ha több, mint 0 "és" szó van az origcontent-ben, növeljük a hungarianlanguage változót
        if (esSzavakSzama > 0) {
            hungarianlanguage += 35;
        }
        // Ha több, mint 0 "the" szó van az origcontent-ben, növeljük az englishlanguage változót
        if (theSzavakSzama > 0) {
            englishlanguage += 35;
        }
        if (hungarianlanguage > englishlanguage) {
            winner = "hu";
        } else if (hungarianlanguage < englishlanguage) {
            winner = "en";
        }
        //alert(winner);
        
        /*
        //itt nem todom hogy hányadik, talán később megcsinálom
        console.log('Current Favorite Index: ' + (bookIndex + 1));
        var textToRead3 = ((bookIndex + 1) + ' ');
        var audio3 = new SpeechSynthesisUtterance(textToRead3);
        //itt nem todom hogy hányadik, talán később megcsinálom
     //   speechSynthesis.speak(audio3);
     */
     
        var textToRead2 = readPath;
        var lang = 'en-ENG';
        if (winner === "hu") {
            var lang = 'hu-HUN';
        }
        var lang2 = lang;
        var audio2 = new SpeechSynthesisUtterance(textToRead2);
        audio2.lang = lang2;
        audio2.rate = 0.8;
        audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
        audio2.pitch = 1.0;
        speechSynthesis.speak(audio2);
      //  blindfavlodTextContent(filePath); // Hívja meg a blindfavlodTextContent funkciót
        
        
        
        
       // alert(filePath);
       
     
       
       
       //	alert('beolvassa a fájlt: ' + filePath);
  var rawFile = new XMLHttpRequest();
  rawFile.open("GET", filePath, false);
  rawFile.onreadystatechange = function () {
    if(rawFile.readyState === 4) {
      if(rawFile.status === 200 || rawFile.status == 0) {
        var allText = rawFile.responseText;
        origcontent = allText;
        // Sikeres beolvasás esetén jelenítsen meg egy alertet a fájl útvonalával
        //alert('A fájl beolvasása sikeres: ' + filePath);
        
        //bookname = readPath; itt kel kiolvasni local readpath
        
        // A localStorage-ból való kiolvasás helyes módja !?!
//readPath = localStorage.getItem('readpathstorage');

//neeem jo bookname = readPath;

// Most már az alert megjeleníti a helyes bookname értéket


        
        //egyébként az alert undefined bookname!

      

  // AZ OLDAL TELJES ÚJRATÖLTÉSE
//  playrefreshSound();


//alert('bookname: ' + bookname + ' - A fájl beolvasása sikeres: ' + filePath);

//console.log(bookname);
    

   // alert(origcontent);
        
        
        //selectfavoritLoadBlind();
        legorigabbcontent = origcontent;
            
                analysis();   // már itt lefut
            
                replaceSt();
                removeQuotes();  // idézőjel
                replaceMr();
                linebreakreplacement(); //savefilenak formázás
                
                let result = AIrecognizelanguage(origcontent);
                    //jelzőhang
                    
                stopMusic();
                    playRandomSound11();
                
                supervision();
                //console.log(result);
                
                
                // funkción belüli funkció következik
                
                
                
           //     bookname = (randomEntry + " clipboard");
      
      
      
  //    
      
      
           // minden nyitó és záró zárójel kiszedése a bookmark localstorage miatt, ez nem csere 
            bookname = bookname.replace(/[()]/g, '');
            
            
            console.log('File loaded successfully.');

//alert("faszom" + bookname);

 
            	
            
            function fadebookname2() { const wordContainer = document.getElementById("wordContainer"); wordContainer.innerHTML = ""; const words = [ bookname ]; for (let i = 1; i <= 18; i++) { const wordElement = document.createElement("span"); wordElement.id = `word${i}`; wordElement.textContent = words[i - 1]; wordElement.style.animation = `fade-in 0.8s ${0.1 + (i - 1) * 0.1}s forwards cubic-bezier(0.1, 0, 0.5, 0)`; wordElement.style.filter = "blur(24px)"; wordElement.style.opacity = "0"; wordContainer.appendChild(wordElement); } } 

/* history localstorage növelése ha változik a bookname var evenlitener*/
let originalBookname = bookname;

Object.defineProperty(window, "bookname", {
  set: function(newValue) {
    if (newValue !== originalBookname) {
      originalBookname = newValue;

      // Először kiolvassuk a jelenlegi localStorage tartalmát
let historyvar = JSON.parse(localStorage.getItem('history')) || [];

// Majd hozzáadjuk az új könyvcímet
let newBookTitle = bookname + '\n' + new Date().toLocaleDateString();
historyvar.push(newBookTitle);

// Végül frissítjük a localStorage-t az új tartalommal
localStorage.setItem('history', JSON.stringify(historyvar));
    }
  },
  get: function() {
    return originalBookname;
  }
})
            
            fadebookname2(); // fadetext
            
            
                console.log('Book name:', bookname); // Ha létezik a bookname, kiírjuk a konzolba
            
            countSentences();
            bookmarkload(bookname);
      // idáig a core betöltése
        
     //   return;
      }
    }
  }
  rawFile.send(null);
}
       
       
       
    
var bookIndex;


Bookload(recogbookNum);

//idáig a teljes betöltés yeah! csak egy var bookIndex kellett és YO!!!








setTimeout(bookpercent, 3000);
setTimeout(four, 4000);
       // return;



        
        
        
    });
// itt a paragraph handler vége asszem


    
    favoritContent.appendChild(itemElement);
});



    // Létrehozzuk a bezárás gombot
    const closeButton = document.createElement('button');
    closeButton.textContent = 'Close';
    closeButton.style.display = 'block';
    closeButton.style.margin = '10px auto 0';
    closeButton.addEventListener('click', () => {
        favoritContainer.style.opacity = '0';
        setTimeout(() => {
            favoritContainer.remove();
        }, 500);
    });

    favoritContent.appendChild(closeButton);
    favoritContainer.appendChild(favoritContent);
    document.body.appendChild(favoritContainer);

    // Megjelenítjük a fade in animációt
    setTimeout(() => {
        favoritContainer.style.opacity = '1';
    }, 100);

    //a togglefavoritLoadPopup irja bele az itemdbNum változóba, hogy hány favoritItems van összesen, majd alert(itemdbNum)
    itemdbNum = favoritItems.length; // Frissítjük az itemdbNum változót a kedvencek számával
    //alert(itemdbNum); // Megjelenítjük az eredményt egy felugró ablakban
    readany = itemdbNum;

    function véletlenFüggvényVálasztó() {
        var függvények = [readanytext, readanytexthun];
        var választottFüggvény = függvények[Math.floor(Math.random() * függvények.length)];
        választottFüggvény();
    }
    véletlenFüggvényVálasztó();

    //sound
    //playRandomSound8(); ez xar soundplay
    
    
    
  //'snd/bbb', 
     
    
    playany(['snd/music 6 - Hebrew Mantra - YHWH (128 kbps).mp3', 'snd/music 5 - The Epic Of Gilgamesh In Sumerian (128 kbps).mp3', 'snd/Giants Citizen Kabuto - Main Theme (Intro Island).mp3', 'snd/music 4 copyr Sacred Initiation.mp3', 'snd/music 3 bensound-moonlightdrive.mp3', 'snd/music 2 solitude-dark-ambient-electronic-197737.mp3', 'snd/music 1 science-documentary-169621.mp3', 'snd/loop-menu-preview-109594.mp3', 'snd/imagefilm-049-by-sascha-ende-from-filmmusic-io.mp3', 'snd/Y2meta.app - A Biblia könyvei AI Cover (192 kbps).mp3', 'snd/i-am-dreaming-or-final-fantasy-menu-kinda-thing-29173.mp3'], 0.4);
    
    if (nomusic === 1) {
            stopPlayany();
        }
    
    
    
    favoritlistopen = 1;
}


function favoritlistoff() {
    if (favoritContainer) {
        favoritContainer.style.display = 'none';
        
        favoritlistopen = 0;
        
    }
}

// Globális funkció a favoritContainer eltüntetésére
function favcontclose() {
    favoritlistoff();
}











/*alert(recogbookNum);


írj BookNum funkciót. Feladata a recogbookNum (ami egy számot tartalmaz) alapján az index segítségével kiválasztani a megfelelő listaelemet. Segítségnek itt egy másik fajta kiválasztási mód:
    


Folytasd. Miután felolvasta.
A fullPath az ugyanaz mint a filePath. Szóval legyen a filePath=fullPath , és hívja meg ezt a funkciót:
function blindfavlodTextContent(filePath)

könyv-szám funkció
EHHEZ A FUNKCIÓHOZ MÁR NE NAGYON NYÚLJUNK BELE, MERT ÉRZÉKENY ÉS ELROMLIK!!!
*/
let filePath;
async function BookNum(recogbookNum) {
    let bookIndex = parseInt(recogbookNum);
    let favoritStorageContent = localStorage.getItem('favoritstorage');
    if (favoritStorageContent) {
        let favoritItems = favoritStorageContent.split('\n');
        if (bookIndex > 0) {
            bookIndex--; // Előző elemre váltás
        } else {
            bookIndex = favoritItems.length - 1; // Utolsó elemre váltás, ha az első elem van kiválasztva
        }
        filePath = favoritItems[bookIndex];
      
      
      
    
    
    let bookname = filePath.substring(filePath.lastIndexOf('/') + 1); // Csak a fájl nevét tároljuk a readPath változóban
    
// A bookname faszságai
// Nemkívánatos speciális karakterek
const undesiredSpecialChars = ['+', '-', '_', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];

// Tisztítás
let filteredContent = bookname.split('').map(char => undesiredSpecialChars.includes(char) ? ' ' : char).join('');

// Visszahelyezés a kiszedett karakterek helyére egy space-szel
bookname = filteredContent;
        
//alert(bookname);

//alert(bookname);



// Várakozás
console.log('Várakozás a bookname és az origcontent elérhetőségére...');
  try {
    const message = await waitForContent();
    console.log(message);
    // Itt folytathatod a kód futtatását, miután a bookname és az origcontent elérhető és vártunk egy másodpercet
  } catch (error) {
    console.error('Hiba történt: ', error);
  }




//log naplózás
	marsSave(bookname);
        
        let readPath = filePath.substring(filePath.lastIndexOf('/') + 1); // Csak a fájl nevét tároljuk a readPath változóban
        // itt nem booknamezünk, mert nem biztos hogy ki lesz választva
        //ezért
        // itt kel feltölteni local readpath
        localStorage.setItem('readpathstorage', readPath);
        // readpath kis formázása
        // Kívánatos speciális karakterek
        const desiredSpecialChars = ['?', '!', '.', ',', '\n'];
        // Nemkívánatos speciális karakterek
        const undesiredSpecialChars2 = ['+', '-', '_', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];
        // Számolja meg a nemkívánatos speciális karaktereket
        let undesiredCharCount2 = 0;
        for (let i = 0; i < readPath.length; i++) {
            if (undesiredSpecialChars2.includes(readPath[i])) {
                undesiredCharCount2++;
            }
        }
        // Számolja ki az eredeti tartalom 0.015%-át
        const threshold = readPath.length * 0.00015;
        // Értesítse a felhasználót, ha a limitet túllépték
        if (undesiredCharCount2 > threshold) {
            //  console.log('Figyelem: A nemkívánatos speciális karakterek száma meghaladja a readPath 0.015%-át.' + readPath);
            // tisztítás
            const filteredContent = filterSpecialCharacters(readPath);
            readPath = filteredContent; // replace the original content with
        } else {
            //  console.log('A readPath tartalom megfelelő.');
        }
        // language recog ai for bookname
        let hungarianlanguage = 0;
        let englishlanguage = 0;
        let magyarEkezetesBetukSzama = 0;
        let esSzavakSzama = 0;
        let theSzavakSzama = 0;
        // Magyar ékezetes betűk és "és" szavak számolása
        for (let i = 0; i < readPath.length; i++) {
            let currentChar = readPath[i];
            if (/[áéíóöőúüűÁÉÍÓÖŐÚÜŰ]/.test(currentChar)) {
                magyarEkezetesBetukSzama++;
            }
        }
        // "és" szavak számolása
        let szavak = readPath.split(" ");
        for (let j = 0; j < szavak.length; j++) {
            if (szavak[j] === "és") {
                esSzavakSzama++;
            }
        }
        // "the" szavak számolása
        for (let j = 0; j < szavak.length; j++) {
            if (szavak[j] === "the") {
                theSzavakSzama++;
            }
        }
        // Ha több, mint 0 magyar ékezetes betű van az origcontent-ben, növeljük a hungarianlanguage változót
        if (magyarEkezetesBetukSzama > 0) {
            hungarianlanguage += 40;
        }
        // Ha nincs magyar ékezetes betű van az origcontent-ben
        if (magyarEkezetesBetukSzama < 1) {
            englishlanguage += 20;
        }
        // Ha több, mint 0 "és" szó van az origcontent-ben, növeljük a hungarianlanguage változót
        if (esSzavakSzama > 0) {
            hungarianlanguage += 35;
        }
        // Ha több, mint 0 "the" szó van az origcontent-ben, növeljük az englishlanguage változót
        if (theSzavakSzama > 0) {
            englishlanguage += 35;
        }
        if (hungarianlanguage > englishlanguage) {
            winner = "hu";
        } else if (hungarianlanguage < englishlanguage) {
            winner = "en";
        }
        //alert(winner);
        console.log('Current Favorite Index: ' + (bookIndex + 1));
        var textToRead3 = ((bookIndex + 1) + ' ');
        var audio3 = new SpeechSynthesisUtterance(textToRead3);
        speechSynthesis.speak(audio3);
        var textToRead2 = readPath;
        var lang = 'en-ENG';
        if (winner === "hu") {
            var lang = 'hu-HUN';
        }
        var lang2 = lang;
        var audio2 = new SpeechSynthesisUtterance(textToRead2);
        audio2.lang = lang2;
        audio2.rate = 0.8;
        audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
        audio2.pitch = 1.0;
        speechSynthesis.speak(audio2);
      //  blindfavlodTextContent(filePath); // Hívja meg a blindfavlodTextContent funkciót
        
        
        
        
       // alert(filePath);
       
     
       
       
       //	alert('beolvassa a fájlt: ' + filePath);
  var rawFile = new XMLHttpRequest();
  rawFile.open("GET", filePath, false);
  rawFile.onreadystatechange = function () {
    if(rawFile.readyState === 4) {
      if(rawFile.status === 200 || rawFile.status == 0) {
        var allText = rawFile.responseText;
        origcontent = allText;
        // Sikeres beolvasás esetén jelenítsen meg egy alertet a fájl útvonalával
        //alert('A fájl beolvasása sikeres: ' + filePath);
        
        //bookname = readPath; itt kel kiolvasni local readpath
        
        // A localStorage-ból való kiolvasás helyes módja !?!
//readPath = localStorage.getItem('readpathstorage');

//neeem jo bookname = readPath;

// Most már az alert megjeleníti a helyes bookname értéket


        
        //egyébként az alert undefined bookname!

      

  // AZ OLDAL TELJES ÚJRATÖLTÉSE
//  playrefreshSound();


//alert('bookname: ' + bookname + ' - A fájl beolvasása sikeres: ' + filePath);

//console.log(bookname);
    

   // alert(origcontent);
        
        
        //selectfavoritLoadBlind();
        legorigabbcontent = origcontent;
            
                analysis();   // már itt lefut
            
                replaceSt();
                removeQuotes();  // idézőjel
                replaceMr();
                linebreakreplacement(); //savefilenak formázás
                
                let result = AIrecognizelanguage(origcontent);
                    //jelzőhang
                    
                stopMusic();
                    playRandomSound11();
                
                supervision();
                //console.log(result);
                
                
                // funkción belüli funkció következik
                
                
                
           //     bookname = (randomEntry + " clipboard");
      
      
      
  //    
      
      
           // minden nyitó és záró zárójel kiszedése a bookmark localstorage miatt, ez nem csere 
            bookname = bookname.replace(/[()]/g, '');
            
            
            console.log('File loaded successfully.');

//alert("faszom" + bookname);

 
            	
            
            function fadebookname2() { const wordContainer = document.getElementById("wordContainer"); wordContainer.innerHTML = ""; const words = [ bookname ]; for (let i = 1; i <= 18; i++) { const wordElement = document.createElement("span"); wordElement.id = `word${i}`; wordElement.textContent = words[i - 1]; wordElement.style.animation = `fade-in 0.8s ${0.1 + (i - 1) * 0.1}s forwards cubic-bezier(0.11, 0, 0.5, 0)`; wordElement.style.filter = "blur(24px)"; wordElement.style.opacity = "0"; wordContainer.appendChild(wordElement); } } 

/* history localstorage növelése ha változik a bookname var evenlitener*/
let originalBookname = bookname;

Object.defineProperty(window, "bookname", {
  set: function(newValue) {
    if (newValue !== originalBookname) {
      originalBookname = newValue;

      // Először kiolvassuk a jelenlegi localStorage tartalmát
let historyvar = JSON.parse(localStorage.getItem('history')) || [];

// Majd hozzáadjuk az új könyvcímet
let newBookTitle = bookname + '\n' + new Date().toLocaleDateString();
historyvar.push(newBookTitle);

// Végül frissítjük a localStorage-t az új tartalommal
localStorage.setItem('history', JSON.stringify(historyvar));
    }
  },
  get: function() {
    return originalBookname;
  }
})
            
            fadebookname2(); // fadetext
            
            
                console.log('Book name:', bookname); // Ha létezik a bookname, kiírjuk a konzolba
            
            countSentences();
            
      // idáig a core betöltése
        
        setTimeout(bookpercent, 5000);
setTimeout(four, 6000);
        
     //   return;
      }
    }
  }
  rawFile.send(null);
}
       
       
       
    
}





// buttonoknak logori szurt toggle

let isSzurtActive = true;  // Alapból szurt aktív

function legorig() {
    console.log("legorig() fut");
    // Ide jön a legorig() funkció tényleges tartalma
}

function szurt() {
    console.log("szurt() fut");
    // Ide jön a szurt() funkció tényleges tartalma
}

function toggleFunc() {
    const btn = document.getElementById('toggleFuncBtn');
    if (isSzurtActive) {
        // Szurt aktív volt, most legorig lesz aktív
        legorig();
        btn.textContent = 'Legorig ON';
        btn.style.backgroundColor = '#4CAF50';  // zöld szín
    } else {
        // Legorig aktív volt, most szurt lesz aktív
        szurt();
        btn.textContent = 'Szurt ON';
        btn.style.backgroundColor = '';  // alapértelmezett szín
    }
    isSzurtActive = !isSzurtActive;  // Állapot váltás
}

// Oldal betöltésekor automatikusan elindítjuk a szurt funkciót, mert az alapértelmezett
window.addEventListener('DOMContentLoaded', () => {
    szurt();
});



// original textet olvasni

function legorig() {	
	
	gamePlaySound(['snd/original Tom Grayson Genny Untitled.wav', 'snd/original text Annie Genny Untitled.wav'], 1);
	
	numberreminder = currentsentencenumber;
          //  alert(numberreminder);
            
            
            origcontent = ("");            
            
            //alert(origcontent);
            
               // analysis();   // már itt lefut
            
                //replaceSt();
                //removeQuotes();  // idézőjel
                //replaceMr();
               // linebreakreplacement(); //savefilenak formázás
                
                let result = AIrecognizelanguage(origcontent);
                    //jelzőhang
                    
                stopMusic();
                    playRandomSound11();
                
                
                //ORIGINALT
               // origcontent = legorigabbcontent;
                origcontent = legorigabbcontent;
                //alert(origcontent);
                
                
                supervision();
                //console.log(result);
                
                
                // funkción belüli funkció következik
                
                
                
           //     bookname = (randomEntry + " clipboard");
      
      
      
  //    
      
      
           // minden nyitó és záró zárójel kiszedése a bookmark localstorage miatt, ez nem csere 
            bookname = bookname.replace(/[()]/g, '');
            
            
            console.log('File loaded successfully.');

//alert("faszom" + bookname);

 
            	
            
            function fadebookname2() { const wordContainer = document.getElementById("wordContainer"); wordContainer.innerHTML = ""; const words = [ bookname ]; for (let i = 1; i <= 18; i++) { const wordElement = document.createElement("span"); wordElement.id = `word${i}`; wordElement.textContent = words[i - 1]; wordElement.style.animation = `fade-in 0.8s ${0.1 + (i - 1) * 0.1}s forwards cubic-bezier(0.11, 0, 0.5, 0)`; wordElement.style.filter = "blur(24px)"; wordElement.style.opacity = "0"; wordContainer.appendChild(wordElement); } } 

/* history localstorage növelése ha változik a bookname var evenlitener*/
let originalBookname = bookname;

Object.defineProperty(window, "bookname", {
  set: function(newValue) {
    if (newValue !== originalBookname) {
      originalBookname = newValue;

      // Először kiolvassuk a jelenlegi localStorage tartalmát
let historyvar = JSON.parse(localStorage.getItem('history')) || [];

// Majd hozzáadjuk az új könyvcímet
let newBookTitle = bookname + '\n' + new Date().toLocaleDateString();
historyvar.push(newBookTitle);

// Végül frissítjük a localStorage-t az új tartalommal
localStorage.setItem('history', JSON.stringify(historyvar));
    }
  },
  get: function() {
    return originalBookname;
  }
})
            
            fadebookname2(); // fadetext
            
            
                console.log('Book name:', bookname); // Ha létezik a bookname, kiírjuk a konzolba
            
            countSentences();
            
      // idáig a core betöltése
        
        setTimeout(bookpercent, 5000);
setTimeout(four, 6000);
        
     //   return;
      }
    
   //originaltextet vége




// filtered textet olvasni

function szurt() {	
	
	//numberreminder = currentsentencenumber;
          //  alert(numberreminder);
            
            
            origcontent = ("");            
            origcontent = legorigabbcontent;
            
            
            //alert(origcontent);
            
                analysis();   // már itt lefut
            
                replaceSt();
                removeQuotes();  // idézőjel
                replaceMr();
                linebreakreplacement(); //savefilenak formázás
                
                let result = AIrecognizelanguage(origcontent);
                    //jelzőhang
                    
                stopMusic();
                    playRandomSound11();
                
                
                //nem originalt
               // origcontent = legorigabbcontent;
                //origcontent = legorigabbcontent;
                //alert(origcontent);
                
                
                supervision();
                //console.log(result);
                
                
                // funkción belüli funkció következik
                
                
                
           //     bookname = (randomEntry + " clipboard");
      
      
      
  //    
      
      
           // minden nyitó és záró zárójel kiszedése a bookmark localstorage miatt, ez nem csere 
            bookname = bookname.replace(/[()]/g, '');
            
            
            console.log('File loaded successfully.');

//alert("faszom" + bookname);

 
            	
            
            function fadebookname2() { const wordContainer = document.getElementById("wordContainer"); wordContainer.innerHTML = ""; const words = [ bookname ]; for (let i = 1; i <= 18; i++) { const wordElement = document.createElement("span"); wordElement.id = `word${i}`; wordElement.textContent = words[i - 1]; wordElement.style.animation = `fade-in 0.8s ${0.1 + (i - 1) * 0.1}s forwards cubic-bezier(0.11, 0, 0.5, 0)`; wordElement.style.filter = "blur(24px)"; wordElement.style.opacity = "0"; wordContainer.appendChild(wordElement); } } 

/* history localstorage növelése ha változik a bookname var evenlitener*/
let originalBookname = bookname;

Object.defineProperty(window, "bookname", {
  set: function(newValue) {
    if (newValue !== originalBookname) {
      originalBookname = newValue;

      // Először kiolvassuk a jelenlegi localStorage tartalmát
let historyvar = JSON.parse(localStorage.getItem('history')) || [];

// Majd hozzáadjuk az új könyvcímet
let newBookTitle = bookname + '\n' + new Date().toLocaleDateString();
historyvar.push(newBookTitle);

// Végül frissítjük a localStorage-t az új tartalommal
localStorage.setItem('history', JSON.stringify(historyvar));
    }
  },
  get: function() {
    return originalBookname;
  }
})
            
            fadebookname2(); // fadetext
            
            
                console.log('Book name:', bookname); // Ha létezik a bookname, kiírjuk a konzolba
            
            countSentences();
            
            
            //vissza az eredeti pozícióra, akkor is ha ellapoznánk
            
            currentsentencenumber = ("");
            	currentsentencenumber = numberreminder;
            //alert(currentsentencenumber);
            setbookmarksentence = currentsentencenumber;
            
           
                // Frissítjük a számlálót az új mondat sorszámával
    let counter = document.getElementById('counter');
    counter.textContent = currentsentencenumber;

    // Megjelenítjük a bookmark-hoz tartozó mondatot a selectedtextblock-ban
    
    //console.log(origcontent);
    //alert();
    let sentences = origcontent.match(/[^.!?]+(?:\.|!|\?)(?=\s|$)/g);
    if (sentences && sentences.length > setbookmarksentence - 1) {
        let selectedSentence = sentences[setbookmarksentence - 1].trim();
        document.getElementById('selectedtextblock').innerText = selectedSentence;
    }

    // Megjelenítjük a bookmark-hoz tartozó mondatot a contextblock-ban
    let contextSentences = origcontent.match(/[^.!?]+(?:\.|!|\?)(?=\s|$)/g);
    if (contextSentences && contextSentences.length > setbookmarksentence - 1) {
        let selectedSentence = contextSentences[setbookmarksentence - 1].trim();
        document.getElementById('selectedtextblock').innerText = selectedSentence;

        // Előző és következő 2 mondat hozzáadása a contextblock-hoz
        let contextBlockContent = "";
        if (setbookmarksentence > 1) {
            contextBlockContent += contextSentences[setbookmarksentence - 3].trim() + " ";
        }
        contextBlockContent += selectedSentence + " ";
        if (setbookmarksentence < contextSentences.length) {
            contextBlockContent += contextSentences[setbookmarksentence].trim();
        }
        document.getElementById('contextblock').innerText = contextBlockContent;
    }
            
             //vissza az eredeti pozícióra, akkor is ha ellapoznánk Vége
            
            
            
            
      // idáig a core betöltése
        
        setTimeout(bookpercent, 5000);
setTimeout(four, 6000);
        
     //   return;
      }
        //filteredtextet vége
       
       
    







let currentFavoritIndex = -1; // Globális változó a jelenlegi index nyomon követésére

let selectLoadBlind = ''; // Globális változó a kiválasztott elem tárolására

function downfavoritLoad() {
	
		favpopuploadwide = 0;
	
    let favoritStorageContent = localStorage.getItem('favoritstorage');
    if (favoritStorageContent) {
        let favoritItems = favoritStorageContent.split('\n');
        currentFavoritIndex++; // Növeljük az indexet a következő elemre
        if (currentFavoritIndex >= favoritItems.length) {
            currentFavoritIndex = 0; // Vissza az első elemre, ha a végére értünk
            playRandomSound13();
            
        }
        let fullPath = favoritItems[currentFavoritIndex];
        let readPath = fullPath.substring(fullPath.lastIndexOf('/') + 1); // Csak a fájl nevét tároljuk a readPath változóban
        
        
        // itt nem booknamezünk, mert nem biztos hogy ki lesz választva
        //ezért
       // itt kel feltölteni local readpath
       localStorage.setItem('readpathstorage', readPath);
       
       // readpath kis formázása
       
 selectLoadBlind = fullPath; // A teljes útvonalat tároljuk
        
             // Kívánatos speciális karakterek
    const desiredSpecialChars = ['?', '!', '.', ',', '\n'];
    // Nemkívánatos speciális karakterek
        const undesiredSpecialChars = ['+', '-', '_', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];

    
    let undesiredCharCount = 0;
    
    // Számolja meg a nemkívánatos speciális karaktereket
    for (let i = 0; i < readPath.length; i++) {
        if (undesiredSpecialChars.includes(readPath[i])) {
            undesiredCharCount++;
        }
    }
    
    // Számolja ki az eredeti tartalom 0.015%-át
    const threshold = readPath.length * 0.00015;
    
    // Értesítse a felhasználót, ha a limitet túllépték
    if (undesiredCharCount > threshold) {
      //  console.log('Figyelem: A nemkívánatos speciális karakterek száma meghaladja a readPath 0.015%-át.' + readPath);
        
                // tisztítás
     const filteredContent = filterSpecialCharacters(readPath);
      readPath = filteredContent; // replace the original content with
        
    } else {
      //  console.log('A readPath tartalom megfelelő.');
    }
    
 
    // language recog ai for bookname
    
   let hungarianlanguage = 0;
    let englishlanguage = 0;
    let magyarEkezetesBetukSzama = 0;
    let esSzavakSzama = 0;
    let theSzavakSzama = 0;
    
    // Magyar ékezetes betűk és "és" szavak számolása
    for (let i = 0; i < readPath.length; i++) {
        let currentChar = readPath[i];
        if (/[áéíóöőúüűÁÉÍÓÖŐÚÜŰ]/.test(currentChar)) {
            magyarEkezetesBetukSzama++;
        }
    }
    
    // "és" szavak számolása
    let szavak = readPath.split(" ");
    for (let j = 0; j < szavak.length; j++) {
        if (szavak[j] === "és") {
            esSzavakSzama++;
        }
    }
    
    // "the" szavak számolása
    for (let j = 0; j < szavak.length; j++) {
        if (szavak[j] === "the") {
            theSzavakSzama++;
        }
    }
    
    // Ha több, mint 0 magyar ékezetes betű van az origcontent-ben, növeljük a hungarianlanguage változót
    if (magyarEkezetesBetukSzama > 0) {
        hungarianlanguage += 40;
    }
    
     // Ha nincs magyar ékezetes betű van az origcontent-ben
    if (magyarEkezetesBetukSzama < 1) {
        englishlanguage += 20;
    }
    
    // Ha több, mint 0 "és" szó van az origcontent-ben, növeljük a hungarianlanguage változót
    if (esSzavakSzama > 0) {
        hungarianlanguage += 35;
    }
    
    // Ha több, mint 0 "the" szó van az origcontent-ben, növeljük az englishlanguage változót
    if (theSzavakSzama > 0) {
        englishlanguage += 35;
    }
    
//    console.log(hungarianlanguage);
//    console.log(englishlanguage);
  
if (hungarianlanguage > englishlanguage) {
  winner = "hu";
// marqueaihuneng();
   
} else if (hungarianlanguage < englishlanguage) {
  winner = "en";
//marqueaienghun();
  }
  
  //alert(winner);
  
 console.log('Current Favorite Index: ' + (currentFavoritIndex + 1));
var textToRead3 = ((currentFavoritIndex + 1) + ' ');
var audio3 = new SpeechSynthesisUtterance(textToRead3);
    speechSynthesis.speak(audio3);
 currentbooknumber = textToRead3;
 
        var textToRead2 = readPath;
        var lang = 'en-ENG';
     if (winner === "hu") {
       var lang = 'hu-HUN';
          }
var lang2 = lang;
var audio2 = new SpeechSynthesisUtterance(textToRead2);
audio2.lang = lang2;
audio2.rate = 0.8;
audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
audio2.pitch = 1.0;
speechSynthesis.speak(audio2);
        

    
        
     //   readAloud(readPath); // Felolvassa a fájl nevét
        
        
        
    } else {
        console.error('Nincs "favoritstorage" bejegyzés a localStorage-ban.');
    }
    
    
    
}


/*
a funkcióval az a probléma, hogy az első meghíváskor nem vissza fele lép egyet a listában, hanem előre. Érdekes módon a második meghívásnál már jól csinálja és visszafele lép.
*/

//felfele
function upfavoritLoad() {
    favpopuploadwide = 0;

    let favoritStorageContent = localStorage.getItem('favoritstorage');
    if (favoritStorageContent) {
        let favoritItems = favoritStorageContent.split('\n');
        
        currentFavoritIndex--;
        
        if (currentFavoritIndex < 0) {
            currentFavoritIndex = favoritItems.length - 1; // Ugrás az utolsó elemre, ha az elejére értünk
            playRandomSound13();
        }
        let fullPath = favoritItems[currentFavoritIndex];
        let readPath = fullPath.substring(fullPath.lastIndexOf('/') + 1); // Csak a fájl nevét tároljuk a readPath változóban

        localStorage.setItem('readpathstorage', readPath);

        selectLoadBlind = fullPath; // A teljes útvonalat tároljuk

        const desiredSpecialChars = ['?', '!', '.', ',', '\n'];
        const undesiredSpecialChars = ['+', '-', '_', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];

        let undesiredCharCount = 0;

        for (let i = 0; i < readPath.length; i++) {
            if (undesiredSpecialChars.includes(readPath[i])) {
                undesiredCharCount++;
            }
        }

        const threshold = readPath.length * 0.00015;

        if (undesiredCharCount > threshold) {
            const filteredContent = filterSpecialCharacters(readPath);
            readPath = filteredContent;
        }

        let magyarEkezetesBetukSzama = 0;
        let esSzavakSzama = 0;
        let theSzavakSzama = 0;

        for (let i = 0; i < readPath.length; i++) {
            let currentChar = readPath[i];
            if (/[áéíóöőúüűÁÉÍÓÖŐÚÜŰ]/.test(currentChar)) {
                magyarEkezetesBetukSzama++;
            }
        }

        let szavak = readPath.split(" ");
        for (let j = 0; j < szavak.length; j++) {
            if (szavak[j] === "és") {
                esSzavakSzama++;
            }
        }

        for (let j = 0; j < szavak.length; j++) {
            if (szavak[j] === "the") {
                theSzavakSzama++;
            }
        }

        let hungarianlanguage = 0;
        let englishlanguage = 0;

        if (magyarEkezetesBetukSzama > 0) {
            hungarianlanguage += 40;
        }

        if (magyarEkezetesBetukSzama < 1) {
            englishlanguage += 20;
        }

        if (esSzavakSzama > 0) {
            hungarianlanguage += 35;
        }

        if (theSzavakSzama > 0) {
            englishlanguage += 35;
        }

        winner = "";
        if (hungarianlanguage > englishlanguage) {
            winner = "hu";
        } else if (hungarianlanguage < englishlanguage) {
            winner = "en";
        }

console.log('Current Favorite Index: ' + (currentFavoritIndex + 1));
var textToRead3 = ((currentFavoritIndex + 1) + ' ');
var audio3 = new SpeechSynthesisUtterance(textToRead3);
    speechSynthesis.speak(audio3);
currentbooknumber = textToRead3;

        var textToRead2 = readPath;
        var lang = 'en-ENG';
        if (winner === "hu") {
            lang = 'hu-HUN';
        }
        var lang2 = lang;
        var audio2 = new SpeechSynthesisUtterance(textToRead2);
        audio2.lang = lang2;
        audio2.rate = 0.8;
        audio2.volume = 1;
        audio2.pitch = 1.0;
        speechSynthesis.speak(audio2);

        
    } else {
        console.error('Nincs "favoritstorage" bejegyzés a localStorage-ban.');
    }
}








let favoritPopup = document.getElementById('favoritLoadPopup'); // Globális változó a popup elemhez

//console
//readPath is not defined

let readPath;

function blindfavlodTextContent(filePath) {
//	alert('beolvassa a fájlt: ' + filePath);
  var rawFile = new XMLHttpRequest();
  rawFile.open("GET", filePath, false);
  rawFile.onreadystatechange = function () {
    if(rawFile.readyState === 4) {
      if(rawFile.status === 200 || rawFile.status == 0) {
        var allText = rawFile.responseText;
        origcontent = allText;
        // Sikeres beolvasás esetén jelenítsen meg egy alertet a fájl útvonalával
        //alert('A fájl beolvasása sikeres: ' + filePath);
        
        //bookname = readPath; itt kel kiolvasni local readpath
        
        // A localStorage-ból való kiolvasás helyes módja !?!
readPath = localStorage.getItem('readpathstorage');
bookname = readPath;

// Most már az alert megjeleníti a helyes bookname értéket
//alert('bookname: ' + bookname + ' - A fájl beolvasása sikeres: ' + filePath);

        
        //egyébként az alert undefined bookname!

      } else {
      	playRandomSound20();
        // Ha a fájl beolvasása nem sikerül, jelenítsen meg egy alertet
        
        fadeInOutText('No File found!', 38, 'rgba(220, 60, 20, 1)', 5);
        manualbookdelete();
    return;
        
        
        
        alert('Nem sikerült beolvasni a fájlt: ' + filePath + '\\nFavoritból törlésre kerül: ' + filePath);

        
        
        
        
// Delete favorit line
        
        	//alert('deleteline');
	//alert(filePath);
    // A 'favoritstorage' bejegyzés tartalmának kiolvasása a 'localStorage'-ból
    let favoritContent = localStorage.getItem('favoritstorage');

    // Ellenőrizze, hogy a tartalom nem üres
    if (favoritContent) {
        // Szétválasztja a sorokat
        let lines = favoritContent.split('\n');

        // Keresse meg a filePath változóban levő sort
      //  let filePath = '...'; // Itt helyettesítse a tényleges értékkel
    //  alert(filePath);
        let indexToRemove = lines.findIndex(line => line.includes(filePath));

        if (indexToRemove !== -1) {
         
            lines.splice(indexToRemove, 1);


            // Frissítse a 'favoritstorage' bejegyzést a módosított tartalommal
            localStorage.setItem('favoritstorage', lines.join('\n'));

            // Felhasználó értesítése
            //alert('A favorit sorok törlése megtörtént.');
        } else {
            alert('A megadott fájl nem található a kedvencek között.');
        }
    } else {
        alert('Nincs mentett kedvenc.');
    }
    
    // Delete vége
    
  //Delete rapidline is az oldalszámmal együtt
  
  
  // Load bookmarkrapidvar from local storage
 // var bookmarkrapidvar = localStorage.getItem("bookmarkrapid");

var bookmarkrapidvar = localStorage.getItem("bookmarkrapid");



readPath = localStorage.getItem('readpathstorage');
bookname = readPath;
  // Display the bookmarkrapidvar content
  //alert(bookmarkrapidvar);
//alert(bookname);

  // Get the value of the bookname variable (replace with actual value)
 // var bookname = "..."; // Replace with the actual value

//alert(bookname);





  // Split the content into lines
      if (bookmarkrapidvar) {
  let lines = bookmarkrapidvar.split('\n');

  // Find the index of the line containing the bookname
  let indexToRemove = lines.findIndex(line => line.includes(bookname));

  if (indexToRemove !== -1) {
    // Remove the line containing the bookname
    lines.splice(indexToRemove, 1);

    // Also remove the next line (if it exists)
   // if (lines[indexToRemove]) {
      lines.splice(indexToRemove, 1);
   // }

    // Update the 'bookmarkrapid' entry in local storage
    localStorage.setItem('bookmarkrapid', lines.join('\n'));

    // Notify the user
    //alert('A fasom sorok törlése megtörtént.');
    startTypingAnimation('paragraphId', 'divId', 'The entries have been deleted');
    
  } else {
    alert('A megadott könyv nem található a listában.');
  }
  
      } else {
        alert('Nincs mentett kedvenc.');
    }

  // AZ OLDAL TELJES ÚJRATÖLTÉSE
  playrefreshSound();



    
        
        
        
        
        
        return;
      }
    }
  }
  rawFile.send(null);
}

function favoritdellines() {

}


function waitForContent() {
  return new Promise((resolve) => {
    // Ellenőrizzük, hogy a bookname és az origcontent változók elérhetőek-e
    if (typeof bookname !== 'undefined' && typeof origcontent !== 'undefined') {
      setTimeout(() => {
        resolve('A bookname és az origcontent elérhető.');
      }, 1000); // Várunk egy másodpercet, mielőtt folytatjuk
    } else {
      console.error('A bookname vagy az origcontent még nem elérhető.');
    }
  });
}

 
  





// joypad favoritload

async function selectfavoritLoadBlind() {
	firstdomload = 0; //hogy minden új betöltésnél a megfelelő booknumbert olvassa
	// a legelsőnél még ne indítson semmit, csak bemondja hány elem van
		if (favpopuploadwide === 1) {
			return;
			}
	
    favoritPopup.style.display = 'none'; // Elrejti a popup ablakot
    	favpopuploadwide = 0; 
    currentFavoritIndex = 0;
    blindfavlodTextContent(selectLoadBlind);
    //alert(selectLoadBlind);
    
localStorage.setItem('lastbook', selectLoadBlind);

// Később, ha szükséged van rá, hogy olvassd be a tartalmat:
//var storedData = localStorage.getItem('lastbook');
//console.log(storedData);
    
    //alert(origcontent);
    

    
    


  
// A bookname faszságai
// Nemkívánatos speciális karakterek
const undesiredSpecialChars = ['+', '-', '_', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];

// Tisztítás
let filteredContent = bookname.split('').map(char => undesiredSpecialChars.includes(char) ? ' ' : char).join('');

// Visszahelyezés a kiszedett karakterek helyére egy space-szel
bookname = filteredContent;
        
//alert(bookname);
//alert(bookname);

// Várakozás
console.log('Várakozás a bookname és az origcontent elérhetőségére...');
  try {
    const message = await waitForContent();
    console.log(message);
    // Itt folytathatod a kód futtatását, miután a bookname és az origcontent elérhető és vártunk egy másodpercet
  } catch (error) {
    console.error('Hiba történt: ', error);
  }
  
  
  


      legorigabbcontent = origcontent;
            
                analysis();   // már itt lefut
            
                replaceSt();
                removeQuotes();  // idézőjel
                replaceMr();
                linebreakreplacement(); //savefilenak formázás
                
                let result = AIrecognizelanguage(origcontent);
                    //jelzőhang
                    
                stopMusic();
                    playRandomSound11();
                
                supervision();
                //console.log(result);
                
                
                // funkción belüli funkció következik
                
                
                
           //     bookname = (randomEntry + " clipboard");
      
      
      
  //    
      
      
           // minden nyitó és záró zárójel kiszedése a bookmark localstorage miatt, ez nem csere 
            bookname = bookname.replace(/[()]/g, '');
            
            
            console.log('File loaded successfully.');

            if (bookname) {
            	fadebookname(); // fadetext
                console.log('Book name:', bookname); // Ha létezik a bookname, kiírjuk a konzolba
            }
            countSentences();
            
      // idáig a core betöltése
      
}






// last book load

async function lastbookload() {
	
    favoritPopup.style.display = 'none'; // Elrejti a popup ablakot
    	favpopuploadwide = 0; 
    currentFavoritIndex = 0;
    
    
//localStorage.setItem('lastbook', selectLoadBlind);

// Később, ha szükséged van rá, hogy olvassd be a tartalmat:


    
var selectLoadBlind = localStorage.getItem('lastbook');
//console.log(storedData);
    
    blindfavlodTextContentLast(selectLoadBlind);
    
    
    
    bookname = selectLoadBlind.split('/').pop();
console.log(bookname);  // Outputs: "Dean-J.txt"
    
    
   // alert(selectLoadBlind);
    //alert(bookname);
    
    function blindfavlodTextContentLast(filePath) {
  var rawFile = new XMLHttpRequest();
  rawFile.open("GET", filePath, false);
  rawFile.onreadystatechange = function () {
    if(rawFile.readyState === 4) {
      if(rawFile.status === 200 || rawFile.status == 0) {
        var allText = rawFile.responseText;
        origcontent = allText;
      }
    }
  }
  rawFile.send(null);
}
    
  //  alert(origcontent);
    

    
    


  
// A bookname faszságai
// Nemkívánatos speciális karakterek
const undesiredSpecialChars = ['+', '-', '_', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];

// Tisztítás
let filteredContent = bookname.split('').map(char => undesiredSpecialChars.includes(char) ? ' ' : char).join('');

// Visszahelyezés a kiszedett karakterek helyére egy space-szel
bookname = filteredContent;
        
//alert(bookname);


// Várakozás
console.log('Várakozás a bookname és az origcontent elérhetőségére...');
  try {
    const message = await waitForContent();
    console.log(message);
    // Itt folytathatod a kód futtatását, miután a bookname és az origcontent elérhető és vártunk egy másodpercet
  } catch (error) {
    console.error('Hiba történt: ', error);
  }
  
  
  


      legorigabbcontent = origcontent;
            
                analysis();   // már itt lefut
            
                replaceSt();
                removeQuotes();  // idézőjel
                replaceMr();
                linebreakreplacement(); //savefilenak formázás
                
                let result = AIrecognizelanguage(origcontent);
                    //jelzőhang
                    
                stopMusic();
                    playRandomSound11();
                
                supervision();
                //console.log(result);
                
                
                // funkción belüli funkció következik
                
                
                
           //     bookname = (randomEntry + " clipboard");
      
      
      
  //    
      
      
           // minden nyitó és záró zárójel kiszedése a bookmark localstorage miatt, ez nem csere 
            bookname = bookname.replace(/[()]/g, '');
            
            
            console.log('File loaded successfully.');

            if (bookname) {
            	fadebookname(); // fadetext
                console.log('Book name:', bookname); // Ha létezik a bookname, kiírjuk a konzolba
            }
            countSentences();
            
      // idáig a core betöltése
      
}







function readAloud(text) {
    let utterance = new SpeechSynthesisUtterance(text);
    speechSynthesis.speak(utterance);
}









// touch favoritload nem ez!

 async function selectfavoritLoad(selectedItem) {
 	stopMusic();
 stopPlayany();
 //alert();
    // Itt kezeljük az selectedItem használatát
  //  alert('Selected item:' + selectedItem);
    // További logika...
    blindfavlodTextContent(selectedItem);
   // alert(origcontent);
    
    
    
    
    let fullPath = selectedItem;
        let readPath = fullPath.substring(fullPath.lastIndexOf('/') + 1); // Csak a fájl nevét tároljuk a readPath változóban
       let filteredContent = readPath; // Inicializáljuk a filteredContent változót
bookname = readPath;
       
       // readpath kis formázása
       
 selectLoadBlind = fullPath; // A teljes útvonalat tároljuk
        
             // Kívánatos speciális karakterek
    const desiredSpecialChars = ['?', '!', '.', ',', '\n'];
    // Nemkívánatos speciális karakterek
    const undesiredSpecialChars = ['+', '-', '_', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];

    
    let undesiredCharCount = 0;
    
    // Számolja meg a nemkívánatos speciális karaktereket
    for (let i = 0; i < readPath.length; i++) {
        if (undesiredSpecialChars.includes(readPath[i])) {
            undesiredCharCount++;
        }
    }
    
    // Számolja ki az eredeti tartalom 0.015%-át
    const threshold = readPath.length * 0.00015;
    
    // Értesítse a felhasználót, ha a limitet túllépték
    if (undesiredCharCount > threshold) {
        console.log('Figyelem: A nemkívánatos speciális karakterek száma meghaladja a readPath 0.015%-át.' + readPath);
        
                // tisztítás
     const filteredContent = filterSpecialCharacters(readPath);
      readPath = filteredContent; // replace the original content with
        
    } else {
        console.log('A readPath tartalom megfelelő.');
    }
    
        // Visszahelyezés a kiszedett karakterek helyére egy space-szel
bookname = filteredContent;
        
//alert(bookname);


        var textToRead2 = readPath;
        var lang = 'en-ENG';
 //     if (winner === "hu") {
    //    var lang = 'hu-HUN';
   //     }
var lang2 = lang;
var audio2 = new SpeechSynthesisUtterance(textToRead2);
audio2.lang = lang2;
audio2.rate = 0.8;
audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
audio2.pitch = 1.0;
speechSynthesis.speak(audio2);
        
    favoritPopup.style.display = 'none'; // Elrejti a popup ablakot
    currentFavoritIndex = 0;
    
    // Várakozás
console.log('Várakozás a bookname és az origcontent elérhetőségére...');
  try {
    const message = await waitForContent();
    console.log(message);
    // Itt folytathatod a kód futtatását, miután a bookname és az origcontent elérhető és vártunk egy másodpercet
  } catch (error) {
    console.error('Hiba történt: ', error);
  }
  
  
  


      legorigabbcontent = origcontent;
            
                analysis();   // már itt lefut
            
                replaceSt();
                removeQuotes();  // idézőjel
                replaceMr();
                linebreakreplacement(); //savefilenak formázás
                
                let result = AIrecognizelanguage(origcontent);
                supervision();
                //console.log(result);
                
                
                // funkción belüli funkció következik
                
                
                
           //     bookname = (randomEntry + " clipboard");
      
      
      
  //    
      
      
           // minden nyitó és záró zárójel kiszedése a bookmark localstorage miatt, ez nem csere 
            bookname = bookname.replace(/[()]/g, '');
            
            
            console.log('File loaded successfully.');

            if (bookname) {
            	fadebookname(); // fadetext
                console.log('Book name:', bookname); // Ha létezik a bookname, kiírjuk a konzolba
            }
            countSentences();
            
      // idáig a core betöltése
    
    
    
}

 








//   ez már egész más, ez az editor favorit

async function favoritadd() {
    try {
        let clipboardContent = await navigator.clipboard.readText();
        let existingEntries = localStorage.getItem('favoritstorage') || '';
        // Ellenőrizzük, hogy a vágólap tartalma tartalmazza-e a kívánt szöveget
        if (clipboardContent.includes("Total commander file list")) {
            let extractedPath = clipboardContent.match(/\/storage[\s\S]*?\.txt/)[0];
            // Ellenőrizzük, hogy az extractedPath tartalmaz-e "+" karaktert
            if (extractedPath.includes('+')) {
                alert('Please rename the file to remove the "+" character before adding it to favorites.');
                return; // Leállítjuk a funkciót
            }
            // Csak az első sortörés cseréje, ha a kívánt szöveg megtalálható
            extractedPath = extractedPath.replace(/\n/, '/');
            existingEntries += '\n' + extractedPath; // Hozzáadjuk az új bejegyzést
            //info
            const newText = "Total commander clipboard recognized.";
            document.querySelector('.scroll-left p').textContent = newText;
        } else {
            existingEntries += '\n' + clipboardContent; // A vágólap tartalmát változtatás nélkül adjuk hozzá
            //info
            const newText = "You can use Total commander on android, long-tap on file and copy to clipboard.";
            document.querySelector('.scroll-left p').textContent = newText;
        }
        localStorage.setItem('favoritstorage', existingEntries.trim());
        document.getElementById('favoritInput').value = existingEntries.trim();
    } catch (error) {
        console.error('Hiba történt a vágólap tartalmának kiolvasása közben:', error);
    }
}





function favoritsave() {
    // A 'textarea' tartalmának kiolvasása
    let favoritContent = document.getElementById('favoritInput').value;

    // A 'favoritstorage' bejegyzés frissítése a 'localStorage'-ban
    localStorage.setItem('favoritstorage', favoritContent);

    // Felhasználó értesítése
    alert('A kedvencek mentése megtörtént.');
}





function editAndDownloadPaths() {
  let pathsJSON = localStorage.getItem('favoritstorage');
  if (!pathsJSON) {
    alert('Nincsenek elérési útvonalak a favoritstorage-ban.');
    return;
  }
  let paths = pathsJSON.split('\n').filter(line => line.trim() !== '');
  const oldStart = '/storage/000C-5B46/work new/reader translator tts joy';
  const modify = confirm(`Az elérési útvonalak "${oldStart}" résszel kezdődnek.\nSzeretnéd átírni ezt az útvonal-részt?`);

  if (modify) {
    let newStart = prompt('Add meg az új kezdő elérési útvonalat:', '/storage/emulated/0/work new/reader translator tts joy');
    if (newStart === null) {
      alert('Módosítás megszakítva, nem történt változás.');
      return;
    }
    newStart = newStart.trim();
    if (newStart.length === 0) {
      alert('Üres új útvonal, nem történt változás.');
      return;
    }
    paths = paths.map(p => {
      if (p.startsWith(oldStart)) {
        return newStart + p.slice(oldStart.length);
      }
      return p;
    });
  } else {
    alert('Nem módosítjuk az útvonalakat.');
  }
  const newPathsStr = paths.join('\n');

  // Fájlnév generálása az aktuális dátummal és idővel
  const now = new Date();
  const yyyy = now.getFullYear();
  const mm = String(now.getMonth() + 1).padStart(2, '0');
  const dd = String(now.getDate()).padStart(2, '0');
  const hh = String(now.getHours()).padStart(2, '0');
  const min = String(now.getMinutes()).padStart(2, '0');
  const ss = String(now.getSeconds()).padStart(2, '0');
  const filename = `favorit_files   ${yyyy}. ${mm}. ${dd}. ${hh}_${min}_${ss} MODIFIED   favorit_files.txt`;

  const blob = new Blob([newPathsStr], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, 100);
}





function favoritsavetofile() {
    let favoritContent = localStorage.getItem('favoritstorage');
    let blob = new Blob([favoritContent], { type: 'text/plain' });
    let url = URL.createObjectURL(blob);
    let link = document.createElement('a');
    link.href = url;
    
    let currentDate = new Date().toLocaleString();
    
    link.download = 'favorit_files   ' + currentDate + '   favorit_files.txt';
    link.click();
    URL.revokeObjectURL(url);
    
}


function favoritloadfile() {
    let input = document.createElement('input');
    input.type = 'file';
    input.accept = 'text/plain';

    input.onchange = function(event) {
        let file = event.target.files[0];
        let reader = new FileReader();

        reader.onload = function(event) {
            let content = event.target.result;
            document.getElementById('favoritInput').value = content;
            localStorage.setItem('favoritstorage', content);
            console.log('Fájl sikeresen beolvasva!');
            playany(['snd/You searched for swell ZapSplat - Download free sound effects_1744112601943.mp3'], 1);
        };

        reader.onerror = function() {
            console.error('Hiba a fájl beolvasásakor!');
        };

        reader.readAsText(file);
    };

    input.click();
}




function favoritclose() {
	
	enableKeydownListener();
	
    let favoritPopup = document.getElementById('favoritPopup');
    favoritPopup.style.display = 'none'; // Az ablak elrejtése
}

function favoritclean() {
    // Megkérdezi a felhasználót, hogy biztosan törölni akarja-e az összes tartalmat
    const confirmation = confirm("Biztosan törölni akarja az összes tartalmat?");

    // Ha a felhasználó megerősíti a törlést
    if (confirmation) {
    	favoritsavetofile();
    
        // Törli a 'favoritInput' tartalmát
        document.getElementById('favoritInput').value = '';

        // Törli a 'favoritstorage' bejegyzést a 'localStorage'-ból
        localStorage.removeItem('favoritstorage');

        // Opcióként értesítheted a felhasználót a sikeres törlésről
        alert("A tartalom sikeresen törölve lett.");
    } else {
        // Ha a felhasználó nem erősíti meg, értesítheted őt
        alert("A törlés megszakítva.");
    }
}


// togglefavorit kjknak pl 

function toggleFavoritStorage() {
    // Először ellenőrizzük és hozzuk létre a szükséges tárolókat
    if (!localStorage.getItem('favoritstorage')) {
        localStorage.setItem('favoritstorage', 'Ez az eredeti favoritstorage');
        console.log('Favoritstorage létrehozva!');
    }

    if (!localStorage.getItem('secondfavoritstorage')) {
        localStorage.setItem('secondfavoritstorage', 'Ez a második favoritstorage');
        console.log('Secondfavoritstorage létrehozva!');
    }

    // Most már biztosan léteznek a tárolók, így cserélhetjük az adatokat
    console.log('Előtte:');
    console.log('Favoritstorage:', localStorage.getItem('favoritstorage'));
    console.log('Secondfavoritstorage:', localStorage.getItem('secondfavoritstorage'));

    let temp = localStorage.getItem('favoritstorage');
    localStorage.setItem('favoritstorage', localStorage.getItem('secondfavoritstorage'));
    localStorage.setItem('secondfavoritstorage', temp);

    console.log('Utána:');
    console.log('Favoritstorage:', localStorage.getItem('favoritstorage'));
    console.log('Secondfavoritstorage:', localStorage.getItem('secondfavoritstorage'));

    console.log('Adatok sikeresen cserélve!');
    startTypingAnimation('paragraphId', 'divId', 'Adatok sikeresen cserélve!');
      
      fadeInOutTextBlink('Favorit adatok sikeresen cserélve', 40, 'rgba(220, 130, 200, 0.91)', 35, 3); // 3-ször villog
      
    playany(['snd/You searched for swell ZapSplat - Download free sound effects_1744112601943.mp3'], 1);
}








function marquecleaned(cleanInputValue) {
    const newText = cleanInputValue + " cleaned";
    document.querySelector('.scroll-left p').textContent = newText;
}




function confirmClean() {
    let cleanInputValue = document.getElementById('cleanInput').value;
    
    // Karakterek eltávolítása az origcontent változóból
    origcontent = origcontent.split(cleanInputValue).join('');
    
    marquecleaned(cleanInputValue);
    
    // Letöltés a blob formájában
    let blob = new Blob([origcontent], {type: 'text/plain'});
    let url = URL.createObjectURL(blob);
    let a = document.createElement('a');
    a.href = url;
    a.download = 'output.txt';
    a.click();
    URL.revokeObjectURL(url);
}




//A Number of Matches: ' + count; legyen nagyobb betűkkel.

document.getElementById('searchInput').addEventListener('input', function() {
    let searchInputValue = this.value;
    let count = countOccurrences(origcontent, searchInputValue);
    
    let searchPopup = document.getElementById('searchPopup');
    let resultContainer = document.createElement('div');
    resultContainer.textContent = 'Number of Matches: ' + count;
    resultContainer.style.fontSize = '12px'; // Betűméret növelése
    resultContainer.style.fontWeight = 'bold'; // Félkövér betűstílus
    
    let existingResult = document.getElementById('searchResult');
    
    if (existingResult) {
        existingResult.textContent = 'Number of Matches: ' + count;
        existingResult.style.fontSize = '12px'; // Betűméret növelése
        existingResult.style.fontWeight = 'bold'; // Félkövér betűstílus
    } else {
        resultContainer.id = 'searchResult';
        searchPopup.appendChild(resultContainer);
    }
});


function countOccurrences(text, searchTerm) {
    let regex = new RegExp(searchTerm, 'gi');
    let matches = text.match(regex);
    return matches ? matches.length : 0;
}



//    --------    scroll marque infotext

function textMarquee(newText) {
  document.querySelector('.scroll-left p').textContent = newText; // Beállítjuk a szöveget a scroll text mezőbe
}

// Használata:
//   textMarquee('Ide írhatja a megjelenítendő szöveget');



function textmarquebookname() {
    const newText = bookname; // A megjelenítendő szöveg
    document.querySelector('.scroll-left p').textContent = newText; // Beállítjuk a szöveget a scroll text mezőbe
}

function textmarquecurrenttime() {
    const currentDate = new Date();
    const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', hour: 'numeric', minute: 'numeric' };
    const formattedDate = currentDate.toLocaleDateString('hu-HU', options);
    document.querySelector('.scroll-left p').textContent = formattedDate;
}




// ------- -------- --------
// AI recognize Language


	
function AIrecognizelanguageSmall(origcontent) {
	
	//alert("abban az esetben, ha az és és a the szavak száma is 1-3 darabszám volna mindkettőből nagyon kevés vagy teljesen nulla akkor ez a funkció álljon le és hívja meg az AIrecognizelanguageSmall origcontent funkciót. ");
	console.log("In case the number of 'and' and 'the' words is between 1-3 for both, very few or completely zero, then this function should stop and call the AIrecognizelanguageSmall origcontent function.")
   
    let hungarianlanguage = 0;
    let englishlanguage = 0;
    let magyarEkezetesBetukSzama = 0;
    let esSzavakSzama = 0;
    let theSzavakSzama = 0;
    
    // Magyar ékezetes betűk és "és" szavak számolása
    for (let i = 0; i < origcontent.length; i++) {
        let currentChar = origcontent[i];
        if (/[áéíóöőúüűÁÉÍÓÖŐÚÜŰ]/.test(currentChar)) {
            magyarEkezetesBetukSzama++;
        }
    }
    
    // "és" szavak számolása
    let szavak = origcontent.split(" ");
    for (let j = 0; j < szavak.length; j++) {
        if (szavak[j] === "és") {
            esSzavakSzama++;
        }
    }
    
    // "the" szavak számolása
    for (let j = 0; j < szavak.length; j++) {
        if (szavak[j] === "the") {
            theSzavakSzama++;
        }
    }
    
    //alert(esSzavakSzama + " és, " + theSzavakSzama + " the ");
   // alert("Az 'es' szó " + esSzavakSzama + " alkalommal, a 'the' szó " + theSzavakSzama + " alkalommal szerepel a szövegben.");
    console.log("Az 'es' szó " + esSzavakSzama + " alkalommal, a 'the' szó " + theSzavakSzama + " alkalommal szerepel a szövegben.");

    // Ha több, mint 2 magyar ékezetes betű van az origcontent-ben, növeljük a hungarianlanguage változót
    if (magyarEkezetesBetukSzama > 2) {
        hungarianlanguage += 2;
    }
    console.log("ékezetes betűk száma: " + magyarEkezetesBetukSzama);
    
    // Ha több, mint 0 "és" szó van az origcontent-ben, növeljük a hungarianlanguage változót
    if (esSzavakSzama > 0) {
        hungarianlanguage += 5;
    }
    
    // Ha több, mint 0 "the" szó van az origcontent-ben, növeljük az englishlanguage változót
    if (theSzavakSzama > 0) {
        englishlanguage += 5;
    }
    
    console.log(hungarianlanguage);
    console.log(englishlanguage);
    
    winner = hungarianlanguage > englishlanguage ? 'hungarianlanguage' : 'englishlanguage';
    
    console.log(winner);
    return { hungarian: hungarianlanguage, english: englishlanguage, winner: winner };
}

// Példa hívás a függvényre
//let result = AIrecognizelanguage("Az alma és a körte");
//console.log(result);




function AIrecognizelanguage(origcontent) {
    let hungarianlanguage = 0;
    let englishlanguage = 0;
    let esSzavakSzama = 0;
    let theSzavakSzama = 0;
    winner = "";

    // "és" és "the" szavak számolása
    let szavak = origcontent.split(/\s+/);
    for (let i = 0; i < szavak.length; i++) {
        let szo = szavak[i].toLowerCase();
        if (szo === "és") {
            esSzavakSzama++;
        } else if (szo === "the") {
            theSzavakSzama++;
        }
    }

    // Ellenőrizzük, hogy az "és" és "the" szavak száma 1 és 3 között van-e
    if ((esSzavakSzama >= 1 && esSzavakSzama <= 3) && (theSzavakSzama >= 1 && theSzavakSzama <= 3)) {
        return AIrecognizelanguageSmall(origcontent);
    }

    if (esSzavakSzama === 0 && theSzavakSzama === 0) {
    return AIrecognizelanguageSmall(origcontent);
    }


    // Nyelvi pontok növelése
    hungarianlanguage += esSzavakSzama * 0.5;
    englishlanguage += theSzavakSzama * 0.5;

    // Százalékos részesedés kiszámítása
    let totalLanguagePoints = hungarianlanguage + englishlanguage;
    let hungarianPercent = (hungarianlanguage / totalLanguagePoints) * 100;
    let englishPercent = (englishlanguage / totalLanguagePoints) * 100;

    console.log(`Hungarian: ${hungarianPercent.toFixed(2)}%, English: ${englishPercent.toFixed(2)}%`);

    // Győztes kiválasztása
    winner = hungarianPercent > englishPercent ? "hungarianlanguage" : "englishlanguage";

    console.log(`The winner is: ${winner}`);
   // alert(`Winner: ${winner}\n"és" szavak száma: ${esSzavakSzama}\n"the" szavak száma: ${theSzavakSzama}`);
   console.log(`Winner: ${winner}\n"és" szavak száma: ${esSzavakSzama}\n"the" szavak száma: ${theSzavakSzama}`);

}

// Assuming AIrecognizelanguageSmall function exists and is implemented correctly

// AIrecognizelanguageSmall function logic...

// Example call to the function
// let result = AIrecognizelanguage("Az alma és a körte");
// console.log(result);

// End of the function







function supervision() {
	
	//log naplózás
	marsSave(bookname);

	
	//random colorful

// 50% eséllyel váltás a színek között
const randomNumberColorful = Math.floor(Math.random() * 2) + 1;
if (randomNumberColorful === 1) {
    toggleColor();
}
	
	playoscilla(519, 100); // F4
playoscilla(392, 100); // G4
playoscilla(349, 150); // F4
	
		//inspect bookmarks
	//bookmarkrapidmaintance();
	
	
	
	favpopuploadForJoy1 = 0;  // joypad2-nek loadoljon ezután
	jumpcount = 1;  // 10-es ugrásnak
    let existingPopup = document.getElementById('supervisionlanguage');
    if (existingPopup) {
        existingPopup.remove(); // Eltávolítjuk az előző popup ablakot, ha létezik
    }

    let supervisionPopup = document.createElement('div');
    supervisionPopup.id = 'supervisionlanguage';
    supervisionPopup.style.display = 'block';
    supervisionPopup.style.position = 'fixed';
    supervisionPopup.style.zIndex = '9999'; // Nagyobb z-index érték
    supervisionPopup.style.top = '40%'; // Felső részre pozícionálás
    supervisionPopup.style.left = '50%';
    supervisionPopup.style.transform = 'translateX(-50%)';
    supervisionPopup.style.width = '60%'; // Szélesség beállítása
    supervisionPopup.style.maxWidth = '500px'; // Maximális szélesség korlátozása
    supervisionPopup.style.padding = '20px';
    supervisionPopup.style.borderRadius = '10px';
    supervisionPopup.style.backgroundColor = 'rgba(255, 155, 55, 0.8)';
    supervisionPopup.style.boxShadow = '0 0 50px rgba(220, 0, 0, 0.9)';
    document.body.appendChild(supervisionPopup);

    let supervisionTitle = document.createElement('h2'); // Felirat hozzáadása
    supervisionTitle.textContent = 'Auto AI';
    supervisionTitle.style.textAlign = 'center';
    supervisionPopup.appendChild(supervisionTitle);

    let supervisionButton = document.createElement('button');
    supervisionButton.textContent = 'Supervision';
    supervisionButton.onclick = function() {
        document.getElementById('supervisionlanguage').style.display = 'none';
        languageoptions();
    };
    supervisionPopup.appendChild(supervisionButton);

    let automaticSetupTimer = setTimeout(function() {
        let popupToRemove = document.getElementById('supervisionlanguage');
        if (popupToRemove) {
            popupToRemove.remove(); // Az időzítő lejárta után eltávolítjuk az ablakot
        }
        automaticlanguagesetup();
        // typinghang totalauto miatt mostmár szólhat
        firstdomloadforTyping = 0;
        
    //    itt jól működik a hud osd fadeout!
        setOpacity(0.9);
    }, 500);

    supervisionButton.addEventListener('click', function() {
        clearTimeout(automaticSetupTimer); // Megakadályozza az automaticlanguagesetup() futtatását a gomb lenyomása után
    });
    
}
        // Call the supervision function or trigger it based on your requirements
        //supervision();
        
        
        
        
        
//let winner; // már deklaráltuk Globális scope-ban

function automaticlanguagesetup() {
    
  //alert("automaticlanguagesetup");
    
    let hungarianlanguage = 0;
    let englishlanguage = 0;
    let magyarEkezetesBetukSzama = 0;
    let esSzavakSzama = 0;
    let theSzavakSzama = 0;
    
    // Magyar ékezetes betűk és "és" szavak számolása
    for (let i = 0; i < origcontent.length; i++) {
        let currentChar = origcontent[i];
        if (/[áéíóöőúüűÁÉÍÓÖŐÚÜŰ]/.test(currentChar)) {
            magyarEkezetesBetukSzama++;
        }
    }
    
    // "és" szavak számolása
    let szavak = origcontent.split(" ");
    for (let j = 0; j < szavak.length; j++) {
        if (szavak[j] === "és") {
            esSzavakSzama++;
        }
    }
    
    // "the" szavak számolása
    for (let j = 0; j < szavak.length; j++) {
        if (szavak[j] === "the") {
            theSzavakSzama++;
        }
    }
    
    // Ha több, mint 2 magyar ékezetes betű van az origcontent-ben, növeljük a hungarianlanguage változót
    if (magyarEkezetesBetukSzama > 2) {
        hungarianlanguage += 2;
    }
    
    // Ha több, mint 0 "és" szó van az origcontent-ben, növeljük a hungarianlanguage változót
    if (esSzavakSzama > 0) {
        hungarianlanguage += 5;
    }
    
    // Ha több, mint 0 "the" szó van az origcontent-ben, növeljük az englishlanguage változót
    if (theSzavakSzama > 0) {
        englishlanguage += 5;
    }
    
    console.log(hungarianlanguage);
    console.log(englishlanguage);
    
   

if (hungarianlanguage > englishlanguage) {
  winner = "hu";
  marqueaihuneng();
   if (Math.random() < 0.5) {
       //majd ide dom-os audiot
  } else {
       //majd ide dom-os audiot
  }
} else if (hungarianlanguage < englishlanguage) {
  winner = "en";
  marqueaienghun();
   if (Math.random() < 0.5) {
    //majd ide dom-os audiot
  } else {
       //majd ide dom-os audiot
  }

 
}

      // Hívjuk meg a funkciót a TheSlider pozicionálására a második mondatra
//positionSliderToSecondSentence();

     //bookmarkreadandsetup();
     //ez itt működik 
bookmarkload(bookname);

    // Auto gombszimuláció Egy lépés vissza az elsőmondatra, hogy fel is olvassa
    //one();
    
    //auto bezárja az options input ablakot a optionsApopupButtonFunctionból
    popup.style.display = 'none';
    optionsopen = 0;
    //alert(winner);
    
}

  // tűnjön el a marque a scroll

function marqueaienghun() {
    const newText = "System set from English to Hungarian";
    const pElement = document.querySelector('.scroll-left p');
    pElement.style.opacity = "1";
    pElement.textContent = newText;

    setTimeout(() => {
        pElement.style.opacity = "0";
    }, 40000);
}

function marqueaihuneng() {
    const newText = "System set from Hungarian to English";
    const pElement = document.querySelector('.scroll-left p');
    pElement.style.opacity = "1";
    pElement.textContent = newText;

    setTimeout(() => {
        pElement.style.opacity = "0";
    }, 40000);
}

function marqueaiebookname() {
    const newText = bookname;
    const pElement = document.querySelector('.scroll-left p');
    pElement.style.opacity = "1";
    pElement.textContent = newText;

    setTimeout(() => {
        pElement.style.opacity = "0";
    }, 60000);
}




	
function languageoptions() {
	
alert("options");
}





// TheSlider pozicionálására a második mondatra majd szimulált 1esgomb elsőre
function positionSliderToSecondSentence() {
    currentsentencenumber = 2; // A második mondat sorszáma legyen 2
    let slider = document.getElementById('TheSlider');
    let maxSliderValue = parseInt(slider.max);
    let sliderValue = Math.floor((currentsentencenumber - 1) / allsentencenumber * maxSliderValue);
    slider.value = sliderValue;

    // Frissítjük a számlálót az új mondat sorszámával
    let counter = document.getElementById('counter');
    counter.textContent = currentsentencenumber;

    // Megjelenítjük a második mondatot a selectedtextblock-ban
    let sentences = origcontent.match(/[^.!?]+(?:\.|!|\?)(?=\s|$)/g);
    if (sentences && sentences.length > 1) {
        let secondSentence = sentences[1].trim();
        document.getElementById('selectedtextblock').innerText = secondSentence;
    }

    // Megjelenítjük az első három mondatot a contextblock-ban
    if (sentences && sentences.length > 0) {
        let contextText = sentences.slice(0, 3).join(' '); // Az első három mondatot jelenítjük meg
        document.getElementById('contextblock').innerText = contextText;
    }
}

//paste
function pasteFromClipboard() {
	document.getElementById("bigInput").focus();
	
            navigator.clipboard.readText()
            
                .then(text => {
                    document.getElementById("bigInput").value = text;
                    //console.log('Text pasted from clipboard: ' + text);
                    
                    /* ez most nem kell ide
                    // Create a popup div
                    var popup = document.createElement("div");
                    // Set the popup content to the clipboard content
                    popup.textContent = "Pasted from clipboard: " + text;
                    // Style the popup
                    popup.style.position = "fixed";
                    popup.style.top = "20px";
                    popup.style.left = "20px";
                    popup.style.padding = "10px";
                    popup.style.backgroundColor = "lightblue";
                    popup.style.border = "1px solid blue";
                    popup.style.borderRadius = "5px";
                    // Append the popup to the body
                    document.body.appendChild(popup);
                    // Set a timeout to remove the popup after 2 seconds
                    setTimeout(function() {
                        popup.remove();
                    }, 2000);
                    */
                    
                })
                .catch(err => {
                    console.error('Failed to paste text: ', err);
                });
                
                
                
                
                
                
                
        }

/* fade in text */
let maininfo=(22+2);

function changeText() { const wordContainer = document.getElementById("wordContainer"); wordContainer.innerHTML = ""; const words = [ maininfo, "---te barom elmész a büdös picsába---" ]; for (let i = 1; i <= 18; i++) { const wordElement = document.createElement("span"); wordElement.id = `word${i}`; wordElement.textContent = words[i - 1]; wordElement.style.animation = `fade-in 0.8s ${0.1 + (i - 1) * 0.1}s forwards cubic-bezier(0.11, 0, 0.5, 0)`; wordElement.style.filter = "blur(24px)"; wordElement.style.opacity = "0"; wordContainer.appendChild(wordElement); } } 



function fadebookname() {
    const wordContainer = document.getElementById("wordContainer");
    wordContainer.innerHTML = "";
    const words = [bookname]; // Feltételezve, hogy a bookname változó máshol definiált

    for (let i = 1; i <= 18; i++) {
        const wordElement = document.createElement("span");
        wordElement.id = `word${i}`;
        wordElement.textContent = words[i - 1];

        // Betűméret beállítása
        wordElement.style.fontSize = "28px";

        // Animáció beállítása
        wordElement.style.animation = `fade-in 0.8s ${0.1 + (i - 1) * 0.1}s forwards cubic-bezier(0.11, 0, 0.5, 0)`;

        // Kezdeti stílusok
        wordElement.style.filter = "blur(24px)";
        wordElement.style.opacity = "1";
        wordElement.style.color = "rgba(255, 247, 0, 0.9)";

        wordContainer.appendChild(wordElement);
    }

    // 8 másodperc múlva visszaállítjuk a stílusokat
    setTimeout(() => {
        for (let i = 1; i <= 18; i++) {
            const wordElement = document.getElementById(`word${i}`);
            if (wordElement) {
                wordElement.style.color = "";
                wordElement.style.filter = "blur(0)";
                wordElement.style.opacity = "1";
            }
        }
    }, 8000);
}


/* history localstorage növelése ha változik a bookname var evenlitener*/
let originalBookname = bookname;

Object.defineProperty(window, "bookname", {
  set: function(newValue) {
    if (newValue !== originalBookname) {
      originalBookname = newValue;

      // Először kiolvassuk a jelenlegi localStorage tartalmát
let historyvar = JSON.parse(localStorage.getItem('history')) || [];

// Majd hozzáadjuk az új könyvcímet
let newBookTitle = bookname + '\n' + new Date().toLocaleDateString();
historyvar.push(newBookTitle);

// Végül frissítjük a localStorage-t az új tartalommal
localStorage.setItem('history', JSON.stringify(historyvar));
    }
  },
  get: function() {
    return originalBookname;
  }
})

function showHistory() {
  // Először kiolvassuk a jelenlegi localStorage tartalmát
let historyvar = JSON.parse(localStorage.getItem('history')) || [];
// Majd kiírjuk az alert ablakban
alert(historyvar.join('\n'));
}

function deleteHistory() {
  // Töröljük a 'history' bejegyzést a localStorage-ból
  localStorage.removeItem('history');
  // És üres tömböt mentünk el helyette
  localStorage.setItem('history', JSON.stringify([]));
  // A törlés után értesítjük a felhasználót
  alert('A történelem sikeresen törölve!');
}


// fadeintext bookname fordítása 

//Cannot read properties of null (reading 'map')

//const wordContainer = document.getElementById("wordContainer");
//const word3 = "read";




// Script to convert the content of word3 to lowercase
function titletranslate() {
	//const word3 = bookname;
    const word3 = document.getElementById("wordContainer").innerText;
    const lowercaseWord3 = word3.toLowerCase(); // Convert word3 to lowercase

    const titlefortranslate = lowercaseWord3;
    var textToRead2 = titlefortranslate;
    var lang2 = 'en-ENG';
    
    var audio2 = new SpeechSynthesisUtterance(textToRead2);
    audio2.lang = lang2;
    audio2.rate = 0.8;
    audio2.volume = 1;
    audio2.pitch = 1.0;
    speechSynthesis.speak(audio2);

    const inputText = titlefortranslate;
    let inputLanguage = "en";
    let outputLanguage = "hu";

    if (winner === "hu") {
        inputLanguage = "en";
        outputLanguage = "hu";
    }

    const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=${inputLanguage}&tl=${outputLanguage}&dt=t&q=${encodeURI(inputText)}`;

    fetch(url)
        .then((response) => response.json())
        .then((json) => {
            szoforditas = json[0].map((item) => item[0]).join("");

            var lang2 = 'hu-HUN';
            if (winner === "hu") {
                lang2 = 'hu-HUN';
            }

            var audio2 = new SpeechSynthesisUtterance(szoforditas);
            audio2.lang = lang2;
            audio2.rate = 0.8;
            audio2.volume = 1;
            audio2.pitch = 1.0;
            speechSynthesis.speak(audio2);
        })
        .catch((error) => {
            console.error(error);
        });
}





/* bookmarkrapid localstorage változtatása, létrehozása, törlése, kiolvasása, ha változik a bookname var evenlistener*/


document.getElementById('counter').addEventListener('DOMSubtreeModified', function() {
  if (this.textContent) {
    // Do something when the textContent changes
    counterlistener = this.textContent;
    //alert(counterlistener);
    //console.log('The textContent of the counter element has changed to:', this.textContent);
    
    bookmarkedit();
    
  }
});




function checkcreatebookmarkrapid() {
  // Check if "bookmarkrapid" exists in local storage
  if (localStorage.getItem("bookmarkrapid")) {
    bookmarkrapidvar = localStorage.getItem("bookmarkrapid");
    // Display the bookmarkrapidvar content
    //console.log(bookmarkrapidvar);
  } else {
    //alert("first time bookmark creating");
   // fadeInOutText('first time bookmark creating and onscreenjoypad active', 34, 'rgba(20, 0, 200, 1)', 40);
    
    fadeInOutTextBlink('first time bookmark creating and onscreenjoypad active', 26, 'rgba(220, 100, 0, 1)', 73, 15);
    fadeInOutTextBlink('Főpanel ablak a jobbfelső sarokban', 28, 'rgba(20, 220, 200, 1)', 85, 15);
    
    document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('toggleGombok').click();
});

    
    
      
      
    
    bookname = "info start.txt";
    counterlistener = 1;
    // Create "bookmarkrapid" in local storage with a newline character after the counterlistener value
    localStorage.setItem("bookmarkrapid", bookname + "\n" + counterlistener + "\n");
    // Update the bookmarkrapidvar variable
    bookmarkrapidvar = localStorage.getItem("bookmarkrapid");
    // Display the bookmarkrapidvar content
    console.log(bookmarkrapidvar);
  }
}

checkcreatebookmarkrapid();


//kiszedi a bookmarkrapid bejegyzést

function deletebookmarkrapid() {
	alert("deletebookmarkrapid");
  localStorage.removeItem("bookmarkrapid");
}


//A bookmarkfrissítés A lényeg 

function bookmarkedit() {
  // Load bookmarkrapidvar from local storage
  var bookmarkrapidvar = localStorage.getItem("bookmarkrapid");

  // Check if bookname exists in bookmarkrapidvar
  if (bookmarkrapidvar.includes(bookname)) {
    // Extract the existing counterlistener value
    var regex = new RegExp(bookname + "\n(\\d+)");
    var existingCounter = bookmarkrapidvar.match(regex)[1];

    // Replace the line with the bookname with the updated counterlistener
    bookmarkrapidvar = bookmarkrapidvar.replace(
      regex,
      bookname + "\n" + counterlistener
    );
  } else {
    // Add a new line with the bookname and counterlistener
    bookmarkrapidvar += bookname + "\n" + counterlistener + "\n";
  }

  // Save the updated bookmarkrapidvar to local storage
  localStorage.setItem("bookmarkrapid", bookmarkrapidvar);
}


function showallbookmarkrapid() {
  // Load bookmarkrapidvar from local storage
  var bookmarkrapidvar = localStorage.getItem("bookmarkrapid");

  // Display the bookmarkrapidvar content
  console.log(bookmarkrapidvar);
}



// nem szükséges minden paste szöveget tárolni a bookmarkban ezért törlés, ha van benne " clipboard"
/*
Javascript folytatása, bővítése.
Letölti a local storage bejegyzését a bookmarkrapidvar-ba.
Nézze át a bookmarkrapidvar minden sorát, és szedje ki azt a sort, amelyik tartalmazza a " clipboard" szót, ezután szedje ki az egyel alatta levő sort is aminek a tartalma mindegy hogy micsoda. Előbbi szabályokat figyelembe véve nézze át az egész bookmarrapidvar-t.
Vissztölti a bookmarkrapidvar-t a local storage-ba.
A console.log-ba is beleírja a törölt sorokat, de csak akkor ha valóban törlésre került egy sor.
*/

function deleteBooknameClipboardBookmarkRapid() {
  // Load bookmarkrapidvar from local storage
  var bookmarkrapidvar = localStorage.getItem("bookmarkrapid");

  // Check each line and remove the ones containing "clipboard" and the line after it
  var lines = bookmarkrapidvar.split('\n');
  var modifiedLines = [];
  var removedLines = []; // Tárolja az eltávolított sorokat

  for (var i = 0; i < lines.length; i++) {
    if (lines[i].includes('clipboard')) {
      removedLines.push(lines[i]); // Naplózza az eltávolított sort
      if (lines[i + 1]) {
        removedLines.push(lines[i + 1]); // Naplózza a következő sort is
      }
      i++; // Skip the next line as well
    } else {
      modifiedLines.push(lines[i]);
    }
  }

  // Join the modified lines back into a single string
  var modifiedContent = modifiedLines.join('\n');

  // Log the removed lines if any were removed
  if (removedLines.length > 0) {
    console.log('Removed lines:', removedLines.join('\n'));
  }

  // Save the modified content back to local storage
  localStorage.setItem("bookmarkrapid", modifiedContent);
}

// Call the function to perform the operation
deleteBooknameClipboardBookmarkRapid();



function saveToFileBookmarks() {
  // Load the data from local storage
  var bookmarkrapidvar = localStorage.getItem("bookmarkrapid");

  // Create a Blob with the data
  var blob = new Blob([bookmarkrapidvar], { type: 'text/plain' });

  // Create a link element
  var downloadLink = document.createElement("a");

  // Set the download attribute with the file name
  downloadLink.download = "readertranslator save bookmarks.txt";

  // Create a URL for the blob
  downloadLink.href = window.URL.createObjectURL(blob);

  // Append the link to the body
  document.body.appendChild(downloadLink);

  // Programmatically click the link to trigger the download
  downloadLink.click();

  // Remove the link from the body
  document.body.removeChild(downloadLink);
}

// Call the function to perform the download
//saveToFileBookmarks();


function loadFromFileBookmarks() {
  // Create an input element of type file
  var fileInput = document.createElement('input');
  fileInput.type = 'file';
  fileInput.accept = '.txt'; // Accept only .txt files

  // Simulate a click on the file input to open the file dialog
  fileInput.click();

  // Listen for changes on the file input (when a file is selected)
  fileInput.addEventListener('change', function(event) {
    var file = event.target.files[0];

    // Check if the file name is 'readertranslator save bookmarks.txt'
    if (file.name === 'readertranslator save bookmarks.txt') {
      var reader = new FileReader();
      
      // Read the file content when the file is loaded
      reader.onload = function(e) {
        var content = e.target.result;

        // Save the content to local storage
        localStorage.setItem('bookmarkrapid', content);
        console.log('Bookmarks loaded successfully from file.');
        startTypingAnimation('paragraphId', 'divId', 'Bookmarks loaded successfully from file.');
      };

      // Read the text file
      reader.readAsText(file);
    } else {
      console.error('Invalid file name. Please select the correct file.');
      startTypingAnimation('paragraphId', 'divId', 'Invalid file name. Please select the correct file.');
    }
  });
}

// Call the function to perform the operation
//loadFromFileBookmarks();



// az elcseszett bookmarkrapid visszaállítása és ellenőrzése




function bookmarkrapidmaintance() {
    let inspect = localStorage.getItem('bookmarkrapid');
    let oldbookmarkrapid = localStorage.getItem('oldbookmarkrapid');

    if (inspect) {
        let lines = inspect.split('\n');
        let isFlawless = true; // Initialize a flag to check if the core is flawless
        for (let i = 0; i < lines.length; i++) {
            if (i % 2 === 0 && i !== lines.length - 1) { // Checking odd lines (1st, 3rd, 5th...) except the last one
                   // csak ezeket a végződéseket engedélyezett beleírni    .txt és clipboard és srtTotxt
           //  if (!lines[i].trim().endsWith('.txt')) {
           	
           
            	if (!lines[i].trim().endsWith('.txt') && !lines[i].trim().endsWith('clipboard') && !lines[i].trim().endsWith('srtTotxt')) {
    
  
                    isFlawless = false;
                   // alert('A bokkmarkrapid bejegyzés hibás a(z) ' + (i + 1) + '. sorban!');
                    
                    startTypingAnimation('paragraphId', 'divId', 'A bokkmarkrapid bejegyzés hibás a(z) ' + (i + 1) + '. sorban!');
                    
                    localStorage.removeItem('bookmarkrapid');
                    if (oldbookmarkrapid) {
                        localStorage.setItem('bookmarkrapid', oldbookmarkrapid);
                        startTypingAnimation('paragraphId', 'divId', 'oldbookmark entry successful restore');
                        startTypingAnimation('paragraphId', 'divId', 'system reset');
                        stopSpeaking(); 
                        
                        setTimeout(function() {
                        playrefreshSound();
                        // Az oldal teljes újratöltése
                    }, 2000);
                        
                      
                    } else {
                        localStorage.setItem('oldbookmarkrapid', '');
                        console.log('Az oldbookmarkrapid bejegyzés hiánya miatt a visszaállítás nem lehetséges. Bookmark törölve.');
                        startTypingAnimation('paragraphId', 'divId', 'system reset');
                        stopSpeaking(); 
                        playrefreshSound();
                        // Az oldal teljes újratöltése
                        
                    }
                    break;
                }
            }
        }
        if (isFlawless) {
            //alert('flawless core');
            //startTypingAnimation('paragraphId', 'divId', 'flawless core');
            console.log('flawless core');
            localStorage.setItem('oldbookmarkrapid', inspect);
        }
    } else {
        alert('Nincs mentett bokkmarkrapid bejegyzés.');
    }
}
  







function bookmarkreadandsetup() {
  // Load bookmarkrapidvar from local storage
  var bookmarkrapidvar = localStorage.getItem("bookmarkrapid");

  // Check if bookname exists in bookmarkrapidvar
  if (bookmarkrapidvar.includes(bookname)) {
    // Extract the line under the bookname variable
    var regex = new RegExp(bookname + "\n(.*?)\n");
    var setbookmarksentence = bookmarkrapidvar.match(regex)[1];

    // Use the extracted data as needed
    console.log("Bookmark sentence: " + setbookmarksentence);

    //slider és textek a bookmarknak megfelelően
    currentsentencenumber = setbookmarksentence; // A második mondat sorszáma legyen bookmarksorszám
    let slider = document.getElementById('TheSlider');
    let maxSliderValue = parseInt(slider.max);
    let sliderValue = Math.floor((currentsentencenumber - 1) / allsentencenumber * maxSliderValue);
    slider.value = sliderValue;

    // Frissítjük a számlálót az új mondat sorszámával
    let counter = document.getElementById('counter');
    counter.textContent = currentsentencenumber;

    // Megjelenítjük a bookmark-hoz tartozó mondatot a selectedtextblock-ban
    
    //console.log(origcontent);
    //alert();
    let sentences = origcontent.match(/[^.!?]+(?:\.|!|\?)(?=\s|$)/g);
    if (sentences && sentences.length > setbookmarksentence - 1) {
        let selectedSentence = sentences[setbookmarksentence - 1].trim();
        document.getElementById('selectedtextblock').innerText = selectedSentence;
    }

    // Megjelenítjük a bookmark-hoz tartozó mondatot a contextblock-ban
    let contextSentences = origcontent.match(/[^.!?]+(?:\.|!|\?)(?=\s|$)/g);
    if (contextSentences && contextSentences.length > setbookmarksentence - 1) {
        let selectedSentence = contextSentences[setbookmarksentence - 1].trim();
        document.getElementById('selectedtextblock').innerText = selectedSentence;

        // Előző és következő 2 mondat hozzáadása a contextblock-hoz
        let contextBlockContent = "";
        if (setbookmarksentence > 1) {
            contextBlockContent += contextSentences[setbookmarksentence - 3].trim() + " ";
        }
        contextBlockContent += selectedSentence + " ";
        if (setbookmarksentence < contextSentences.length) {
            contextBlockContent += contextSentences[setbookmarksentence].trim();
        }
        document.getElementById('contextblock').innerText = contextBlockContent;
    }

  } else {
    console.log("Bookname not found in bookmarkrapidvar, ezért beleírjuk");

    // Add a new line for the bookname and the first sentence
    bookmarkrapidvar += bookname + "\n1\n";

    // Save the updated bookmarkrapidvar to local storage
    localStorage.setItem("bookmarkrapid", bookmarkrapidvar);

    // Update the slider and text elements with the first sentence
    currentsentencenumber = 1;
    let slider = document.getElementById('TheSlider');
    let maxSliderValue = parseInt(slider.max);
    let sliderValue = Math.floor((currentsentencenumber - 1) / allsentencenumber * maxSliderValue);
    slider.value = sliderValue;

    let counter = document.getElementById('counter');
    counter.textContent = currentsentencenumber;

    let sentences = origcontent.match(/[^.!?]+(?:\.|!|\?)(?=\s|$)/g);
    if (sentences && sentences.length > currentsentencenumber - 1) {
      //console.log("Selected sentence: " + sentences[currentsentencenumber - 1].trim());
      document.getElementById('selectedtextblock').innerText = sentences[currentsentencenumber - 1].trim();
    }

    let contextSentences = origcontent.match(/[^.!?]+(?:\.|!|\?)(?=\s|$)/g);
    if (contextSentences && contextSentences.length > currentsentencenumber - 1) {
     // console.log("Context sentences: " + contextSentences);
      let selectedSentence = contextSentences[currentsentencenumber - 1].trim();
      document.getElementById('selectedtextblock').innerText = selectedSentence;

      let contextBlockContent = "";
      if (currentsentencenumber > 1) {
          contextBlockContent += contextSentences[currentsentencenumber - 3].trim() + " ";
      }
      contextBlockContent += selectedSentence + " ";
      if (currentsentencenumber < contextSentences.length) {
          contextBlockContent += contextSentences[currentsentencenumber].trim();
      }
      document.getElementById('contextblock').innerText = contextBlockContent;
    }
  }
}


// ----------    infogomb
function infogomb() {
	
	
    if (!navigator.onLine) {
        alert("Nincs internet kapcsolat!");
        nonetinfogomb();
        return;
    }

    let bitcoinPrice;

    fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd')
    .then(response => response.json())
    .then(data => {
        bitcoinPrice = data.bitcoin.usd;
        // eddig a cn buttonra lényeg, innen felolvas
        
        var textToRead2 = bitcoinPrice;
        var lang2 = 'hu-HUN';
        var audio2 = new SpeechSynthesisUtterance(textToRead2);
        audio2.lang = lang2;
        audio2.rate = 0.8;
        audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
        audio2.pitch = 1.0;
        speechSynthesis.speak(audio2);
        
        // hány %
        let readpercentage = Math.round((currentsentencenumber / allsentencenumber) * 100);
        readpercentage = (readpercentage + " percent");
        console.log(readpercentage); 
        var textToRead2 = readpercentage;
        var lang2 = 'en-ENG';
        var audio2 = new SpeechSynthesisUtterance(textToRead2);
        audio2.lang = lang2;
        audio2.rate = 0.8;
        audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
        audio2.pitch = 1.0;
        speechSynthesis.speak(audio2);
    
        // Kívánatos és nemkívánatos speciális karakterek
        const desiredSpecialChars = ['?', '!', '.', ',', '\n'];
        const undesiredSpecialChars = ['+', '-', '_', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];
    
        let undesiredCharCount = 0;
        
        // Számolja meg a nemkívánatos speciális karaktereket
        for (let i = 0; i < bookname.length; i++) {
            if (undesiredSpecialChars.includes(bookname[i])) {
                undesiredCharCount++;
            }
        }
        
        // Számolja ki az eredeti tartalom 0.015%-át
        const threshold = bookname.length * 0.00015;
        
        // Értesítse a felhasználót, ha a limitet túllépték
        if (undesiredCharCount > threshold) {
            console.log('Figyelem: A nemkívánatos speciális karakterek száma meghaladja a bookname 0.015%-át.' + bookname);
            const filteredContent = filterSpecialCharacters(bookname);
            bookname = filteredContent; // replace the original content with
        } else {
            console.log('A bookname tartalom megfelelő.');
        }
        
        var textToRead2 = bookname;
        var lang = 'en-ENG';
        if (winner === "hu") {
            var lang = 'hu-HUN';
        }
        var lang2 = lang;
        var audio2 = new SpeechSynthesisUtterance(textToRead2);
        audio2.lang = lang2;
        audio2.rate = 0.8;
        audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
        audio2.pitch = 1.0;
        speechSynthesis.speak(audio2);
        
        // mondatszámok per
        var textToRead2 = (currentsentencenumber + " per " + allsentencenumber + " mondat.") ;
        var lang = 'hu-HUN';
        var audio2 = new SpeechSynthesisUtterance(textToRead2);
        audio2.lang = lang;
        audio2.rate = 0.8;
        audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
        audio2.pitch = 1.0;
        speechSynthesis.speak(audio2);

        // hány óra
        let date = new Date();
        let options = {
            year: 'numeric',
            month: 'numeric',
            day: 'numeric',
            hour: 'numeric',
            minute: 'numeric',
            timeZone: 'Europe/Budapest'
        };
        let formattedDate = new Intl.DateTimeFormat('hu-HU', options).format(date);
        console.log(formattedDate);
        var textToRead2 = formattedDate;
        var lang = 'en-ENG';
        if (winner === "hu") {
            var lang = 'hu-HUN';
        }
        var lang2 = lang;
        var audio2 = new SpeechSynthesisUtterance(textToRead2);
        audio2.lang = lang2;
        audio2.rate = 0.8;
        audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
        audio2.pitch = 1.0;
        speechSynthesis.speak(audio2);
    });
    
    
    
    
}
	
	//Spain weather
	
	
	
	
	function startWeatherApp({ width = 700, height = 500, bottomOffset = 20 } = {}) {
  const apiKey = 'abd7bd86bde4449ba8c80819230411';
  const videoUrl = 'https://m.youtube.com/watch?v=rBmaDf0Yd1A'; // Példa videó URL
  const subtitleUrl = ''; // Ide jöhet a felirat URL-je, ha van

  function weatherCreateStyles() {
    const style = document.createElement('style');
    style.textContent = `
      #weather-popup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(173, 216, 130, 0.5); /* Átlátszó világoskék háttér */
        color: #2c3e50; /* Sötétebb szövegszín */
        padding: 20px 30px 20px 30px;
        border-radius: 10px;
        box-shadow: 0 0 15px rgba(44, 62, 80, 0.3);
        font-family: Arial, sans-serif;
        width: ${width}px;
        height: ${height}px;
        box-sizing: border-box;
        z-index: 10000;
        user-select: none;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        position: relative; /* Fontos a controls abszolút pozíciójához */
      }
      #weather-popup h2 {
        margin: 0 0 15px 0;
        font-size: 22px;
        flex-shrink: 0;
        color: #3498db; /* Kék címsor */
      }
      #result {
        flex-grow: 1;
        overflow-y: auto;
        font-size: 16px;
        margin-bottom: 10px;
      }
      #error-msg {
        color: #e74c3c; /* Piros hibaüzenet */
        font-size: 14px;
        min-height: 18px;
        margin-bottom: 10px;
        flex-shrink: 0;
      }
      #controls {
        position: absolute;
        left: 30px;
        right: 30px;
        bottom: ${bottomOffset}px;
        display: flex;
        gap: 10px;
        align-items: center;
      }
      #location-input {
        flex-grow: 1;
        padding: 12px 14px;
        font-size: 18px;
        border-radius: 6px;
        border: 1px solid #bdc3c7; /* Szürke keret */
        box-sizing: border-box;
        color: #34495e; /* Sötét szöveg a beviteli mezőben */
      }
      #ok-btn, #close-btn, #youtube-btn {
        padding: 12px 24px;
        font-size: 18px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        background-color: rgba(0, 128, 0, 0.5); /* Átlátszó zöld gombok */
        color: white;
        transition: background-color 0.3s ease;
        white-space: nowrap;
      }
      #ok-btn:hover, #close-btn:hover, #youtube-btn:hover {
        background-color: rgba(0, 100, 0, 0.7); /* Sötétebb zöld hover */
      }
      #video-container {
        flex-grow: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: auto; /* Ha a videó túl nagy lenne */
        margin-bottom: 10px; /* Távolság a vezérlőktől */
      }
      #video-player-embedded {
        max-width: 100%;
        max-height: 100%;
        border: 3px solid #2980b9;
        border-radius: 10px;
      }
    `;
    document.head.appendChild(style);
  }

  async function fetchWeather(location) {
    const url = `https://api.weatherapi.com/v1/current.json?key=${apiKey}&q=${encodeURIComponent(location)}`;
    const response = await fetch(url);
    if (!response.ok) throw new Error(`Hálózati hiba: ${response.status}`);
    const data = await response.json();
    if (data.error) throw new Error(data.error.message);
    return data;
  }

  function formatLocalTime(localtimeStr) {
    const dt = new Date(localtimeStr);
    const h = dt.getHours().toString().padStart(2, '0');
    const m = dt.getMinutes().toString().padStart(2, '0');
    return `${h}:${m}`;
  }

  function speak(text) {
    if (!('speechSynthesis' in window)) {
      console.warn('A böngésző nem támogatja a hangos felolvasást.');
      return;
    }
    window.speechSynthesis.cancel();

    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = 'hu-HU';

    const voices = window.speechSynthesis.getVoices();
    const huVoice = voices.find(v => v.lang.startsWith('hu'));
    if (huVoice) {
      utterance.voice = huVoice;
    }

    window.speechSynthesis.speak(utterance);
  }

  function createPopup() {
    const existing = document.getElementById('weather-popup');
    if (existing) existing.remove();

    const popup = document.createElement('div');
    popup.id = 'weather-popup';

    popup.innerHTML = `
      <h2>Időjárás lekérdezése</h2>
      <div id="result"></div>
      <div id="error-msg"></div>
      <div id="video-container" style="display: none;">
        <video id="video-player-embedded" width="600" controls>
          A böngésződ nem támogatja a videó címkét.
          ${subtitleUrl ? `<track kind="subtitles" label="Felirat" src="${subtitleUrl}" srclang="hu" default>` : ''}
        </video>
      </div>
      <div id="controls">
        <input type="text" id="location-input" placeholder="Helyszín (pl. La Marina, Spain)" />
        <button id="ok-btn">OK</button>
        <button id="close-btn">Bezár</button>
        <button id="youtube-btn">Videó megtekintése</button>
      </div>
    `;

    document.body.appendChild(popup);

    return {
      popup,
      input: popup.querySelector('#location-input'),
      okBtn: popup.querySelector('#ok-btn'),
      closeBtn: popup.querySelector('#close-btn'),
      resultDiv: popup.querySelector('#result'),
      errorDiv: popup.querySelector('#error-msg'),
      youtubeBtn: popup.querySelector('#youtube-btn'),
      videoContainer: popup.querySelector('#video-container'),
      videoPlayerEmbedded: popup.querySelector('#video-player-embedded'),
    };
  }

  async function updateWeather(location, elements) {
    elements.errorDiv.textContent = '';
    elements.resultDiv.style.display = 'block';
    elements.errorDiv.style.display = 'block';
    elements.resultDiv.textContent = 'Betöltés...';
    elements.videoContainer.style.display = 'none'; // Elrejtjük a videót, ha éppen időjárás adatokat kérünk

    try {
      const data = await fetchWeather(location);
      const uvIndex = data.current.uv;
      const temperature = data.current.temp_c;
      const localTimeStr = formatLocalTime(data.location.localtime);

      elements.resultDiv.innerHTML = `
        <p><strong>Helyszín:</strong> ${data.location.name}, ${data.location.country}</p>
        <p><strong>UV index:</strong> ${uvIndex}</p>
        <p><strong>Helyi idő:</strong> ${localTimeStr}</p>
        <p><strong>Hőmérséklet:</strong> ${temperature} °C</p>
      `;

      const speechText = `A(z) ${data.location.name}, ${data.location.country} helyszín aktuális időjárási adatai: ` +
        `Az UV index ${uvIndex}. ` +
        `A helyi idő ${localTimeStr}. ` +
        `Az aktuális hőmérséklet ${temperature} Celsius fok.`;

      speak(speechText);

    } catch (err) {
      elements.resultDiv.textContent = '';
      elements.errorDiv.textContent = 'Hiba: ' + err.message;
    }
  }

  weatherCreateStyles();

  const elements = createPopup();

  const defaultLocation = 'La Marina, Spain';
  elements.input.value = defaultLocation;

  function onVoicesChanged() {
    updateWeather(defaultLocation, elements);
    window.speechSynthesis.removeEventListener('voiceschanged', onVoicesChanged);
  }
  if (window.speechSynthesis.getVoices().length === 0) {
    window.speechSynthesis.addEventListener('voiceschanged', onVoicesChanged);
  } else {
    updateWeather(defaultLocation, elements);
  }

  elements.okBtn.addEventListener('click', () => {
    const loc = elements.input.value.trim();
    if (loc.length === 0) {
      elements.errorDiv.textContent = 'Kérlek, adj meg egy helyszínt!';
      return;
    }
    updateWeather(loc, elements);
  });

  elements.input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      elements.okBtn.click();
    }
  });

  elements.closeBtn.addEventListener('click', () => {
    elements.popup.remove();
    window.speechSynthesis.cancel();
  });

  // YouTube videó megnyitása új ablakban
  elements.youtubeBtn.addEventListener('click', () => {
    window.open(videoUrl, '_blank', 'noopener,noreferrer,width=800,height=600');
  });

  // Hangfelismerés funkció
  if ('webkitSpeechRecognition' in window) {
    const recognition = new webkitSpeechRecognition();
    recognition.lang = 'hu-HU';
    recognition.continuous = false;
    recognition.interimResults = false;

    elements.input.addEventListener('click', () => {
      elements.input.value = ''; // Töröljük a beviteli mező tartalmát
      recognition.start();
    });

    recognition.onresult = (event) => {
      const transcript = event.results[0][0].transcript;
      elements.input.value = transcript;
      elements.okBtn.click(); // Automatikusan kattint az OK gombra
    };

    recognition.onerror = (event) => {
      elements.errorDiv.textContent = 'Hangfelismerési hiba: ' + event.error;
    };
  } else {
    elements.errorDiv.textContent = 'A böngésző nem támogatja a hangfelismerést.';
  }
}


	
	
	
	
	
	

	 
        function nonetinfogomb() {
    if (!navigator.onLine) {
       // alert("Nincs internet kapcsolat!");
    
        // Continue with the rest of the code
        // hány %
        let readpercentage = Math.round((currentsentencenumber / allsentencenumber) * 100);
        readpercentage = (readpercentage + " percent");
        console.log(readpercentage); 
        var textToRead2 = readpercentage;
        var lang2 = 'en-ENG';
        var audio2 = new SpeechSynthesisUtterance(textToRead2);
        audio2.lang = lang2;
        audio2.rate = 0.8;
        audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
        audio2.pitch = 1.0;
        speechSynthesis.speak(audio2);
    
        // Kívánatos és nemkívánatos speciális karakterek
        const desiredSpecialChars = ['?', '!', '.', ',', '\n'];
        const undesiredSpecialChars = ['+', '-', '_', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];
    
        let undesiredCharCount = 0;
        
        // Számolja meg a nemkívánatos speciális karaktereket
        for (let i = 0; i < bookname.length; i++) {
            if (undesiredSpecialChars.includes(bookname[i])) {
                undesiredCharCount++;
            }
        }
        
        // Számolja ki az eredeti tartalom 0.015%-át
        const threshold = bookname.length * 0.00015;
        
        // Értesítse a felhasználót, ha a limitet túllépték
        if (undesiredCharCount > threshold) {
            console.log('Figyelem: A nemkívánatos speciális karakterek száma meghaladja a bookname 0.015%-át.' + bookname);
            const filteredContent = filterSpecialCharacters(bookname);
            bookname = filteredContent; // replace the original content with
        } else {
            console.log('A bookname tartalom megfelelő.');
        }
        
        var textToRead2 = bookname;
        var lang = 'en-ENG';
        if (winner === "hu") {
            var lang = 'hu-HUN';
        }
        var lang2 = lang;
        var audio2 = new SpeechSynthesisUtterance(textToRead2);
        audio2.lang = lang2;
        audio2.rate = 0.8;
        audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
        audio2.pitch = 1.0;
        speechSynthesis.speak(audio2);
        
        // mondatszámok per
        var textToRead2 = (currentsentencenumber + " per " + allsentencenumber + " mondat.") ;
        var lang = 'hu-HUN';
        var audio2 = new SpeechSynthesisUtterance(textToRead2);
        audio2.lang = lang;
        audio2.rate = 0.8;
        audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
        audio2.pitch = 1.0;
        speechSynthesis.speak(audio2);

        // hány óra
        let date = new Date();
        let options = {
            year: 'numeric',
            month: 'numeric',
            day: 'numeric',
            hour: 'numeric',
            minute: 'numeric',
            timeZone: 'Europe/Budapest'
        };
        let formattedDate = new Intl.DateTimeFormat('hu-HU', options).format(date);
        console.log(formattedDate);
        var textToRead2 = formattedDate;
        var lang = 'en-ENG';
        if (winner === "hu") {
            var lang = 'hu-HUN';
        }
        var lang2 = lang;
        var audio2 = new SpeechSynthesisUtterance(textToRead2);
        audio2.lang = lang2;
        audio2.rate = 0.8;
        audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
        audio2.pitch = 1.0;
        speechSynthesis.speak(audio2);
    }
}
	
	// infogomb másodszori lenyomásakor funkció
	
	function weathernow() {
    
       $.get("https://api.weatherapi.com/v1/forecast.json?key=abd7bd86bde4449ba8c80819230411&q=Nagykata&days=6", function(data) {
            var currentWeather = data.current;

            // Display the current temperature and weather description
            var temperaturenow = currentWeather.temp_c;
            var descriptionnow = currentWeather.condition.text;
            $("#weather").text("Temperature: " + temperaturenow + "°C, Description: " + descriptionnow);

            // Speak the temperature and description out loud using the Web Speech API
            var utteranceforecastnow = new SpeechSynthesisUtterance();
            utteranceforecastnow.text = "The temperature is " + temperaturenow + " , degrees Celsius and the weather condition is " + descriptionnow;
            utteranceforecastnow.lang = "en-ENG"; // Set the language to English
            window.speechSynthesis.speak(utteranceforecastnow);
        });
        
        }
        
        
	
	// folyamatos hőmérsékletcheck
	
	function weathernowChecK() {
    var temperatureThreshold = 20;
    var temperatureCheckInterval = setInterval(function() {
        $.get("https://api.weatherapi.com/v1/forecast.json?key=abd7bd86bde4449ba8c80819230411&q=Nagykata&days=6", function(data) {
            var currentWeather = data.current;

            // Display the current temperature and weather description
            var temperaturenow = currentWeather.temp_c;
            var descriptionnow = currentWeather.condition.text;
            $("#weather").text("Temperature: " + temperaturenow + "°C, Description: " + descriptionnow);

  
//alert(temperaturenow);

  if (temperaturenow < temperatureThreshold) {
  	
  const searchLabel = createFadeInLabel("The temperature now " + temperaturenow + "°", {
  position: "absolute",
  top: "60%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  fontSize: "24px",
  fontWeight: "bold",
  color: "rgba(100, 100, 255, 0.6)",
  textShadow: "2px 2px 4px rgba(0, 0, 0, 0.5)",
  zIndex: 1
});
  
  
//startTypingAnimation('paragraphId', 'divId', "The temperature now " + temperaturenow + "°");

}

            // Check if the temperature is 20°C or higher
            if (temperaturenow >= temperatureThreshold) {
            	
            startTypingAnimation('paragraphId', 'divId', "The temperature has reached " + temperatureThreshold + "°C!");
            
               // alert("The temperature has reached " + temperatureThreshold + "°C!");
               
               
                         // Speak the temperature and description out loud using the Web Speech API
            var utteranceforecastnow = new SpeechSynthesisUtterance();
            utteranceforecastnow.text = "The temperature is " + temperaturenow + " , degrees Celsius and the weather condition is " + descriptionnow;
            utteranceforecastnow.lang = "en-ENG"; // Set the language to English
            window.speechSynthesis.speak(utteranceforecastnow);

               
               
                clearInterval(temperatureCheckInterval);
            }
        });
    }, 2000); // Check every 1 seconds
    removelabel("temperature");
}
        
        /*
        setInterval(function() {
    weathernowChecK();
}, 60000);
        */
        
       
	
	// háromnapos weather
	function weather3() {
		       $.get("https://api.weatherapi.com/v1/forecast.json?key=abd7bd86bde4449ba8c80819230411&q=Nagykata&days=6", function(data) {
            // Get the forecast data for the next 3 days
            var forecast = data.forecast.forecastday;

            // Display the forecast for each day
            forecast.forEach(function(day) {
                // Store the date in a variable
                var date = new Date(day.date);
                // Get the day of the week from the date
                // ha magyar kellene:
                //var dayOfWeek = date.toLocaleString('default', { weekday: 'long' });
                var dayOfWeek = date.toLocaleString('en-US', { weekday: 'long' });
                // Get the description of the weather from the day object
                var description = day.day.condition.text;

                // Log the data to the console
                console.log("Date:", dayOfWeek);
                console.log("Description:", description);
                console.log("-----------------------------------");

                // Speak the date and description out loud using the Web Speech API
                var utterance = new SpeechSynthesisUtterance();
                //utterance.text = "Date: " + dayOfWeek + ", Description: " + description;
                utterance.text = dayOfWeek + ", " + description;
                utterance.lang = "en-ENG"; // Set the language to English
                window.speechSynthesis.speak(utterance);

                // Display the forecast for each day
                $("#weather").append("<p>Date: " + dayOfWeek + "</p>");
                $("#weather").append("<p>Description: " + description + "</p>");
                $("#weather").append("<hr>");
            });
        });
    
    
    
    
    
    
	// napkelte
	
	let sunrise;

const lat = 47.3178;
const lng = 19.7433;
const apiUrl = `https://api.sunrise-sunset.org/json?lat=${lat}&lng=${lng}&date=today&formatted=0`;

fetch(apiUrl)
  .then(response => response.json())
  .then(data => {
    sunrise = new Date(data.results.sunrise);
    const now = new Date();
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();

    if (sunrise < now && (currentHour < 23 || (currentHour === 23 && currentMinute < 59))) {
      // Ha a napkelte már elmúlt és 23:59 előtt vagyunk, számítsa a következő napot
      const tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
      const tomorrowSunrise = new Date(tomorrow.getFullYear(), tomorrow.getMonth(), tomorrow.getDate(), sunrise.getHours(), sunrise.getMinutes(), sunrise.getSeconds());
      const timeDifference = getTimeDifference(tomorrowSunrise);
      
      console.log(`A holnapi napkelte időpontja ${timeDifference.hours} óra és ${timeDifference.minutes} perc múlva lesz.`);
      
      var textToRead = (`A holnapi napkelte időpontja ${timeDifference.hours} óra és ${timeDifference.minutes} perc múlva lesz.`);
      var lang = 'hu-HUN';
      var audio = new SpeechSynthesisUtterance(textToRead);
      audio.lang = lang;
      audio.rate = 0.8;
      audio.volume = 1;
      audio.pitch = 1.0;
      speechSynthesis.speak(audio);
    } else {
      // A napkelte még nem volt meg, kiszámítjuk a mai napkelte időpontjáig hátralévő időt
      const timeDifference = getTimeDifference(sunrise);
      
      console.log(`A napkelte időpontja ${timeDifference.hours} óra és ${timeDifference.minutes} perc múlva lesz.`);
      
      var textToRead = (`A napkelte időpontja ${timeDifference.hours} óra és ${timeDifference.minutes} perc múlva lesz.`);
      var lang = 'hu-HUN';
      var audio = new SpeechSynthesisUtterance(textToRead);
      audio.lang = lang;
      audio.rate = 0.8;
      audio.volume = 1;
      audio.pitch = 1.0;
      speechSynthesis.speak(audio);
    }
  })
  .catch(error => console.error('Hiba:', error));

function getTimeDifference(date) {
  const now = new Date();
  const diffInMilliseconds = date - now;
  const hoursDifference = Math.floor(diffInMilliseconds / 1000 / 60 / 60);
  const minutesDifference = Math.round((diffInMilliseconds % (1000 * 60 * 60)) / (1000 * 60));
  return { hours: hoursDifference, minutes: minutesDifference };
}


	
	//battery




let batteryCurrent;

if ('getBattery' in navigator) {
  navigator.getBattery().then(function(battery) {
    // Frissítjük az akkumulátor állapotát
    function updateBatteryStatus() {
      batteryCurrent = battery.level * 100;
      console.log("Akkumulátor töltöttsége: " + batteryCurrent + "%");

      // Audio 2 rate és pitch beállítása az akkumulátor töltöttsége alapján
      let ratePercentage = batteryCurrent / 100; // Rate százalékos értéke
      let pitchPercentage = batteryCurrent / 100; // Pitch százalékos értéke
//egész számot
batteryCurrent = Math.round(battery.level * 100);

      var textToRead2 = ("Akkumulátor: " + batteryCurrent + " százalék");
      var lang2 = 'hu-HUN';
      var audio2 = new SpeechSynthesisUtterance(textToRead2);
      audio2.lang = lang2;
      audio2.rate = ratePercentage; // Rate beállítása a töltöttség arányában
      audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
      audio2.pitch = pitchPercentage; // Pitch beállítása a töltöttség arányában
      speechSynthesis.speak(audio2);
    }

    updateBatteryStatus(); // Hívjuk meg az updateBatteryStatus függvényt azonnal is
  });
}
//akksi vége

//uv

var utterance = new SpeechSynthesisUtterance();

fetch('https://api.weatherapi.com/v1/current.json?key=abd7bd86bde4449ba8c80819230411&q=Nagykata')
    .then(response => response.json())
    .then(data => {
        const temperature = data.current.temp_c; // Extract temperature in Celsius
        const uvIndex = data.current.uv; // Extract UV index
        var localTime = new Date(data.location.localtime);
        var hours = localTime.getHours();
        var minutes = localTime.getMinutes();
        var formattedTime = hours.toString().padStart(2, '0') + ':' + minutes.toString().padStart(2, '0');

        var result = 'Temperature: ' + temperature + '°C. UV index: ' + uvIndex + '_____ ' + formattedTime;

        const fetchedData = `Temp: ${temperature}°C. UV Index: ${uvIndex} _____ ${formattedTime}`;
        console.log(fetchedData);
        uvdata = fetchedData ;

        utterance.text = uvdata;
        window.speechSynthesis.speak(utterance);
    });




	}
	
	
	
	


	//ez egyszeri check oldalbetöltéskor
	var burl = 'https://api.binance.com/api/v3/ticker/price?symbol=';
var symbol = 'BTCUSDT';
var url = burl + symbol;

var ourRequest = new XMLHttpRequest();
ourRequest.open('GET', url, true);

ourRequest.onload = function() {
    var data = JSON.parse(ourRequest.responseText);
    var bitcoinPrice = data.price;
    console.log(bitcoinPrice);

};

ourRequest.send();

	
	
	
	
	
	let resultglobal1; // Globális változó deklarálása

function calculateData() {
    // Valamilyen számítás elvégzése
    resultglobal1 = 42; // Az eredmény beállítása a globális változóban
}
function accessData() {
    //console.log(resultglobal1); // Hozzáférés a globális változóhoz
}

calculateData(); // Az adatok kiszámítása
accessData(); // A kiszámított adatok elérése
//alert(resultglobal1);
	
	
	
	
	
		let resultglobal2; // Globális változó deklarálása

function calculateData2() {
	
	
    // Valamilyen számítás elvégzése
    resultglobal2 = 42; // Az eredmény beállítása a globális változóban
}

function accessData2() {
	
	
   // console.log(resultglobal2); // Hozzáférés a globális változóhoz
}

calculateData2(); // Az adatok kiszámítása
accessData2(); // A kiszámított adatok elérése
//alert(resultglobal2);
	
	
	// --------  Alert Yeah
	function checkBitcoinPrice() {
    var burl = 'https://api.binance.com/api/v3/ticker/price?symbol=';
    var symbol = 'BTCUSDT';
    var url = burl + symbol;

    var ourRequest = new XMLHttpRequest();
    ourRequest.open('GET', url, true);

    ourRequest.onload = function() {
        var data = JSON.parse(ourRequest.responseText);
        var bitcoinPrice = parseFloat(data.price);
        console.log(bitcoinPrice);
        
                  // A változók értékeinek beírása az terminator1osd 'callout right' osztályú div-be
            let vari1 = bitcoinPrice;
            document.querySelector('.callout.right .title').textContent = vari1;
        
       // alert(bitcoinPrice);

setprice = 92000;

        if (bitcoinPrice > 1000000000) {
        	// alert('price is greater than ' + setprice + '   ' + bitcoinPrice);
            // Gomb létrehozása és megjelenítése
            document.body.style.backgroundColor = 'white';
document.body.style.backgroundImage = "url('./picture/alert-attention-sign-bold-red-letters-against-a-pristine-white-background-high-contrast-warning-s-848329442.jpeg')"; // Háttérkép beállítása
    document.body.style.animation = "backgroundSlideIn 1s forwards"; // Animáció alkalmazása a háttérképre
    
    
            var alertButton = document.createElement('button');
            alertButton.innerText = 'Price alert ' + bitcoinPrice;  
            alertButton.style.position = 'fixed';
        alertButton.style.top = '290px';
        alertButton.style.zIndex = '1000';
        alertButton.style.left = '50%';
        alertButton.style.transform = 'translateX(-50%)';
        alertButton.style.padding = '10px 260px';
        alertButton.style.backgroundColor = 'rgba(220, 3, 5, 1)';
        alertButton.style.color = 'rgba(250, 253, 255, 1)'; // Piros szövegszín beállítása
        alertButton.style.fontSize = '28px';
        alertButton.style.border = 'none';
        alertButton.style.borderRadius = '5px';
        alertButton.style.cursor = 'pointer';
        alertButton.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
        
            alertButton.onclick = function() {
                // Videó lejátszása
                var videoPopup = document.getElementById('videoPopup');
                var popupVideo = document.getElementById('popupVideo');
                videoPopup.style.display = 'block';
                popupVideo.play();
                popupVideo.onended = function() {
                    videoPopup.style.display = 'none';
                };
            };
            document.body.appendChild(alertButton);
        }
    };

    ourRequest.send();
}

setInterval(checkBitcoinPrice, 60000); // Update every minute (60000 milliseconds)

// Videó popup elem és videó elem létrehozása
var videoPopup = document.createElement('div');
videoPopup.id = 'videoPopup';
videoPopup.style.display = 'none';
videoPopup.style.position = 'fixed';
videoPopup.style.left = '50%';
videoPopup.style.top = '50%';
videoPopup.style.transform = 'translate(-50%, -50%)';
videoPopup.style.zIndex = '1000';

var popupVideo = document.createElement('video');
popupVideo.id = 'popupVideo';
popupVideo.src = './video/price Synthesia STUDIO Your AI video.mp4';
videoPopup.appendChild(popupVideo);

document.body.appendChild(videoPopup);

checkBitcoinPrice();



	// --------  Alert vége Yeah


  //  btc read start







function startBitcoinPriceReader() {
  const styleContent = `
    body, html {
      margin: 0; padding: 0; height: 100%;
      background: rgba(40, 40, 60, 0.9);
      color: white;
      font-family: Arial, sans-serif;
      overflow: auto;
      display: block;
    }
    #app {
      position: fixed;
      top: 520px;
      right: 120px;
      width: 600px;
      max-height: 400px;
      padding: 20px;
      box-sizing: border-box;
      z-index: 11200;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
    }
    #panel {
      background: linear-gradient(135deg, rgba(0, 128, 128, 0.3), rgba(0, 255, 255, 0.15));
      border-radius: 15px;
      padding: 30px 25px;
      box-shadow: 0 8px 24px rgba(0, 128, 128, 0.4);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: 11200;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      user-select: none;
      max-height: 100%;
      overflow-y: auto;
    }
    #btcPrice {
      margin-top: 0;
      font-size: 1.1rem;
      font-weight: bold;
      text-align: center;
      color: #e0f7f7;
      text-shadow: 0 0 6px rgba(0, 255, 255, 0.7);
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    #countdown {
      margin-top: 12px;
      font-size: 0.9rem;
      text-align: center;
      color: #a0f0f0;
      font-weight: 600;
      text-shadow: 0 0 4px rgba(0, 255, 255, 0.5);
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    #intervalControl {
      margin-top: 20px;
      font-size: 0.9rem;
      width: 100%;
      max-width: 400px;
      color: #ccf9f9;
      user-select: none;
    }
    #intervalControl label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      text-shadow: 0 0 3px rgba(0, 255, 255, 0.6);
    }
    #intervalControl input[type="range"] {
      width: 100%;
      cursor: pointer;
      -webkit-appearance: none;
      height: 8px;
      border-radius: 5px;
      background: linear-gradient(90deg, #00ffff, #008080);
      outline: none;
      transition: background 0.3s ease;
    }
    #intervalControl input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #00ffff;
      cursor: pointer;
      box-shadow: 0 0 8px #00ffff;
      border: none;
      margin-top: -7px;
      transition: background 0.3s ease;
    }
    #intervalControl input[type="range"]:hover::-webkit-slider-thumb {
      background: #00e6e6;
      box-shadow: 0 0 12px #00e6e6;
    }
    #intervalValue {
      font-weight: bold;
      margin-left: 8px;
      color: #a0f0f0;
      text-shadow: 0 0 3px rgba(0, 255, 255, 0.6);
      user-select: none;
    }
  `;
  const styleElem = document.createElement('style');
  styleElem.textContent = styleContent;
  document.head.appendChild(styleElem);

  const app = document.createElement('div');
  app.id = 'app';

  const panel = document.createElement('div');
  panel.id = 'panel';

  const btcPrice = document.createElement('div');
  btcPrice.id = 'btcPrice';
  btcPrice.textContent = '...';

  const countdown = document.createElement('div');
  countdown.id = 'countdown';
  countdown.textContent = 'Következő felolvasásig: -- s';

  const intervalControl = document.createElement('div');
  intervalControl.id = 'intervalControl';

  const label = document.createElement('label');
  label.setAttribute('for', 'intervalSlider');
  label.innerHTML = 'Frissítési időköz (másodperc): <span id="intervalValue">30</span>s';

  const intervalSlider = document.createElement('input');
  intervalSlider.type = 'range';
  intervalSlider.id = 'intervalSlider';
  intervalSlider.min = '10';
  intervalSlider.max = '120';
  intervalSlider.value = '30';
  intervalSlider.step = '1';

  intervalControl.appendChild(label);
  intervalControl.appendChild(intervalSlider);

  panel.appendChild(btcPrice);
  panel.appendChild(countdown);
  panel.appendChild(intervalControl);

  app.appendChild(panel);
  document.body.appendChild(app);

  const intervalValueSpan = label.querySelector('#intervalValue');

  const API_URL = 'https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd';

  let intervalId = null;
  let countdownIntervalId = null;
  let voices = [];
  let readCount = 0;
  let previousPrice = null;

  function loadVoices() {
    return new Promise(resolve => {
      voices = speechSynthesis.getVoices();
      if (voices.length) {
        resolve(voices);
        return;
      }
      speechSynthesis.onvoiceschanged = () => {
        voices = speechSynthesis.getVoices();
        resolve(voices);
      };
    });
  }

  function readUniversal(textToRead, langCode, volume = 1, olvassebesseg = 1, pitch = 1) {
    if (!textToRead || typeof textToRead !== "string") {
        console.warn("Nincs mit felolvasni.");
        return;
    }

    const supportedLanguages = [
        'hu-HU', 'en-US', 'en-GB', 'de-DE', 'fr-FR', 'es-ES', 'it-IT', 'ru-RU',
        'zh-CN', 'ja-JP', 'ar-SA', 'pt-PT', 'ko-KR'
    ];

    if (!langCode || !supportedLanguages.includes(langCode)) {
        console.warn(`Nem támogatott nyelv: ${langCode}, alapértelmezett angolra váltok.`);
        langCode = 'en-US';
    }

    if (typeof volume !== 'number' || volume < 0 || volume > 1) {
        console.warn(`Érvénytelen hangerő: ${volume}, alapértelmezett 1 lesz.`);
        volume = 1;
    }

    if (typeof olvassebesseg !== 'number' || olvassebesseg < 0.1 || olvassebesseg > 10) {
        console.warn(`Érvénytelen olvasási sebesség: ${olvassebesseg}, alapértelmezett 1 lesz.`);
        olvassebesseg = 1;
    }

    if (typeof pitch !== 'number' || pitch < 0 || pitch > 2) {
        console.warn(`Érvénytelen hangmagasság: ${pitch}, alapértelmezett 1 lesz.`);
        pitch = 1;
    }

    const utterance = new SpeechSynthesisUtterance(textToRead);
    utterance.lang = langCode;
    utterance.volume = volume;
    utterance.rate = olvassebesseg;
    utterance.pitch = pitch;

    speechSynthesis.speak(utterance);
}

  async function fetchAndSpeakBitcoinPrice() {
    try {
      const response = await fetch(API_URL);
      if (!response.ok) throw new Error('Hálózati hiba: ' + response.status);
      const data = await response.json();

      const priceUSD = Math.round(data.bitcoin.usd);
      btcPrice.textContent = priceUSD.toString();

      let speechText = priceUSD.toString();
      if (readCount > 0 && previousPrice !== null && previousPrice !== priceUSD) {
        const diff = priceUSD - previousPrice;
        const absDiff = Math.abs(diff);
        const direction = diff > 0 ? "nőtt" : "csökkent";
        speechText += `, az ár ${direction} ${absDiff} dollárral.`;
      }

      readUniversal(speechText, 'hu-HU');

      previousPrice = priceUSD;
      readCount++;

      resetCountdown(parseInt(intervalSlider.value, 10));
    } catch (error) {
      btcPrice.textContent = 'Hiba az ár lekérésekor.';
      console.error(error);
    }
  }

  function startInterval(intervalSec) {
    if (intervalId) clearInterval(intervalId);
    intervalId = setInterval(fetchAndSpeakBitcoinPrice, intervalSec * 1000);
  }

  function resetCountdown(seconds) {
    if (countdownIntervalId) clearInterval(countdownIntervalId);
    let timeLeft = seconds;
    countdown.textContent = `Következő felolvasásig: ${timeLeft} s`;

    countdownIntervalId = setInterval(() => {
      timeLeft--;
      if (timeLeft < 0) timeLeft = 0;
      countdown.textContent = `Következő felolvasásig: ${timeLeft} s`;
    }, 1000);
  }

  (async () => {
    await loadVoices();
    readUniversal('A program elindult.', 'hu-HU');
    fetchAndSpeakBitcoinPrice();
    startInterval(intervalSlider.value);
  })();

  intervalSlider.addEventListener('input', () => {
    const val = intervalSlider.value;
    intervalValueSpan.textContent = val;
    startInterval(val);
    resetCountdown(parseInt(val, 10));
  });
}
// Indításhoz hívd meg:
// startBitcoinPriceReader()









   // btc read vége



// újság second ez a nospeak version


async function ujsag() {
    
    console.log('News random keresés indítása');
    newsflag = 1;
    await randomWordFunction();
    if (typeof rndWord === 'string' && rndWord.length > 0) {
      console.log(`Random szó a kereséshez: ${rndWord}`);
      await fetchAndReadNews_7d18(rndWord);
    } else {
      console.log('Nem sikerült random szót generálni.');
      await speakText_7d18('Nem sikerült random szót generálni.');
    }
    return;
}

  
  
  async function ujsaggoogle() {
  	
//  createSearchInputWithButton();
  
  console.log('Google keresés random szóval indítása');
  newsflag = 1;
  await randomWordFunction();
  if (typeof rndWord === 'string' && rndWord.length > 0) {
    console.log(`Random szó a kereséshez: ${rndWord}`);
    await performGoogleSearchAndRead123(rndWord);
  } else {
    console.log('Nem sikerült random szót generálni.');
    await speakText_google('Nem sikerült random szót generálni.');
  }
  return;
}






 //   ---- Meló text akciók


// föld
function contentarchive() {
  // Az origcontent mondatokra bontása
  const sentences = origcontent.match(/[^.!?]+(?:.!?)/g);

  if (sentences) {
    // A currentsentencenumber-hez tartozó mondat és a környező mondatok kiválasztása
    const start = Math.max(0, currentsentencenumber - 100); // Győződjünk meg róla, hogy nem negatív indexet adunk meg
    const end = Math.min(sentences.length, currentsentencenumber + 200); // Győződjünk meg róla, hogy nem lépünk túl a tömb határain
    const archiveSentences = sentences.slice(start, end);

    // Az archivesentence változóba helyezés
    let archivesentence = archiveSentences.join(' ');

    // Az archivesentence változó megjelenítése console.log segítségével
    console.log(archivesentence);

    // Az archivesentence változó hozzáadása a localStorage-hoz
    const currentDate = new Date();
    const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', hour: 'numeric', minute: 'numeric' };
    const formattedDate = currentDate.toLocaleDateString('hu-HU', options);

    var actualsentence = document.getElementById('selectedtextblock').innerText;

    // Függvény a dátum szó szerinti megfogalmazására
    function dateToWords(date) {
      const months = {
        '0': 'január',
        '1': 'február',
        '2': 'március',
        '3': 'április',
        '4': 'május',
        '5': 'június',
        '6': 'július',
        '7': 'augusztus',
        '8': 'szeptember',
        '9': 'október',
        '10': 'november',
        '11': 'december'
      };

      const day = date.getDate();
      const month = months[date.getMonth()];
      const year = date.getFullYear();

      // A nap szó szerinti megfogalmazása
      let dayInWords;
      if (day === 1) {
        dayInWords = 'első';
      } else if (day === 2) {
        dayInWords = 'második';
      } else if (day === 3) {
        dayInWords = 'harmadik';
      } else if (day === 4) {
        dayInWords = 'negyedik';
      } else if (day === 5) {
        dayInWords = 'ötödik';
      } else if (day === 6) {
        dayInWords = 'hatodik';
      } else if (day === 7) {
        dayInWords = 'hetedik';
      } else if (day === 8) {
        dayInWords = 'nyolcadik';
      } else if (day === 9) {
        dayInWords = 'kilencedik';
      } else if (day === 10) {
        dayInWords = 'tizedik';
      } else if (day === 11) {
        dayInWords = 'tizenegyedik';
      } else if (day === 12) {
        dayInWords = 'tizenkettedik';
      } else if (day === 13) {
        dayInWords = 'tizenharmadik';
      } else if (day === 14) {
        dayInWords = 'tizennegyedik';
      } else if (day === 15) {
        dayInWords = 'tizenötödik';
      } else if (day === 16) {
        dayInWords = 'tizenhatodik';
      } else if (day === 17) {
        dayInWords = 'tizenhetedik';
      } else if (day === 18) {
        dayInWords = 'tizennyolcadik';
      } else if (day === 19) {
        dayInWords = 'tizenkilencedik';
      } else if (day === 20) {
        dayInWords = 'huszadik';
      } else if (day === 21) {
        dayInWords = 'huszonegyedik';
      } else if (day === 22) {
        dayInWords = 'huszonkettedik';
      } else if (day === 23) {
        dayInWords = 'huszonharmadik';
      } else if (day === 24) {
        dayInWords = 'huszonnegyedik';
      } else if (day === 25) {
        dayInWords = 'huszonötödik';
      } else if (day === 26) {
        dayInWords = 'huszonhatodik';
      } else if (day === 27) {
        dayInWords = 'huszonhetedik';
      } else if (day === 28) {
        dayInWords = 'huszonnyolcadik';
      } else if (day === 29) {
        dayInWords = 'huszonkilencedik';
      } else if (day === 30) {
        dayInWords = 'harmincadik';
      } else if (day === 31) {
        dayInWords = 'harmincegyedik';
      }

      return `${month} ${dayInWords}.`;
    }

    // A függvény használata
    const dateInWords = dateToWords(currentDate);

    let lines = [
      bookname,
      actualsentence,
      formattedDate,
      dateInWords
    ];
    createSimplePanel(
      lines,
      'rgba(255, 255, 255, 0.8)', // Fehér háttér 80%-os opacitással
      50, // X pozíció: 50%
      12, // Y pozíció: 12%
      'a', // Automatikus szélesség
      5000, // Eltűnési idő: 3 másodperc
      20, // Betűméret: 24 pixel
      1 // Randomizálás bekapcsolva
    );

    const existingEntries = localStorage.getItem('archivesentencestorage') || '';
    const newEntry = `\n${existingEntries}\n${bookname}\n${actualsentence}\n${formattedDate}\n${dateInWords}\nsentence ${currentsentencenumber}\n\n${archivesentence}\n-------------------------------------------`;

    localStorage.setItem('archivesentencestorage', newEntry);

    // Sikeres művelet tájékoztatása
    startTypingAnimation('paragraphId', 'divId', 'Az adatok sikeresen hozzá lettek adva a localstorage-ban lévő archivesentencestorage bejegyzéshez.');

    playany(['snd/Page 3 Search Coin Arcade Soundsnap.mp3'], 1);

    // Fájl tartalmának összeállítása
    const fileContent = `${bookname}\n${actualsentence}\n${formattedDate}\n${dateInWords}\nMondat ${currentsentencenumber}\n${archivesentence}\n-------------------------------------------`;

    // Random szó kiválasztása és fájlnev létrehozása
    const words = archivesentence.split(' ');
    const randomIndex = Math.floor(Math.random() * words.length);
    const randomWords = words.slice(randomIndex, randomIndex + 6).join('-');
    const filename = `archiveföld-${randomWords}.txt`;

    // Blob fájl létrehozása és letöltése
    const blob = new Blob([fileContent], { type: 'text/plain' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();

  } else {
    alert('Nincsenek mondatok az origcontent változóban.');
  }
}






let holdContainer; // Globális változó a holdContainer elem tárolására

function hold() {
	
	            let popup = document.getElementById('popup');
    if (popup.style.display === 'block') {
    	playRandomSound6();
    
    	optionsopen = 0;
        popup.style.display = 'none'; // Ha látható, akkor elrejtjük
        //meg a többi ablakot is bezárjuk
            favoritPopup.style.display = 'none'; // Elrejti a popup ablakot
            currentFavoritIndex = 0;
            stopMusic();
            stopPlayany();
            searchclose();
        
        }
	
	holdopened = 1;
	playany(['snd/Sound design user interface accent - coin - 04 - select - acquire Soundsnap.mp3'], 1);
  const storedContent = localStorage.getItem('archivesentencestorage') || '';
  const parts = storedContent.split('-------------------------------------------\n');

  // Töröljük az utolsó üres részt, ha van
  if (parts[parts.length - 1].trim() === '') {
    parts.pop();
  }

  // Ellenőrizzük, hogy van-e 'archivesentencestorage' bejegyzés a localStorage-ban
  if (storedContent === '') {
    // Ha nincs, akkor hozzunk létre egyet a megadott értékkel
    localStorage.setItem('archivesentencestorage', 'Ez az első mondat.\n-------------------------------------------\nEz a második mondat.');
  }

  // Olvassuk ki a 'archivesentencestorage' bejegyzés tartalmát
  const storedContentReload = localStorage.getItem('archivesentencestorage');
  const partsReload = storedContentReload.split('-------------------------------------------\n');

  // Töröljük az utolsó üres részt, ha van
  if (partsReload[partsReload.length - 1].trim() === '') {
    partsReload.pop();
  }

  // Létrehozzuk a holdContainer div-et
  holdContainer = document.createElement('div');
  holdContainer.className = 'holdContainer';
  holdContainer.style.position = 'fixed';
  holdContainer.style.top = '0';
  holdContainer.style.left = '0';
  holdContainer.style.width = '100%';
  holdContainer.style.height = '100%';

  // Random háttérszín
  const randomR = Math.floor(Math.random() * 256);
  const randomG = Math.floor(Math.random() * 256);
  const randomB = Math.floor(Math.random() * 256);
  const randomA = 0.3; // Átlátszóság

  holdContainer.style.backgroundColor = `rgba(${randomR}, ${randomG}, ${randomB}, ${randomA})`;
  holdContainer.style.display = 'flex';
  holdContainer.style.justifyContent = 'center';
  holdContainer.style.alignItems = 'center';
  holdContainer.style.zIndex = '9999';
  holdContainer.style.opacity = '0';
  holdContainer.style.transition = 'opacity 0.5s ease-in-out';

  // Létrehozzuk a tartalmat tartalmazó elemet
const holdContent = document.createElement('div');
holdContent.style.backgroundColor = 'rgba(100, 190, 110, 0.5)';
holdContent.style.padding = '20px';
holdContent.style.borderRadius = '5px';
holdContent.style.maxWidth = '80%';
holdContent.style.maxHeight = '80%';
holdContent.style.overflowY = 'auto';
holdContent.style.fontSize = '18px'; // Betűméret beállítása


  // Hozzáadjuk a listaelemeket a tartalomhoz
  for (let i = partsReload.length - 1; i >= 0; i--) {
  const part = partsReload[i];
  const itemElement = document.createElement('p');
  itemElement.style.cursor = 'pointer'; 
  itemElement.style.padding = '10px'; 
  itemElement.style.borderRadius = '5px'; 
  itemElement.style.marginBottom = '10px'; 
  itemElement.textContent = `Mondat ${i + 1}: ${part.substring(0, 50)}...`;

  if (i % 2 === 0) {
    itemElement.style.color = 'rgb(128, 228, 248)';
  }

  itemElement.addEventListener('click', () => {
    origcontent = part.replace(/.*\nMondat \d+\n/, '');
    playany(['snd/snap click 20250412_114526_mp3_V1.mp3'], 1);
    fadeOutElements();
  });

  holdContent.appendChild(itemElement);
}


  holdContainer.appendChild(holdContent);
  document.body.appendChild(holdContainer);

  // Átlátszóság növelése
  setTimeout(() => {
    holdContainer.style.opacity = '1';
  }, 100);

  // Mondjuk be a listaelemek számát
  var textToRead = `Összesen ${partsReload.length} elem található a listában.`;
  var audio = new SpeechSynthesisUtterance(textToRead);
  speechSynthesis.speak(audio);

  // nem Fade-out funkció
  
  function fadeOutElements() {
    holdContainer.style.display = 'none'; // Eltüntetjük a konténert

    // A betöltés
    bookname = ("archive");

    //randomNumber = rndmaker(1, 100000);
    //bookname = "archive " + randomNumber;

    // Speciális karakterek kezelése
    const undesiredSpecialChars = ['+', '-', '_', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];
    let filteredContent = bookname.split('').map(char => undesiredSpecialChars.includes(char) ? ' ' : char).join('');

    // Visszahelyezés a kiszedett karakterek helyére egy space-szel
    bookname = filteredContent;

    // A fájl nevéből kiszedjük a zárójeleket
    bookname = bookname.replace(/[()]/g, '');

    console.log('Book name:', bookname); // Ha létezik a bookname, kiírjuk a konzolba

    legorigabbcontent = origcontent;

    analysis();   // már itt lefut
    replaceSt();
    removeQuotes();  // idézőjel
    replaceMr();
    linebreakreplacement(); //savefilenak formázás

    let result = AIrecognizelanguage(origcontent);
    supervision();

    if (bookname) {
      fadebookname(); // fadetext
      console.log('File loaded successfully.');
    }
    countSentences();

    //currentsentencenumber = 1; // 
    //setSliderToCurrentSentence(); //
    
    //titletranslate();
    //bookpercent();
    //four();

    //alert(randombooknumber);

    //setTimeout(percentread, 3000);
  }

  // Stílusok hozzáadása a fejlécben
  const style = document.createElement('style');
  style.innerHTML = `
    /* Egyedi prefix hozzáadása az osztálynevekhez */
    .holdContainer {
      z-index: 10100;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }
  `;
  document.head.appendChild(style);
}





let currentHoldIndex = -1; // Globális változó a jelenlegi index nyomon követésére
let selectHoldBlind = ''; // Globális változó a kiválasztott elem tárolására

function holdDown() {
    let storedContent = localStorage.getItem('archivesentencestorage') || '';
    let parts = storedContent.split('-------------------------------------------\n');

    if (parts[parts.length - 1].trim() === '') {
        parts.pop();
    }

    if (storedContent === '') {
        localStorage.setItem('archivesentencestorage', 'Ez az első mondat.\n-------------------------------------------\nEz a második mondat.');
    }

    let storedContentReload = localStorage.getItem('archivesentencestorage');
    let partsReload = storedContentReload.split('-------------------------------------------\n');

    if (partsReload[partsReload.length - 1].trim() === '') {
        partsReload.pop();
    }

    currentHoldIndex++; // Növeljük az indexet a következő elemre
    if (currentHoldIndex >= partsReload.length) {
        currentHoldIndex = 0; // Vissza az első elemre, ha a végére értünk
        playRandomSound13();
    }

    let part = partsReload[currentHoldIndex];
    let fileName = `Mondat ${currentHoldIndex + 1}.txt`;

    localStorage.setItem('readpathstorage', fileName);

    selectHoldBlind = part; // A teljes tartalmat tároljuk

    let hungarianlanguage = 0;
    let englishlanguage = 0;

    // Nyelvfelismerés és beszédszintézis
    let magyarEkezetesBetukSzama = 0;
    let esSzavakSzama = 0;
    let theSzavakSzama = 0;

    for (let i = 0; i < part.length; i++) {
        let currentChar = part[i];
        if (/[áéíóöőúüűÁÉÍÓÖŐÚÜŰ]/.test(currentChar)) {
            magyarEkezetesBetukSzama++;
        }
    }

    let szavak = part.split(" ");
    for (let j = 0; j < szavak.length; j++) {
        if (szavak[j] === "és") {
            esSzavakSzama++;
        }
    }

    for (let j = 0; j < szavak.length; j++) {
        if (szavak[j] === "the") {
            theSzavakSzama++;
        }
    }

    if (magyarEkezetesBetukSzama > 0) {
        hungarianlanguage += 40;
    }

    if (magyarEkezetesBetukSzama < 1) {
        englishlanguage += 20;
    }

    if (esSzavakSzama > 0) {
        hungarianlanguage += 35;
    }

    if (theSzavakSzama > 0) {
        englishlanguage += 35;
    }

    let winner = "";
    if (hungarianlanguage > englishlanguage) {
        winner = "hu";
    } else if (hungarianlanguage < englishlanguage) {
        winner = "en";
    }

    console.log('Current Hold Index: ' + (currentHoldIndex + 1));
    var textToRead3 = `A ${currentHoldIndex + 1}. bejegyzés következik.`;
    speechSynthesis.cancel(); // Leállítjuk a korábbi beszédszintézist
    var audio3 = new SpeechSynthesisUtterance(textToRead3);
    speechSynthesis.speak(audio3);

    var textToRead2 = part.substring(0, 50); // A listaelemben megjelenő szövegrészlet
    speechSynthesis.cancel(); // Leállítjuk a korábbi beszédszintézist
    var lang = 'en-ENG';
    if (winner === "hu") {
        lang = 'hu-HUN';
    }
    var lang2 = lang;
    var audio2 = new SpeechSynthesisUtterance(textToRead2);
    audio2.lang = lang2;
    audio2.rate = 0.8;
    audio2.volume = 1;
    audio2.pitch = 1.0;
    speechSynthesis.speak(audio2);
}

function holdUp() {
    let storedContent = localStorage.getItem('archivesentencestorage') || '';
    let parts = storedContent.split('-------------------------------------------\n');

    if (parts[parts.length - 1].trim() === '') {
        parts.pop();
    }

    if (storedContent === '') {
        localStorage.setItem('archivesentencestorage', 'Ez az első mondat.\n-------------------------------------------\nEz a második mondat.');
    }

    let storedContentReload = localStorage.getItem('archivesentencestorage');
    let partsReload = storedContentReload.split('-------------------------------------------\n');

    if (partsReload[partsReload.length - 1].trim() === '') {
        partsReload.pop();
    }

    currentHoldIndex--;
    if (currentHoldIndex < 0) {
        currentHoldIndex = partsReload.length - 1; // Ugrás az utolsó elemre, ha az elejére értünk
        playRandomSound13();
    }

    let part = partsReload[currentHoldIndex];
    let fileName = `Mondat ${currentHoldIndex + 1}.txt`;

    localStorage.setItem('readpathstorage', fileName);

    selectHoldBlind = part; // A teljes tartalmat tároljuk

    let hungarianlanguage = 0;
    let englishlanguage = 0;

    // Nyelvfelismerés és beszédszintézis
    let magyarEkezetesBetukSzama = 0;
    let esSzavakSzama = 0;
    let theSzavakSzama = 0;

    for (let i = 0; i < part.length; i++) {
        let currentChar = part[i];
        if (/[áéíóöőúüűÁÉÍÓÖŐÚÜŰ]/.test(currentChar)) {
            magyarEkezetesBetukSzama++;
        }
    }

    let szavak = part.split(" ");
    for (let j = 0; j < szavak.length; j++) {
        if (szavak[j] === "és") {
            esSzavakSzama++;
        }
    }

    for (let j = 0; j < szavak.length; j++) {
        if (szavak[j] === "the") {
            theSzavakSzama++;
        }
    }

    if (magyarEkezetesBetukSzama > 0) {
        hungarianlanguage += 40;
    }

    if (magyarEkezetesBetukSzama < 1) {
        englishlanguage += 20;
    }

    if (esSzavakSzama > 0) {
        hungarianlanguage += 35;
    }

    if (theSzavakSzama > 0) {
        englishlanguage += 35;
    }

    let winner = "";
    if (hungarianlanguage > englishlanguage) {
        winner = "hu";
    } else if (hungarianlanguage < englishlanguage) {
        winner = "en";
    }

    console.log('Current Hold Index: ' + (currentHoldIndex + 1));
    var textToRead3 = `A ${currentHoldIndex + 1}. bejegyzés következik.`;
    speechSynthesis.cancel(); // Leállítjuk a korábbi beszédszintézist
    var audio3 = new SpeechSynthesisUtterance(textToRead3);
    speechSynthesis.speak(audio3);

    var textToRead2 = part.substring(0, 50); // A listaelemben megjelenő szövegrészlet
    speechSynthesis.cancel(); // Leállítjuk a korábbi beszédszintézist
    var lang = 'en-ENG';
    if (winner === "hu") {
        lang = 'hu-HUN';
    }
    var lang2 = lang;
    var audio2 = new SpeechSynthesisUtterance(textToRead2);
    audio2.lang = lang2;
    audio2.rate = 0.8;
    audio2.volume = 1;
    audio2.pitch = 1.0;
    speechSynthesis.speak(audio2);
}









// Segédfüggvény: szöveg szintetikus beszédként való lejátszása Promise-szal
function beszelesAsync(szoveg) {
  return new Promise((resolve) => {
    let utterance = new SpeechSynthesisUtterance(szoveg);
    utterance.lang = 'hu-HU';
    utterance.onend = () => resolve();
    speechSynthesis.speak(utterance);
  });
}

// A holdSelect függvény
async function holdSelect() {
  stopSpeaking();

  firstdomload = 0;
  currentHoldIndex = 0;
  origcontent = selectHoldBlind;
  localStorage.setItem('lastbook', selectHoldBlind);

  const undesiredSpecialChars = ['+', '-', '_', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];
  bookname = bookname.split('').map(c => undesiredSpecialChars.includes(c) ? ' ' : c).join('');

  try {
    const message = await waitForContent();
    console.log(message);
  } catch (error) {
    console.error('Hiba történt: ', error);
  }

  legorigabbcontent = origcontent;

  analysis();
  replaceSt();
  removeQuotes();
  replaceMr();
  linebreakreplacement();

  origcontent = legorigabbcontent;

  AIrecognizelanguage(origcontent);

  stopMusic();
  playRandomSound11();
  supervision();

  bookname = bookname.replace(/[()]/g, '');

  console.log('File loaded successfully.');

  if (bookname) {
    fadebookname();
    console.log('Book name:', bookname);
  }

  countSentences();

  holdContainer.style.display = 'none';
  holdopened = 0;

  setTimeout(function() {
  three();
  three();
  one();
  one();
  one();
  textselect();
}, 5000);



  // --- Random szó kiválasztása a selectedtextblock-ból ---
  const textTo = document.getElementById('selectedtextblock').innerText;
  const words = textTo.match(/\b\w{4,}\b/g); // Legalább 4 karakterből álló szavak
  if (!words || words.length === 0) {
    console.log('Nincs értelmes szó a kiválasztott szövegben.');
    return;
  }
  const randomIndex = Math.floor(Math.random() * words.length);
  const randomSzot = words[randomIndex];
  console.log('Kiválasztott random szó:', randomSzot);

  // --- Mondatokra bontás ---
  const sentences = origcontent.match(/[^.!?]+[.!?](?=\s|$)/g);
  if (!sentences) {
    console.log('Nem találhatók mondatok az origcontentben.');
    return;
  }

  // --- Szűrés: mely mondatok tartalmazzák a random szót (kis/nagybetűtől függetlenül) ---
  const regex = new RegExp(`\\b${randomSzot}\\b`, 'i');
  const matchedSentences = sentences.filter(sentence => regex.test(sentence));

  // --- Eredmény kiírása és felolvasás ---
  if (matchedSentences.length > 0) {
    console.log(`Talált mondat(ok) a(z) "${randomSzot}" szóra:`);

    matchedSentences.forEach((sentence) => {
      const index = sentences.indexOf(sentence);
      console.log(`Mondat ${index + 1}: ${sentence.trim()}`);
    });

    if (matchedSentences.length < 4) {
      // Felolvasás számokkal együtt
      for (const sentence of matchedSentences) {
        const index = sentences.indexOf(sentence);
        await beszelesAsync(`Mondat ${index + 1}: ${sentence.trim()}`);
      }
    }

  } else {
    console.log(`Nem található a mondatokban az a szó: "${randomSzot}"`);
  }
}








function holdDown() {
    let storedContent = localStorage.getItem('archivesentencestorage') || '';
    let parts = storedContent.split('-------------------------------------------\n');

    if (parts[parts.length - 1].trim() === '') {
        parts.pop();
    }

    if (storedContent === '') {
        localStorage.setItem('archivesentencestorage', 'Ez az első mondat.\n-------------------------------------------\nEz a második mondat.');
    }

    let storedContentReload = localStorage.getItem('archivesentencestorage');
    let partsReload = storedContentReload.split('-------------------------------------------\n');

    if (partsReload[partsReload.length - 1].trim() === '') {
        partsReload.pop();
    }

    currentHoldIndex++; // Növeljük az indexet a következő elemre
    if (currentHoldIndex >= partsReload.length) {
        currentHoldIndex = 0; // Vissza az első elemre, ha a végére értünk
        playRandomSound13();
    }

    let part = partsReload[currentHoldIndex];
    let fileName = `Mondat ${currentHoldIndex + 1}.txt`;

    localStorage.setItem('readpathstorage', fileName);

    selectHoldBlind = part; // A teljes tartalmat tároljuk

    let hungarianlanguage = 0;
    let englishlanguage = 0;

    // Nyelvfelismerés és beszédszintézis
    let magyarEkezetesBetukSzama = 0;
    let esSzavakSzama = 0;
    let theSzavakSzama = 0;

    for (let i = 0; i < part.length; i++) {
        let currentChar = part[i];
        if (/[áéíóöőúüűÁÉÍÓÖŐÚÜŰ]/.test(currentChar)) {
            magyarEkezetesBetukSzama++;
        }
    }

    let szavak = part.split(" ");
    for (let j = 0; j < szavak.length; j++) {
        if (szavak[j] === "és") {
            esSzavakSzama++;
        }
    }

    for (let j = 0; j < szavak.length; j++) {
        if (szavak[j] === "the") {
            theSzavakSzama++;
        }
    }

    if (magyarEkezetesBetukSzama > 0) {
        hungarianlanguage += 40;
    }

    if (magyarEkezetesBetukSzama < 1) {
        englishlanguage += 20;
    }

    if (esSzavakSzama > 0) {
        hungarianlanguage += 35;
    }

    if (theSzavakSzama > 0) {
        englishlanguage += 35;
    }

    let winner = "";
    if (hungarianlanguage > englishlanguage) {
        winner = "hu";
    } else if (hungarianlanguage < englishlanguage) {
        winner = "en";
    }

    console.log('Current Hold Index: ' + (currentHoldIndex + 1));
    var textToRead = `${currentHoldIndex + 1}. bejegyzés: ${part.substring(0, 150)}`;
    speechSynthesis.cancel(); // Leállítjuk a korábbi beszédszintézist
    var audio = new SpeechSynthesisUtterance(textToRead);
    var lang = 'en-ENG';
    if (winner === "hu") {
        lang = 'hu-HUN';
    }
    audio.lang = lang;
    audio.rate = 0.8;
    audio.volume = 1;
    audio.pitch = 1.0;
    speechSynthesis.speak(audio);
}

function holdUp() {
    let storedContent = localStorage.getItem('archivesentencestorage') || '';
    let parts = storedContent.split('-------------------------------------------\n');

    if (parts[parts.length - 1].trim() === '') {
        parts.pop();
    }

    if (storedContent === '') {
        localStorage.setItem('archivesentencestorage', 'Ez az első mondat.\n-------------------------------------------\nEz a második mondat.');
    }

    let storedContentReload = localStorage.getItem('archivesentencestorage');
    let partsReload = storedContentReload.split('-------------------------------------------\n');

    if (partsReload[partsReload.length - 1].trim() === '') {
        partsReload.pop();
    }

    currentHoldIndex--;
    if (currentHoldIndex < 0) {
        currentHoldIndex = partsReload.length - 1; // Ugrás az utolsó elemre, ha az elejére értünk
        playRandomSound13();
    }

    let part = partsReload[currentHoldIndex];
    let fileName = `Mondat ${currentHoldIndex + 1}.txt`;

    localStorage.setItem('readpathstorage', fileName);

    selectHoldBlind = part; // A teljes tartalmat tároljuk

    let hungarianlanguage = 0;
    let englishlanguage = 0;

    // Nyelvfelismerés és beszédszintézis
    let magyarEkezetesBetukSzama = 0;
    let esSzavakSzama = 0;
    let theSzavakSzama = 0;

    for (let i = 0; i < part.length; i++) {
        let currentChar = part[i];
        if (/[áéíóöőúüűÁÉÍÓÖŐÚÜŰ]/.test(currentChar)) {
            magyarEkezetesBetukSzama++;
        }
    }

    let szavak = part.split(" ");
    for (let j = 0; j < szavak.length; j++) {
        if (szavak[j] === "és") {
            esSzavakSzama++;
        }
    }

    for (let j = 0; j < szavak.length; j++) {
        if (szavak[j] === "the") {
            theSzavakSzama++;
        }
    }

    if (magyarEkezetesBetukSzama > 0) {
        hungarianlanguage += 40;
    }

    if (magyarEkezetesBetukSzama < 1) {
        englishlanguage += 20;
    }

    if (esSzavakSzama > 0) {
        hungarianlanguage += 35;
    }

    if (theSzavakSzama > 0) {
        englishlanguage += 35;
    }

    let winner = "";
    if (hungarianlanguage > englishlanguage) {
        winner = "hu";
    } else if (hungarianlanguage < englishlanguage) {
        winner = "en";
    }

    console.log('Current Hold Index: ' + (currentHoldIndex + 1));
    var textToRead = `${currentHoldIndex + 1}. bejegyzés: ${part.substring(0, 150)}`;
    speechSynthesis.cancel(); // Leállítjuk a korábbi beszédszintézist
    var audio = new SpeechSynthesisUtterance(textToRead);
    var lang = 'en-ENG';
    if (winner === "hu") {
        lang = 'hu-HUN';
    }
    audio.lang = lang;
    audio.rate = 0.8;
    audio.volume = 1;
    audio.pitch = 1.0;
    speechSynthesis.speak(audio);
}








function deletearchivesentencestorage() {
  // Kérjünk jelszót a felhasználótól
  var password = prompt('Kérjük, adja meg a jelszót a törléshez - jelszó a semmi csak enter -:', '');
  
  // Ellenőrizzük a jelszót
  if (password === '') {
    // Ellenőrizzük, hogy létezik-e az archivesentencestorage bejegyzés
    if (localStorage.getItem('archivesentencestorage')) {
      // Töröljük az archivesentencestorage bejegyzést
      localStorage.removeItem('archivesentencestorage');
      alert('Az archivesentencestorage bejegyzés sikeresen törölve lett.');
    } else {
      alert('Nincs archivesentencestorage bejegyzés a localStorage-ban.');
    }
  } else {
    // Ha a jelszó nem stimmel, tájékoztassuk a felhasználót
    alert('Hibás jelszó. A törlés nem hajtható végre.');
  }
}

// A deletearchivesentencestorage függvény meghívása
//deletearchivesentencestorage();


function showarchivesentencestorage() {
  // Lekérjük az archivesentencestorage bejegyzést a localStorage-ból
  const archivesshow = localStorage.getItem('archivesentencestorage');

  if (archivesshow) {
    // Kiírjuk a bejegyzés tartalmát a konzolra
    console.log(archivesshow);
    
    
    
// Példa használat

createComplexPanelfromVar(
    archivesshow,
    50, // X pozíció: 50%
    12, // Y pozíció: 12%
    'a', // Automatikus szélesség
    24 // Betűméret: 24 pixel
)
    
    
    
    
  } else {
    console.log('Nincs archivesentencestorage bejegyzés a localStorage-ban.');
  }
}

// A showarchivesentencestorage függvény meghívása
//showarchivesentencestorage();

function downloadarchivesentencestorage() {
  // Lekérjük az archivesentencestorage bejegyzést a localStorage-ból
  const archivesshow = localStorage.getItem('archivesentencestorage');

  if (archivesshow) {
    // Az aktuális dátum formátumának létrehozása
    randomNumber = rndmaker(1, 100);
    
    const currentDate = new Date().toLocaleDateString('hu-HU').replace(/\./g, '-');

    // Blob objektum létrehozása a letöltendő adatokkal
    const blob = new Blob([archivesshow], { type: 'text/plain' });

    // Blob URL létrehozása
    const url = URL.createObjectURL(blob);

    // Letöltési link létrehozása
    const a = document.createElement('a');
    a.href = url;
    a.download = `archives bookwork_${currentDate}_${randomNumber}.txt`;

    // A letöltési link hozzáadása a dokumentumhoz és a letöltés aktiválása
    document.body.appendChild(a);
    a.click();

    // Az URL és a letöltési link eltávolítása
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    // Sikeres letöltés üzenet
    //alert('Az archivesentencestorage bejegyzés sikeresen letöltve.');
  } else {
    alert('Nincs archivesentencestorage bejegyzés a localStorage-ban.');
  }
}

// A downloadarchivesentencestorage függvény meghívása
// downloadarchivesentencestorage();


//   ---- Meló text akciók vége




// userbookmark eleje

function userbookmarkload() {
	
	sentencesaveslot1 = localStorage.getItem('sentencesaveslot1');
    
    startTypingAnimation('paragraphId', 'divId', 'load sentencesaveslot1: ' + sentencesaveslot1);
	        
            
            currentsentencenumber = ("");
            	currentsentencenumber = sentencesaveslot1;
            //alert(currentsentencenumber);
            setbookmarksentence = sentencesaveslot1;
            
            
                // Frissítjük a számlálót az új mondat sorszámával
    let counter = document.getElementById('counter');
    counter.textContent = currentsentencenumber;

    // Megjelenítjük a bookmark-hoz tartozó mondatot a selectedtextblock-ban
    
    //console.log(origcontent);
    //alert();
    let sentences = origcontent.match(/[^.!?]+(?:\.|!|\?)(?=\s|$)/g);
    if (sentences && sentences.length > setbookmarksentence - 1) {
        let selectedSentence = sentences[setbookmarksentence - 1].trim();
        document.getElementById('selectedtextblock').innerText = selectedSentence;
    }

    // Megjelenítjük a bookmark-hoz tartozó mondatot a contextblock-ban
    let contextSentences = origcontent.match(/[^.!?]+(?:\.|!|\?)(?=\s|$)/g);
    if (contextSentences && contextSentences.length > setbookmarksentence - 1) {
        let selectedSentence = contextSentences[setbookmarksentence - 1].trim();
        document.getElementById('selectedtextblock').innerText = selectedSentence;

        // Előző és következő 2 mondat hozzáadása a contextblock-hoz
        let contextBlockContent = "";
        if (setbookmarksentence > 1) {
            contextBlockContent += contextSentences[setbookmarksentence - 3].trim() + " ";
        }
        contextBlockContent += selectedSentence + " ";
        if (setbookmarksentence < contextSentences.length) {
            contextBlockContent += contextSentences[setbookmarksentence].trim();
        }
        document.getElementById('contextblock').innerText = contextBlockContent;
    }
            
             
             
             setSliderToCurrentSentence();

      if (muteSounds) {
        playany(['snd/button/hitman AI futuristic and simple, soft-sounding switching sound, blip.mp3'], 1);
    }

stopSpeaking();  
                readany = "Betöltve.";
                readanytexthun();

      
            
	}




function userbookmarksave() {
//	alert("sentencesaveslot1");
	sentencesaveslot1 = currentsentencenumber;
	
	localStorage.setItem('sentencesaveslot1', sentencesaveslot1);

                stopSpeaking();  
                readany = "Mentve.";
                readanytexthun();
                startTypingAnimation('paragraphId', 'divId', 'sentencesaveslot1 ' + sentencesaveslot1);
	
	
if (muteSounds) {
        playany(['snd/button/AI Voice Generator & Text to Speech ElevenLabs_1718968793772.mp3', 'snd/button/AI Voice Generator & Text to Speech ElevenLabs_1718968741023.mp3'], 1);
    }


	}
	
// userbookmark vége



//let bookname = 'abc.txt';
//let currentsentencenumber = 33;





function bookmarksave() {
    if (bookname === "archive") {
        //console.log("A funkció nem fut le az 'archive' könyvnél.");
        return; // Kilép a függvényből
    }

    // Aktuális dátum és idő lekérése
    let currentDate = new Date();
    let formattedDate = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}-${String(currentDate.getDate()).padStart(2, '0')} ${String(currentDate.getHours()).padStart(2, '0')}:${String(currentDate.getMinutes()).padStart(2, '0')}`;
    
    // Ellenőrizzük, hogy van-e már ilyen könyv a localStorage-ban
    let bookmarks = localStorage.getItem('bookmarks');
    
    if (bookmarks) {
        // Ha van, akkor JSON-ba konvertáljuk és frissítjük az adatokat
        bookmarks = JSON.parse(bookmarks);
        
        // Keresünk egy meglévő könyvet
        let existingBook = bookmarks.find(book => book.bookname === bookname);
        
        if (existingBook) {
            // Ha van ilyen könyv, akkor frissítjük a mondat számát és az időt
            existingBook.currentsentencenumber = currentsentencenumber;
            existingBook.savedDate = formattedDate;
        } else {
            // Ha nincs ilyen könyv, akkor hozzáadjuk az újat
            bookmarks.push({ bookname, currentsentencenumber, savedDate: formattedDate });
        }
        
        // Visszaírjuk a frissített listát a localStorage-ba
        localStorage.setItem('bookmarks', JSON.stringify(bookmarks));
    } else {
        // Ha nincs még bookmark, akkor létrehozunk egy új listát
        localStorage.setItem('bookmarks', JSON.stringify([{ bookname, currentsentencenumber, savedDate: formattedDate }]));
    }
    
    console.log(`Mentve: ${bookname}, mondat száma: ${currentsentencenumber}, idő: ${formattedDate}`);
}






function bookmarkload(booknameToLoad) {
    if (booknameToLoad === "archive") {
       // console.log("A funkció nem fut le az 'archive' könyvnél.");
       
       currentsentencenumber = 1;
            setSliderToCurrentSentence();
            if (displaysentence) {
                document.getElementById('selectedtextblock').innerText = displaysentence; // Az új kiválasztott mondat megjelenítése
                
            }
       updateContextBlock();
       
       
       //odaugrik sehova
       
       playany(['snd/Mobile app video game - fantasy magic - rounded menu select Soundsnap.mp3'], 1);
       
  
       
       
        return; // Kilép a függvényből
    }

    let bookmarks = localStorage.getItem('bookmarks');
    
    if (bookmarks) {
        bookmarks = JSON.parse(bookmarks);
        
        // Keresünk egy meglévő könyvet
        let loadedBookmark = bookmarks.find(book => book.bookname === booknameToLoad);
        
        if (loadedBookmark) {
            currentsentencenumber = loadedBookmark.currentsentencenumber;
            console.log(`Betöltve: ${booknameToLoad}, mondat száma: ${currentsentencenumber}, utoljára mentve: ${loadedBookmark.savedDate}`);
  

            startTypingAnimation('paragraphId', 'divId', 'könyvjelző mondat száma: ' + currentsentencenumber + '   utoljára mentve: ' + loadedBookmark.savedDate);
            
            //currentsentencenumber = randomSentenceNumber;

            displaysentence = getSelectedSentence(currentsentencenumber); // Az új kiválasztott mondat lekérése

            if (displaysentence) {
                document.getElementById('selectedtextblock').innerText = displaysentence; // Az új kiválasztott mondat megjelenítése
            }

            updateContextBlock(); // Frissítjük a kontextus blokkot az új kiválasztott mondat körül
            document.getElementById('counter').textContent = currentsentencenumber; // Frissítjük a számlálót az új mondat sorszámával
            setSliderToCurrentSentence(); // Frissítjük a slidert is
            // alert(currentsentencenumber);
            
        } else {
            console.log(`Bookmarkload: Nincs ilyen könyv még: ${booknameToLoad}`);
            currentsentencenumber = 1;

            displaysentence = getSelectedSentence(currentsentencenumber); // Az új kiválasztott mondat lekérése

            if (displaysentence) {
                document.getElementById('selectedtextblock').innerText = displaysentence; // Az új kiválasztott mondat megjelenítése
            }

            updateContextBlock(); // Frissítjük a kontextus blokkot az új kiválasztott mondat körül
            document.getElementById('counter').textContent = currentsentencenumber; // Frissítjük a számlálót az új mondat sorszámával
            setSliderToCurrentSentence(); // Frissítjük a slidert is
        }
    } else {
        console.log('Nincsenek könyvjelzők.');
    }
}



function bookmarkdeleteall() {
    // Kitöröljük az egész könyvjelző listát
    localStorage.removeItem('bookmarks');
    alert();
    console.log('Az összes könyvjelző törlése sikeres!');
}

function bookmarkallsave() {
    // Aktuális dátum és idő lekérése
    let currentDate = new Date();
    let formattedDate = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}-${String(currentDate.getDate()).padStart(2, '0')}_${String(currentDate.getHours()).padStart(2, '0')}-${String(currentDate.getMinutes()).padStart(2, '0')}`;
    
    // Ellenőrizzük, hogy van-e könyvjelző lista
    let bookmarks = localStorage.getItem('bookmarks');
    
    if (bookmarks) {
        bookmarks = JSON.parse(bookmarks);
        
        // A lista tartalmát szöveggé alakítjuk
        let textContent = '';
        bookmarks.forEach(bookmark => {
            textContent += `Könyv: ${bookmark.bookname}, Mondat száma: ${bookmark.currentsentencenumber}, Utoljára mentve: ${bookmark.savedDate}\n`;
        });
        
        // Blob létrehozása a szövegből
        let blob = new Blob([textContent], { type: 'text/plain' });
        
        // Fájl neve az aktuális dátummal
        let filename = `bookmarks_${formattedDate}.txt`;
        
        // Fájl letöltése
        let link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        
        console.log(`Könyvjelző lista mentve: ${filename}`);
    } else {
        console.log('Nincsenek könyvjelzők.');
    }
}

// Tesztelés
// bookmarksave(); // Mentés
// bookmarkload(bookname); // Betöltés
// bookmarkallsave(); // Lista mentése fájlba
// bookmarkdeleteall(); // Összes törlése

//Írd újra az egész bookmarkallshow funkciót, és az ablak és gombok létrehozása ilyenforma módszer legyen:

function createScriptButton(text, onClick, styles) {
  const button = document.createElement("button");
  button.textContent = text;
  button.classList.add("scriptbutton");
  button.id = `button-${text.replace(/\s+/g, '-').toLowerCase()}`; 
  Object.assign(button.style, styles);
  
  // Eseménykezelő a kék effekthez
  button.addEventListener("click", function(event) {
    event.target.style.background = 'blue';
    event.target.style.color = 'white';
    
    // A kék effekt késleltetett visszaállítása
    setTimeout(function() {
      event.target.style.background = '';
      event.target.style.color = '';
    }, 200); // 200 ms múlva visszaállítja az eredeti színt
    
    // Az eredeti onClick eseménykezelő meghívása
    onClick();
  });
  
  return button;
}

function createScriptDiv(content, styles) {
  const div = document.createElement("div");
  div.innerHTML = content;
  Object.assign(div.style, styles);
  return div;
}

function bookmarkallshow() {
    // Létrehozunk egy új ablakot
    let win = window.open('', '_blank', 'width=600,height=450');
    
    // Ablak tartalmának létrehozása
    win.document.write('<html><head><title>Könyvjelzők</title><style>body { font-family: Arial, sans-serif; }</style></head><body>');
    
    // Könyvjelző lista betöltése
    let bookmarks = localStorage.getItem('bookmarks');
    
    if (bookmarks) {
        bookmarks = JSON.parse(bookmarks);
        
        // Lista rendezése és megjelenítése
        let bookmarkList = createScriptDiv('', { height: '300px', overflowY: 'auto', padding: '10px', border: '1px solid #ccc' });
        bookmarks.sort((a, b) => {
            return new Date(b.savedDate.replace(' ', 'T')) - new Date(a.savedDate.replace(' ', 'T'));
        });
        bookmarks.forEach(bookmark => {
            let item = document.createElement('div');
            item.innerHTML = `
                Könyv: ${bookmark.bookname}, Mondat száma: ${bookmark.currentsentencenumber}, Utoljára mentve: ${bookmark.savedDate}
                <input type="text" value="${bookmark.bookname}" data-bookname="${bookmark.bookname}">
                <input type="number" value="${bookmark.currentsentencenumber}" data-bookname="${bookmark.bookname}">
                <button class="update">Frissítés</button>
                <button class="delete">Törlés</button>
            `;
            bookmarkList.appendChild(item);
        });
        win.document.body.appendChild(bookmarkList);
        
        // Gombok létrehozása
        let saveToLocalStorageButton = createScriptButton('Mentés a localStorage-ba', function() {
            // Lista frissítése a localStorage-ban
            let updatedBookmarks = [];
            let inputs = bookmarkList.querySelectorAll('input');
            for (let i = 0; i < inputs.length; i += 2) {
                let bookname = inputs[i].value;
                let currentsentencenumber = inputs[i + 1].value;
                updatedBookmarks.push({ bookname, currentsentencenumber, savedDate: bookmarks.find(b => b.bookname === bookname).savedDate });
            }
            localStorage.setItem('bookmarks', JSON.stringify(updatedBookmarks));
            alert('Mentve a localStorage-ba!');
        }, { position: 'absolute', top: '320px', left: '10px' });
        win.document.body.appendChild(saveToLocalStorageButton);
        
        let saveToFileButton = createScriptButton('Mentés fájlba', function() {
    // Lista mentése fájlba
    let textContent = '';
    bookmarks.forEach(bookmark => {
        textContent += `Könyv: ${bookmark.bookname}, Mondat száma: ${bookmark.currentsentencenumber}, Utoljára mentve: ${bookmark.savedDate}\n`;
    });
    let blob = new Blob([textContent], { type: 'text/plain' });
    
    // Aktuális dátum és idő beillesztése a fájl nevébe
    let now = new Date();
    let year = now.getFullYear();
    let month = (now.getMonth() + 1).toString().padStart(2, '0');
    let day = now.getDate().toString().padStart(2, '0');
    let hour = now.getHours().toString().padStart(2, '0');
    let minute = now.getMinutes().toString().padStart(2, '0');
    let filename = `bookmarks_${year}${month}${day}_${hour}${minute}.txt`;
    
    let link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
    alert('Mentve fájlba!');
}, { position: 'absolute', top: '320px', left: '150px' });
win.document.body.appendChild(saveToFileButton);

        
        let deleteAllButton = createScriptButton('Összes törlése', function() {
    // Saját megerősítő ablak létrehozása
    let confirmDiv = document.createElement('div');
    confirmDiv.style.position = 'fixed';
    confirmDiv.style.top = '50%';
    confirmDiv.style.left = '50%';
    confirmDiv.style.transform = 'translate(-50%, -50%)';
    confirmDiv.style.background = 'white';
    confirmDiv.style.padding = '20px';
    confirmDiv.style.borderRadius = '10px';
    confirmDiv.style.boxShadow = '0px 0px 10px rgba(0,0,0,0.5)';
    confirmDiv.style.zIndex = '1000';

    let confirmText = document.createElement('p');
    confirmText.textContent = 'Biztosan törli az összes könyvjelzőt?';

    let yesButton = document.createElement('button');
    yesButton.textContent = 'Igen';
    yesButton.style.marginRight = '10px';

    let noButton = document.createElement('button');
    noButton.textContent = 'Nem';

    confirmDiv.appendChild(confirmText);
    confirmDiv.appendChild(yesButton);
    confirmDiv.appendChild(noButton);

    win.document.body.appendChild(confirmDiv);

    // Eseménykezelők a gombokhoz
    yesButton.addEventListener('click', function() {
        localStorage.removeItem('bookmarks');
        alert('Összes törlése sikeres!');
        win.close();
        confirmDiv.remove(); // A megerősítő ablak eltávolítása
    });

    noButton.addEventListener('click', function() {
        confirmDiv.remove(); // A megerősítő ablak eltávolítása
    });
}, { position: 'absolute', top: '320px', left: '290px' });
win.document.body.appendChild(deleteAllButton);

        
        // Frissítés és törlés gombok eseménykezelői
        let updateButtons = bookmarkList.querySelectorAll('.update');
        let deleteButtons = bookmarkList.querySelectorAll('.delete');
        
        updateButtons.forEach(button => {
            button.addEventListener('click', function() {
                let bookname = button.parentNode.querySelector('input[type="text"]').value;
                let currentsentencenumber = button.parentNode.querySelector('input[type="number"]').value;
                let bookmarks = JSON.parse(localStorage.getItem('bookmarks'));
                let existingBook = bookmarks.find(book => book.bookname === bookname);
                if (existingBook) {
                    existingBook.currentsentencenumber = currentsentencenumber;
                }
                localStorage.setItem('bookmarks', JSON.stringify(bookmarks));
                alert('Frissítve!');
            });
        });
        
        deleteButtons.forEach(button => {
            button.addEventListener('click', function() {
                let bookname = button.parentNode.querySelector('input[type="text"]').value;
                let bookmarks = JSON.parse(localStorage.getItem('bookmarks'));
                bookmarks = bookmarks.filter(book => book.bookname !== bookname);
                localStorage.setItem('bookmarks', JSON.stringify(bookmarks));
                button.parentNode.remove();
                alert('Törölve!');
            });
        });
        
        // Kék effekt hozzáadása a frissítés és törlés gombokhoz is
        updateButtons.forEach(button => {
            button.addEventListener('click', function(event) {
            
                event.target.style.background = 'blue';
                event.target.style.color = 'white';
                setTimeout(function() {
                  event.target.style.background = '';
                  event.target.style.color = '';
                }, 200);
            }, true); // true: bubbling, hogy ne zavarja a korábbi eseménykezelőket
        });
        
        deleteButtons.forEach(button => {
            button.addEventListener('click', function(event) {
                event.target.style.background = 'blue';
                event.target.style.color = 'white';
                setTimeout(function() {
                  event.target.style.background = '';
                  event.target.style.color = '';
                }, 200);
            }, true); // true: bubbling, hogy ne zavarja a korábbi eseménykezelőket
        });
    } else {
        win.document.body.innerHTML += 'Nincsenek könyvjelzők.';
        playany(['snd/Zapsplat High tech beep with reverb 4.mp3'], 1);
    }
    
    win.document.write('</body></html>');
    win.document.close();
}

// Példa használat
// bookmarkallshow()









// külön funkció betölteni

function fileBookmarkBetolt() {
    // Fájl kiválasztása
    let fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.txt';
    fileInput.onchange = function() {
        let file = fileInput.files[0];
        let reader = new FileReader();
        reader.onload = function(e) {
            let fileContent = e.target.result;
            let lines = fileContent.split('\n');
            let loadedBookmarks = [];

            lines.forEach(line => {
                if (line.trim() !== '') {
                    let parts = line.split(', ');
                    let bookname = parts[0].split(': ')[1];
                    let currentsentencenumber = parseInt(parts[1].split(': ')[1]);
                    let savedDate = parts[2].split(': ')[1];
                    loadedBookmarks.push({ bookname, currentsentencenumber, savedDate });
                }
            });

            // A betöltött lista mentése a localStorage-ba
            localStorage.setItem('bookmarks', JSON.stringify(loadedBookmarks));
            //alert('Betöltve a fájlból!');
            
            bookmarkallshow();
            
            
        };
        reader.readAsText(file);
    };
    fileInput.click();
}

// Példa használat
//fileBookmarkBetolt();





//




//    ----   Random oldalra vagyis mondatra , random mondatra

function randomSentence() {
//	playRandomSound11();

//optionsApopupButtonFunction();

//playany(['snd/You searched for notify Page 2 of 14 ZapSplat - Download free sound effects_1744032397551.mp3', 'snd/Computer Alert 04.mp3', 'snd/You searched for notify Page 2 of 14 ZapSplat - Download free sound effects_1744032448138.mp3'], 1);


gamePlaySound(['snd/button/Page 18 Search Smooth Soundsnap.mp3', 'snd/button/Smooth Soundsnap1.mp3'], 1);




	stopSpeaking();  
	//alert(allsentencenumber);
    // A véletlen szám soha ne legyen nulla, és ha a generált szám
    // véletlenül nulla lenne, akkor újra kell választani

    // let allsentencenumber = 100; // vagy bármilyen más érték, ami a generált mondatok teljes számát jelöli
    let randomSentenceNumber = 0;

    while (randomSentenceNumber === 0) {
        randomSentenceNumber = Math.floor(Math.random() * allsentencenumber);
    }

    currentsentencenumber = randomSentenceNumber;

    displaysentence = getSelectedSentence(currentsentencenumber); // Az új kiválasztott mondat lekérése

    if (displaysentence) {
        document.getElementById('selectedtextblock').innerText = displaysentence; // Az új kiválasztott mondat megjelenítése
    }

    updateContextBlock(); // Frissítjük a kontextus blokkot az új kiválasztott mondat körül
    document.getElementById('counter').textContent = currentsentencenumber; // Frissítjük a számlálót az új mondat sorszámával
    setSliderToCurrentSentence(); // Frissítjük a slidert is
    
    
  
  let readpercentage = Math.round((currentsentencenumber / allsentencenumber) * 100);
        readpercentage = (readpercentage + " százalék. ");
        
       // alert(readpercentage + " ");	
       
       readUniversal(readpercentage + " ", "hu-HU");

       
       
//    var textToRead = (readpercentage + " ");
//	readanytexthun(textToRead);
    
    
    //readTextinfinite();
   readText();
}



///////////

function randomSentenceV2() {
    // 1. Lejátszik egy "simító" hangot (Smooth Soundsnap), és leállítja az esetleges felolvasást.
    gamePlaySound(
        ['snd/button/Page 18 Search Smooth Soundsnap.mp3', 'snd/button/Smooth Soundsnap1.mp3'], 
        1
    );

    stopSpeaking();

    // 2. Véletlen mondat sorszámának generálása (soha nem lehet 0).
    // A 'allsentencenumber' változónak (ami feltételezhetően a mondatok teljes számát jelöli) 
    // globálisan elérhetőnek kell lennie, vagy paraméterként átadni.
    
    let randomSentenceNumber = 0;

    while (randomSentenceNumber === 0) {
        // A Math.floor(Math.random() * allsentencenumber) 0 és (allsentencenumber - 1) közötti értéket ad vissza.
        // Ha a sorszámok 1-től indulnak, érdemes lehet +1-et hozzáadni a ciklus után:
        // randomSentenceNumber = Math.floor(Math.random() * allsentencenumber) + 1;
        // Jelenleg a kód a 0-t tiltja, így a generált érték 1 és (allsentencenumber - 1) között lesz.
        randomSentenceNumber = Math.floor(Math.random() * allsentencenumber);
    }

    currentsentencenumber = randomSentenceNumber;

    // 3. A kiválasztott mondat lekérése és megjelenítése.
    let displaysentence = getSelectedSentence(currentsentencenumber); 

    if (displaysentence) {
        document.getElementById('selectedtextblock').innerText = displaysentence;
    }

    // 4. Felhasználói felület frissítése.
    updateContextBlock(); // Frissíti a kontextus blokkot az új kiválasztott mondat körül.
    document.getElementById('counter').textContent = currentsentencenumber; // Frissíti a számlálót.
    setSliderToCurrentSentence(); // Frissíti a slidert a jelenlegi mondat sorszámával.
    
    // 5. Olvasási progressz (százalék) számítása.
    // Megjegyzés: A 'readpercentage' változó számítása és hozzárendelése a stringhez jelenleg nincs felhasználva 
    // a felolvasásban, de a kód tartalmazza.
    let readpercentage = Math.round((currentsentencenumber / allsentencenumber) * 100);
    readpercentage = (readpercentage + " százalék. ");
        
    // 6. A kiválasztott mondat felolvasásának elindítása.
    readTextWithNumberRepeat();
    createRandomSentenceSetupWindow();
}








function readTextWithNumberRepeat() {
    // LocalStorage-ból töltjük be az ismétlések számát
    let timesLeft = parseInt(localStorage.getItem('repeatCount'), 10);
    if (isNaN(timesLeft) || timesLeft < 1) {
        console.warn('Invalid repeatCount in localStorage. Using 2 as default.');
        timesLeft = 2;
        localStorage.setItem('repeatCount', timesLeft);
    }

    // LocalStorage-ból delayRatio és olvassebesseg
    let delayRatio = parseFloat(localStorage.getItem('delayRatio'));
    if (isNaN(delayRatio)) delayRatio = 0.6;

    let olvassebesseg = parseFloat(localStorage.getItem('olvassebesseg'));
    if (isNaN(olvassebesseg) || olvassebesseg <= 0) olvassebesseg = 1;

    function recursiveRead(remaining) {
        if (remaining <= 0) return;

        threenumberrepeat();

        setTimeout(() => {
            var currentText = document.getElementById('selectedtextblock').innerText;

            if (currentText.length > 1000) {
                startTypingAnimation('paragraphId', 'divId', 'A felolvasandó szöveg túl hosszú (több mint 1000 karakter).');
                return;
            }

            var prefixText = "";
            if (currentText.includes('?')) {
                prefixText = "Kérdő mondat. ";
            } else if (currentText.includes('!')) {
                prefixText = "Felkiáltó mondat. ";
            }

            var textToSpeak = prefixText + currentText;
            var langCode = (winner === "hu") ? 'hu-HUN' : 'en-ENG';

            console.log(`[${new Date().toLocaleString()}] [${bookname}] mondatszám: ${currentsentencenumber} - szöveg: ${currentText}`);

            let logEntry = {
                datetime: new Date().toISOString(),
                bookname: bookname,
                mondatszám: currentsentencenumber,
                szöveg: currentText
            };
            let logs = JSON.parse(localStorage.getItem('readTextLogs') || '[]');
            logs.push(logEntry);
            localStorage.setItem('readTextLogs', JSON.stringify(logs));

            speechSynthesis.cancel();
            var utterance = new SpeechSynthesisUtterance(textToSpeak);
            utterance.lang = langCode;
            utterance.rate = olvassebesseg;
            utterance.volume = 1;
            utterance.pitch = 1.0;

            utterance.onend = function() {
                // Véletlen késleltetés delayRatio alapján
                let timeoutDelay;
                if (Math.random() < delayRatio) {
                    timeoutDelay = 0; // nodelay
                } else {
                    let minDelay = 1.5;
                    let maxDelay = 2.0;
                    timeoutDelay = Math.random() * (maxDelay - minDelay) + minDelay;
                }

                console.log("Késleltetés: " + timeoutDelay + " másodperc");

                setTimeout(() => {
                    recursiveRead(remaining - 1);
                }, timeoutDelay * 1000);
            };

            utterance.onerror = function() {
                console.error('Speech synthesis hiba.');
            };

            speechSynthesis.speak(utterance);
        }, 100);
    }

    recursiveRead(timesLeft);
}






function createRandomSentenceSetupWindow() {
    // 1. Meglévő ablak ellenőrzése
    if (document.getElementById('randomsentencev2setup')) {
        return;
    }

    const overlayDiv = document.createElement('div');
    overlayDiv.id = 'randomsentencev2setup';
    overlayDiv.style.position = 'fixed';
    overlayDiv.style.width = '400px';
    // Mivel a két gomb kikerült, visszatérhetünk a 400px magassághoz
    overlayDiv.style.height = '400px'; 
    overlayDiv.style.top = '50%';
    overlayDiv.style.left = '50%';
    overlayDiv.style.transform = 'translate(-50%, -50%)';
    overlayDiv.style.backgroundColor = 'rgba(30, 45, 60, 0.95)';
    overlayDiv.style.borderRadius = '10px';
    overlayDiv.style.zIndex = '30000';
    overlayDiv.style.boxShadow = '0 0 10px rgba(0,0,0,0.7)';
    overlayDiv.style.padding = '15px';
    overlayDiv.style.boxSizing = 'border-box';
    overlayDiv.style.color = 'white';
    overlayDiv.style.fontFamily = 'Arial, sans-serif';
    overlayDiv.style.display = 'flex';
    overlayDiv.style.flexDirection = 'column';

    // Cím
    const title = document.createElement('h3');
    title.innerText = 'Random Sentence V2 Setup';
    title.style.marginTop = '0';
    title.style.marginBottom = '20px';
    overlayDiv.appendChild(title);

    // --- Ismétlésszám Input és Mentés gomb beállítása ---
    const label = document.createElement('label');
    label.innerText = 'Ismétlések száma: ';
    label.htmlFor = 'repeatCountInput';

    const input = document.createElement('input');
    input.type = 'number';
    input.id = 'repeatCountInput';
    input.min = '1';
    let savedRepeatCount = parseInt(localStorage.getItem('repeatCount'), 10);
    if (isNaN(savedRepeatCount) || savedRepeatCount < 1) savedRepeatCount = 2;
    input.value = savedRepeatCount;
    input.style.marginLeft = '10px';
    input.style.width = '60px';
    input.style.borderRadius = '6px';
    input.style.border = 'none';
    input.style.padding = '5px';

    const saveButton = document.createElement('button');
    saveButton.innerText = 'Mentés';
    saveButton.style.padding = '8px 16px';
    saveButton.style.borderRadius = '6px';
    saveButton.style.border = 'none';
    saveButton.style.backgroundColor = 'rgba(70, 90, 110, 0.9)';
    saveButton.style.color = 'white';
    saveButton.style.fontWeight = 'bold';
    saveButton.style.cursor = 'pointer';
    saveButton.onmouseenter = () => {
        saveButton.style.backgroundColor = 'rgba(100, 120, 140, 1)';
    };
    saveButton.onmouseleave = () => {
        saveButton.style.backgroundColor = 'rgba(70, 90, 110, 0.9)';
    };

    // Konténer a label + input + Mentés gomb számára egy sorban
    const inputSaveContainer = document.createElement('div');
    inputSaveContainer.style.display = 'flex';
    inputSaveContainer.style.alignItems = 'center';
    inputSaveContainer.style.gap = '10px';
    // Eltávolítva a 'marginBottom', mert most közvetlenül a textarea következik
    inputSaveContainer.appendChild(label);
    inputSaveContainer.appendChild(input);
    inputSaveContainer.appendChild(saveButton);
    overlayDiv.appendChild(inputSaveContainer);

    // --- Napló Textarea ---
    const logTextarea = document.createElement('textarea');
    logTextarea.style.flexGrow = '1';
    logTextarea.style.marginTop = '15px'; // Helyet ad az InputSaveContainernek
    logTextarea.style.backgroundColor = 'rgba(50, 65, 80, 0.85)';
    logTextarea.style.color = 'white';
    logTextarea.style.borderRadius = '6px';
    logTextarea.style.border = 'none';
    logTextarea.style.padding = '10px';
    logTextarea.style.fontFamily = 'monospace';
    logTextarea.style.fontSize = '12px';
    logTextarea.readOnly = true;
    overlayDiv.appendChild(logTextarea);

    // --- Segédfunkciók és Eseménykezelők ---
    function updateLogTextarea() {
        let logs = JSON.parse(localStorage.getItem('readTextLogs') || '[]');
        if (logs.length > 100) {
            logs = logs.slice(logs.length - 100);
        }
        let filteredLogs = logs.map(entry => {
            let copy = {...entry};
            delete copy.bookname;
            return JSON.stringify(copy);
        // Szintaktikai hiba javítva: sortörés '\n'-nel
        }).join('\n');
        
        logTextarea.value = filteredLogs || "(Nincs naplózott adat)";
        logTextarea.scrollTop = logTextarea.scrollHeight; // Görgetés az utolsó sorhoz
    }

    // Folyamatos frissítés bekapcsolása (1 másodpercenként)
    const logInterval = setInterval(updateLogTextarea, 1000);

    // Mentés gomb eseménykezelője (ismétlésszám mentése)
    saveButton.onclick = () => {
        const repeatCount = parseInt(input.value, 10);
        if (isNaN(repeatCount) || repeatCount < 1) {
            alert("Kérlek adj meg egy 1-nél nagyobb számot!");
            return;
        }
        localStorage.setItem('repeatCount', repeatCount);
       // alert("Ismétlésszám mentve: " + repeatCount);
       gamePlaySound(['snd/Data Alert Digi GFX019208.mp3', 'snd/Data Alert Digi GFX019208.mp3'], 1);
 readTextinfinite();  
    };


    // Bezárás gomb
    const closeButton = document.createElement('button');
    closeButton.innerText = 'Bezárás';
    closeButton.style.position = 'absolute';
    closeButton.style.top = '10px';
    closeButton.style.right = '10px';
    closeButton.style.cursor = 'pointer';
    closeButton.style.borderRadius = '6px';
    closeButton.style.border = 'none';
    closeButton.style.padding = '6px 12px';
    closeButton.style.backgroundColor = 'rgba(70, 90, 110, 0.9)';
    closeButton.style.color = 'white';
    closeButton.style.fontWeight = 'bold';
    closeButton.onmouseenter = () => {
        closeButton.style.backgroundColor = 'rgba(100, 120, 140, 1)';
    };
    closeButton.onmouseleave = () => {
        closeButton.style.backgroundColor = 'rgba(70, 90, 110, 0.9)';
    };
    closeButton.onclick = () => {
        // KIEMELTEN FONTOS: Az időzítő leállítása
        clearInterval(logInterval);
        document.body.removeChild(overlayDiv);
    };
    overlayDiv.appendChild(closeButton);

    // Első frissítés és DOM-hoz adás
    updateLogTextarea();
    document.body.appendChild(overlayDiv);
}




//ooooo







// ----- Radio yeah   ---   https://streamurl.link/
let audio;
  const urls = [
   'https://lwrcomedy-zaklwr10.radioca.st/stream',
   'http://listen.181fm.com/181-comedy_128k.mp3',
   'https://cast2.asurahosting.com/proxy/britcom1/stream',
    'https://radio4.vip-radios.fm:18054/stream-128kmp3-BuddhaBeach',//yoga best Buddha Beach
    'https://chilloutzone.stream.laut.fm/chilloutzone',
    'http://salalondon.ddns.net:8002/;stream.mp3',
    'https://stream.0nlineradio.com/chillout',
    'http://stream.mercyradio.eu/kabare.mp3',
    'https://streaming.silvacast.com/VIBEFM.mp3',
    'https://sex-high.rautemusik.fm/',
    'https://stream.infostart.hu/stream',
    'https://sj-1.scenesat.com/scenesatmax',
    'https://ais-sa2.cdnstream1.com/1373_128',
    'https://kathy.torontocast.com:1825/stream',
    'http://radio.dawnshadow.se:8000/stream',
        'https://stream.rcs.revma.com/zfad8vm4srhvv.mp3',
'http://stream.rtlradio.de/plusedm/mp3-192/',
    'https://0n-electro.radionetz.de/0n-electro.mp3',
    'http://jking.cdnstream1.com/b22139_128mp3',
    'http://radio.wanderingsheep.tv:8021/christianjazz',
    'https://radio4.vip-radios.fm:18027/stream-128kmp3-YogaChill',
    'https://streamssl.chilltrax.com/index.html',
    'https://moviedance.stream.laut.fm/moviedance',
    'https://spacetravelradio.de:2893/stream/2/',
    'https://nature-rex.radioca.st/stream',
    'https://stream.adradio.ro/ambiento',
    'https://ambientartsound.skydesignltd.com:8000/radio.mp3',
    'https://stream.zeno.fm/00rt0rdm7k8uv',
    'https://jazzy.hu/jazzy.mp3'
//'aaa',
//'aaa',
//'aaa',
//'aaa',
//'aaa',
//'aaa',
//'aaa',
  ];




var radioTts;
var volumeSlider;
var radioAudio;





function halkabbradio() {
  if (currentVolume > 0) {
      currentVolume -= 5;
      if (currentVolume < 0) currentVolume = 0;
      updateVolume();
      readUniversal(currentVolume, "hu-HU");
    }
 }   
 
 function hangosabbradio() {
 if (currentVolume < 100) {
      currentVolume += 5;
      if (currentVolume > 100) currentVolume = 100;
      updateVolume();
      readUniversal(currentVolume, "hu-HU");
    }
 }   
    
    function tomparadio() {
 
      currentVolume = 3;
      
      updateVolume();
      readUniversal(currentVolume, "hu-HU");
    
 }   
    
function playRadio() {
	
	stopPlayany();
	radioplayer = 1;
	playany(['snd/Radio Tuning Sound Effects Download SFX Library Soundsniiiiiap.mp3', 'snd/Radio Tuning Sound Effects Download SFX Library Soundsnap.mp3', 'snd/Radio Search Sound Effects Download SFX Library Soundsnap_1744126595863.mp3', 'snd/Radio Search Sound Effects Download SFX Library Soundsnap_1744126576029.mp3'], 1);
	
	document.getElementById("volume-slider-container").style.display = "block";
	
  const randomIndex = Math.floor(Math.random() * urls.length);
  const selectedUrl = urls[randomIndex];
  radioTts = `${selectedUrl.replace('https://', ' ')}`;
  radioado = radioTts;
  
  
  radioAudio = new Audio(selectedUrl);
  radioAudio.volume = 0.25; // Hangerő beállítása (0.5 = 50% hangerő)
  
  // Utterance
  const synth = window.speechSynthesis;
  const utterance = new SpeechSynthesisUtterance(radioTts);
  
  
  utterance.onend = function() {
    radioAudio.play(); // Az utterance végén elindítja a rádió lejátszását
  };
  
  var randomRate = 0.6 + Math.random() * 0.2;
utterance.rate = randomRate;

  
  synth.speak(utterance);
  
  // Felirat
  const searchLabel = createFadeInLabel(`playing: ${selectedUrl}`, {
    position: "absolute",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    fontSize: "25px",
    fontWeight: "bold",
    color: "rgba(215, 205, 205, 0.5)",
    textShadow: "2px 2px 4px rgba(0, 0, 0, 0.5)",
    zIndex: 0
  });
  
  // Hangerő beállítása
  volumeSlider = document.getElementById("volume-slider");
  volumeSlider.addEventListener("input", function() {
    radioAudio.volume = volumeSlider.value / 100;
  });
}

function stopRadio() {
	stopPlayany();
	
  if (radioAudio) {
  	
  playany(['snd/Radio Search Sound Effects Download SFX Library Soundsnap_1744126557442.mp3', 'snd/Radio Search Sound Effects Download SFX Library Soundsnap.mp3'], 1);
  
  	radioplayer = 0;
    radioAudio.pause();
    radioAudio.currentTime = 0;
    
    removelabel("playing:");
    
    // Hangerő visszaállítása
    volumeSlider.value = 50;
    
    // Slider eltüntetése
    document.getElementById("volume-slider-container").style.display = "none";
  }
}

// radio gomb gombnzomaskor
function hatterradiogombra() {
  const jazzyUrl = 'http://jking.cdnstream1.com/b22139_128mp3';

  // Ha már szól valami, leállítjuk
  if (window.radioAudio) {
    window.radioAudio.pause();
    window.radioAudio = null;
  }

  window.radioAudio = new Audio(jazzyUrl);
  const startVolume = 0.05; // Kezdő hangerő
  window.radioAudio.volume = startVolume;

  // 1. Lépés: 6 másodperc várakozás az indításig (ahogy eddig is volt)
  setTimeout(() => {
    window.radioAudio.play().then(() => {
      console.log('Háttérrádió elindult. 20 másodperces lejátszás kezdődik...');

      // 2. Lépés: 20 másodperc lejátszás után elindítjuk a Fade Out-ot
      setTimeout(() => {
        const fadeDuration = 3000; // 3 másodperc alatt halkuljon el teljesen
        const intervalTime = 100;  // 100 ezredmásodpercenként csökkentjük a hangerőt
        const steps = fadeDuration / intervalTime;
        const volumeStep = startVolume / steps;

        const fadeInterval = setInterval(() => {
          if (window.radioAudio && window.radioAudio.volume > volumeStep) {
            window.radioAudio.volume -= volumeStep;
          } else {
            // Ha elértük a 0-t, megállítjuk és takarítunk
            clearInterval(fadeInterval);
            if (window.radioAudio) {
              window.radioAudio.pause();
              window.radioAudio.volume = 0;
              console.log('Háttérrádió fade out befejezve, lejátszás leállítva.');
            }
          }
        }, intervalTime);
      }, 20000); // 20 másodpercig szól normálisan

    }).catch(e => console.log('Lejátszás sikertelen:', e));
  }, 6000);
}


 	

function muteRadio() {
  if (window.radioAudio) {
    window.radioAudio.pause();
    window.radioAudio.currentTime = 0; // visszaállítja a lejátszás elejére
  }
}



function halkRadio() {
  stopPlayany();
  	radioplayer = 1;
    playany(['snd/lower volume Genny Untitled.wav', 'snd/Lower volume Catherine Genny mp3cut.net.wav'], 1);

    
    radioAudio.volume = 0.05; // Hangerő beállítása (0.5 = 50% hangerő)
    
 
  
}

//// radiopanel



 radioAudio = null; // A rádió példány
timeoutId = null; // Az inaktivitás utáni elrejtéshez

function createRadioPanel() {
    const radioPanel = document.getElementById('radio-panel');
    const radioList = document.getElementById('radio-list');

    // Töröljük a régi rádió példányt
    if (radioAudio) {
        radioAudio.pause();
        radioAudio.currentTime = 0;
        radioAudio = null;
    }

    // Megjelenítjük a panelt
    radioPanel.style.display = 'block';

    // Listázzuk a rádióadókat
    radioList.innerHTML = '';
    urls.forEach((url, index) => {
        const radioButton = document.createElement('input');
        radioButton.type = 'radio';
        radioButton.name = 'radio';
        radioButton.value = url;
        radioButton.id = `radio-${index}`;

        const label = document.createElement('label');
        label.htmlFor = `radio-${index}`;
        label.textContent = url.replace('https://', '');

        const br = document.createElement('br');

        radioList.appendChild(radioButton);
        radioList.appendChild(label);
        radioList.appendChild(br);

        // Event listener a rádióadó kiválasztásához
        radioButton.addEventListener('change', () => {
            playSelectedRadio(url);
        });
    });

    // Inaktivitás utáni elrejtés
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
        radioPanel.style.display = 'none';
    }, 6000); // 6 másodperc

    // Mozgásra reagálva töröljük az időzítést
    radioPanel.addEventListener('mousemove', () => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
            radioPanel.style.display = 'none';
        }, 6000);
    });
}

function playSelectedRadio(url) {
    // Töröljük a régi rádió példányt
    if (radioAudio) {
        radioAudio.pause();
        radioAudio.currentTime = 0;
        radioAudio = null;
        removelabel("playing:");
    }

    // Új rádió példány létrehozása
    radioAudio = new Audio(url);

stopSpeaking();

    // Hangerő beállítása
    radioAudio.volume = 1;

    // Utterance
    const synth = window.speechSynthesis;
    const utterance = new SpeechSynthesisUtterance(url.replace('https://', ''));

    utterance.onend = function() {
        radioAudio.play(); // Az utterance végén elindítja a rádió lejátszását
    };

    utterance.rate = 1.3; // Beszéd sebessége nagyon gyorsra állítása

    synth.speak(utterance);

    // Felirat
    const searchLabel = createFadeInLabel(`playing: ${url}`, {
        position: "absolute",
        top: "50%",
        left: "50%",
        transform: "translate(-50%, -50%)",
        fontSize: "26px",
        color: "rgba(115, 205, 105, 0.5)",
        textShadow: "2px 2px 4px rgba(0, 0, 0, 0.5)",
        zIndex: 0
    });

    // Slider megjelenítése
    document.getElementById("volume-slider-container").style.display = "block";

    const volumeSlider = document.getElementById("volume-slider");
    volumeSlider.value = 100; // Hangerő visszaállítása 100%-ra

    volumeSlider.addEventListener("input", function() {
        radioAudio.volume = volumeSlider.value / 100;
    });
}

// A panel megjelenítéséhez hívjuk meg a createRadioPanel függvényt
//createRadioPanel();




///// tördelő ttsmakernek

function tordelttsmaker() {
	
	navigator.clipboard.writeText(origcontent)
    .then(() => {
      //alert('Szöveg sikeresen másolva a vágólapra: ' + origcontent);
    })
    .catch(err => {
      alert('Vágólapra másolás sikertelen: ' + err);
    });
	
  fetch('fejlesztői eszközök/tordel.html')
    .then(response => response.text())
    .then(htmlContent => {
      let win = window.open('', '_blank', 'width=600,height=450');
      win.document.write(htmlContent);
      win.document.close();
    })
    .catch(err => alert('Nem sikerült betölteni a fájlt: ' + err));
}



///// fast3radio

function fast3radio() {
  fetch('fastradio2.html')
    .then(response => response.text())
    .then(htmlContent => {
      let win = window.open('', '_blank', 'width=600,height=450');
      win.document.write(htmlContent);
      win.document.close();
    })
    .catch(err => alert('Nem sikerült betölteni a fájlt: ' + err));
}


//// fastradio elcsesződött???

let toggleFastRadio = localStorage.getItem('toggleFastRadio') === '1' ? 1 : 0;

function toggleFastRadioFunction() {
    toggleFastRadio = toggleFastRadio === 1 ? 0 : 1;
    localStorage.setItem('toggleFastRadio', toggleFastRadio);
    console.log('toggleFastRadio:', toggleFastRadio);
    
    playany(['snd/17 New Outfit.mp3'], 1);
}

// Példa használatra:
//toggleFastRadioFunction(); // Kapcsolja a változót
//toggleFastRadioFunction(); // Kapcsolja ki a változót
















let audioContext;
let sourceNode;
let mediaRecorder;
let recordedChunks = [];

// UI elemek referenciái
let volumeControlContainer, volumeMinusBtn, volumePlusBtn, volumeDisplay;
let downloadLink, stopRecordBtn, startRecordBtn;

let currentVolume = 50; // alapértelmezett hangerő 50%

function createUI() {
  if (volumeControlContainer) return;  // Ha már létrehozva, ne csinálja újra


  // --- Start Record Button ---
  startRecordBtn = document.createElement('button');
  startRecordBtn.textContent = 'Felvétel indítása';
  styleFixedButton(startRecordBtn, 20);
  startRecordBtn.style.display = 'none';

  // --- Stop Record Button ---
  stopRecordBtn = document.createElement('button');
  stopRecordBtn.textContent = 'Felvétel leállítása';
  stopRecordBtn.disabled = true;

  stopRecordBtn.style.position = 'fixed';
  stopRecordBtn.style.right = '220px';
  stopRecordBtn.style.bottom = '160px';
  stopRecordBtn.style.zIndex = '10000';

  stopRecordBtn.style.fontSize = '28px';
  stopRecordBtn.style.padding = '20px 30px';
  stopRecordBtn.style.width = '200px';
  stopRecordBtn.style.height = '160px';
  stopRecordBtn.style.borderRadius = '50px';
  stopRecordBtn.style.background = 'rgba(255, 76, 59, 0.81)';
  stopRecordBtn.style.boxShadow = '0 6px 15px rgba(255, 76, 59, 0.7)';
  stopRecordBtn.style.color = 'rgba(255, 255, 255, 1)';
  stopRecordBtn.style.border = 'none';
  stopRecordBtn.style.cursor = 'pointer';

  stopRecordBtn.style.display = 'none';

  // --- Volume Control Container ---
  

volumeControlContainer = document.createElement('div');
volumeControlContainer.style.position = 'fixed';
volumeControlContainer.style.top = '400px';
volumeControlContainer.style.right = '20px';
volumeControlContainer.style.zIndex = '10000';
// RGBA fekete háttér 0.7 átlátszósággal
volumeControlContainer.style.background = 'rgba(0, 0, 0, 0.7)';
volumeControlContainer.style.color = '#fff';
volumeControlContainer.style.padding = '20px 30px';
volumeControlContainer.style.borderRadius = '15px';
volumeControlContainer.style.userSelect = 'none';
volumeControlContainer.style.display = 'none';
volumeControlContainer.style.display = 'none';  // alapból rejtve
volumeControlContainer.style.alignItems = 'center';
volumeControlContainer.style.gap = '20px';
volumeControlContainer.style.fontFamily = 'sans-serif';
volumeControlContainer.style.fontSize = '32px';  // nagyobb szövegméret

document.body.appendChild(volumeControlContainer);

// --- Minus Button ---
volumeMinusBtn = document.createElement('button');
volumeMinusBtn.textContent = '-';
volumeMinusBtn.style.fontSize = '48px';  // nagyobb gombméret
volumeMinusBtn.style.cursor = 'pointer';
volumeMinusBtn.style.width = '70px';
volumeMinusBtn.style.height = '70px';
volumeMinusBtn.style.borderRadius = '50%';
volumeMinusBtn.style.border = 'none';
volumeMinusBtn.style.background = 'rgba(255, 76, 59, 0.8)';  // citromos piros, átlátszó
volumeMinusBtn.style.color = 'white';
volumeMinusBtn.style.boxShadow = '0 4px 10px rgba(255, 76, 59, 0.6)';
volumeControlContainer.appendChild(volumeMinusBtn);

// --- Volume Display ---
volumeDisplay = document.createElement('span');
volumeDisplay.textContent = currentVolume + '%';
volumeDisplay.style.minWidth = '80px';
volumeDisplay.style.textAlign = 'center';
volumeDisplay.style.userSelect = 'none';
volumeControlContainer.appendChild(volumeDisplay);

// --- Plus Button ---
volumePlusBtn = document.createElement('button');
volumePlusBtn.textContent = '+';
volumePlusBtn.style.fontSize = '48px';  // nagyobb gombméret
volumePlusBtn.style.cursor = 'pointer';
volumePlusBtn.style.width = '70px';
volumePlusBtn.style.height = '70px';
volumePlusBtn.style.borderRadius = '50%';
volumePlusBtn.style.border = 'none';
volumePlusBtn.style.background = 'rgba(76, 175, 80, 0.8)';  // zöld, átlátszó
volumePlusBtn.style.color = 'white';
volumePlusBtn.style.boxShadow = '0 4px 10px rgba(76, 175, 80, 0.6)';
volumeControlContainer.appendChild(volumePlusBtn);


  // --- Download Link ---
  downloadLink = document.createElement('a');
  downloadLink.textContent = 'Felvétel letöltése';
  downloadLink.style.position = 'fixed';
  downloadLink.style.top = '540px';
  downloadLink.style.right = '220px';
  downloadLink.style.zIndex = '10000';
  downloadLink.style.background = 'rgba(200, 0, 110, 0.8)';
  downloadLink.style.color = '#fff';
  downloadLink.style.padding = '18px 28px';
  downloadLink.style.borderRadius = '5px';
  downloadLink.style.textDecoration = 'none';
  downloadLink.style.display = 'none';
  downloadLink.style.fontFamily = 'sans-serif';
  downloadLink.style.fontSize = '40px';

  downloadLink.onclick = () => {
    downloadLink.style.display = 'none';
    playany(['snd/You searched for swell ZapSplat - Download free sound effects_1744112601943.mp3'], 1);
  };

  document.body.appendChild(downloadLink);

  // --- Eseménykezelők ---
  startRecordBtn.onclick = startRecording;
  stopRecordBtn.onclick = stopRecording;

  volumeMinusBtn.onclick = () => {
    if (currentVolume > 0) {
      currentVolume -= 5;
      if (currentVolume < 0) currentVolume = 0;
      updateVolume();
    }
  };

  volumePlusBtn.onclick = () => {
    if (currentVolume < 100) {
      currentVolume += 5;
      if (currentVolume > 100) currentVolume = 100;
      updateVolume();
    }
  };

  // --- Gombok hozzáadása a DOM-hoz ---
  document.body.appendChild(startRecordBtn);
  document.body.appendChild(stopRecordBtn);
}

function updateVolume() {
  volumeDisplay.textContent = currentVolume + '%';
  if (radioAudio) {
    radioAudio.volume = currentVolume / 100;
  }
}

function styleFixedButton(button, topPx) {
  button.style.position = 'fixed';
  button.style.right = '220px';
  button.style.top = topPx + 'px';
  button.style.zIndex = '10000';
  button.style.padding = '10px 15px';
  button.style.fontSize = '16px';
  button.style.background = '#222';
  button.style.color = '#fff';
  button.style.border = 'none';
  button.style.borderRadius = '5px';
  button.style.cursor = 'pointer';
  button.style.userSelect = 'none';
  button.style.fontFamily = 'sans-serif';
}

function generateFileNameFromUrl(url) {
  let cleanName = url.replace(/^https?:\/\//, '')
                     .replace(/[^a-zA-Z0-9-_]/g, '_');
  const now = new Date();
  const pad = n => n.toString().padStart(2, '0');
  const dateStr = now.getFullYear().toString() +
                  pad(now.getMonth() + 1) +
                  pad(now.getDate()) + '_' +
                  pad(now.getHours()) +
                  pad(now.getMinutes()) +
                  pad(now.getSeconds());
  return `${cleanName}_${dateStr}.webm`;
}





function fastradio() {
  stopSpeaking();
  startStopwatch();
  createUI();
  createRadioPanel();
  volumeControlContainer.style.display = 'flex';

  if (radioAudio) {
    radioAudio.pause();
    radioAudio.currentTime = 0;
    radioAudio = null;
  }

  let callCount = parseInt(localStorage.getItem('fastradioCallCount')) || 0;
  let currentIndex = parseInt(localStorage.getItem('fastradioIndex')) || 0;

  let selectedUrl;
  let labelText;

  if (callCount === 0) {
    currentIndex = 0;
    selectedUrl = urls[currentIndex];
    labelText = `playing (${currentIndex + 1}/${urls.length}): ${selectedUrl}`;
  } else if (callCount % 2 === 1) {
    const randomIndex = Math.floor(Math.random() * urls.length);
    selectedUrl = urls[randomIndex];
    labelText = `playing (random): ${selectedUrl}`;
  } else {
    currentIndex = (currentIndex + 1) % urls.length;
    selectedUrl = urls[currentIndex];
    labelText = `playing (${currentIndex + 1}/${urls.length}): ${selectedUrl}`;
  }

  callCount++;
  localStorage.setItem('fastradioCallCount', callCount);

  if (!labelText.includes('(random)')) {
    localStorage.setItem('fastradioIndex', currentIndex);
  }

  radioplayer = 1;
  radioado = labelText.replace('https://', '');

  if (audioContext) {
    audioContext.close();
  }
  audioContext = new (window.AudioContext || window.webkitAudioContext)();

  radioAudio = new Audio(selectedUrl);
  radioAudio.crossOrigin = "anonymous";

  // Elmentjük az eredeti hangerőt (például 0.5)
  const originalVolume = 0.5;
  radioAudio.volume = originalVolume;

  currentVolume = 50; // alap hangerő (ha kell, updateVolume()-nal is beállíthatod)
  updateVolume();
  radioAudio.play();

  sourceNode = audioContext.createMediaElementSource(radioAudio);
  const destination = audioContext.createMediaStreamDestination();
  sourceNode.connect(destination);
  sourceNode.connect(audioContext.destination);

  mediaRecorder = new MediaRecorder(destination.stream);
  recordedChunks = [];

  mediaRecorder.ondataavailable = e => {
    if (e.data.size > 0) {
      recordedChunks.push(e.data);
    }
  };

  mediaRecorder.onstop = () => {
    const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType });
    const url = URL.createObjectURL(blob);

    downloadLink.href = url;
    downloadLink.download = generateFileNameFromUrl(selectedUrl);
    downloadLink.style.display = 'inline-block';
  };

  mediaRecorder.start();

  const synth = window.speechSynthesis;
  const utterance = new SpeechSynthesisUtterance(radioado);
  utterance.rate = 1.3;

  // Felolvasás indulásakor halkítjuk a rádiót
  utterance.onstart = function() {
    if (radioAudio) {
      radioAudio.volume = 0.062;  // halkítás
    }
  };

  // Felolvasás befejezésekor visszaállítjuk az eredeti hangerőt
  utterance.onend = function() {
    if (radioAudio) {
      radioAudio.volume = originalVolume;  // visszaállítás
    }
  };

  synth.speak(utterance);

  if (typeof stopClearFadeinoutText === 'function') stopClearFadeinoutText();

  if (typeof fadeInOutTextBlink === 'function') {
    fadeInOutTextBlink(labelText, 24, 'rgba(200, 0, 110, 1)', 60, 555);
  }

  startRecordBtn.style.display = 'inline-block';
  stopRecordBtn.style.display = 'inline-block';
  volumeControlContainer.style.display = 'flex';

  stopRecordBtn.disabled = false;
  startRecordBtn.disabled = true;
  setRecordingState(false);
}






function setRadioVolume(level) {
  // level értéke 0 és 1 között legyen
  if (radioAudio) {
    radioAudio.volume = level;
  }
}

//használat:
//setRadioVolume(0.5); // 50% hangerő










function startRecording() {
  if (!radioAudio) {
    alert('Előbb indítsd el a rádiót!');
    return;
  }
  if (mediaRecorder && mediaRecorder.state !== 'inactive') {
    alert('A felvétel már folyamatban van!');
    return;
  }

  if (audioContext) audioContext.close();
  audioContext = new (window.AudioContext || window.webkitAudioContext)();
  sourceNode = audioContext.createMediaElementSource(radioAudio);
  const destination = audioContext.createMediaStreamDestination();
  sourceNode.connect(destination);
  sourceNode.connect(audioContext.destination);

  mediaRecorder = new MediaRecorder(destination.stream);
  recordedChunks = [];

  mediaRecorder.ondataavailable = e => {
    if (e.data.size > 0) {
      recordedChunks.push(e.data);
    }
  };

  mediaRecorder.onstop = () => {
    const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType });
    const url = URL.createObjectURL(blob);
    downloadLink.href = url;
    downloadLink.download = generateFileNameFromUrl(radioAudio.src);
    downloadLink.style.display = 'inline-block';
  };

  mediaRecorder.start();
  startRecordBtn.disabled = true;
  stopRecordBtn.disabled = false;
  setRecordingState(true);
}

function stopRecording() {
  stopStopwatch();
  if (mediaRecorder && mediaRecorder.state !== 'inactive') {
    mediaRecorder.stop();
  }
  if (sourceNode) {
    sourceNode.disconnect();
  }
  if (audioContext) {
    audioContext.close();
  }
  stopRecordBtn.disabled = true;
  startRecordBtn.disabled = false;
  setRecordingState(false);
}

// UI létrehozása az oldal betöltésekor
window.addEventListener('DOMContentLoaded', () => {
  createUI();
});

// A többi függvényed (pl. startStopwatch, stopStopwatch, stb.) változatlan maradhat




let stopwatchInterval;
let startTime;
let stopwatchDiv;

function startStopwatch() {
  // Ha már fut stopper, töröljük
  if (stopwatchInterval) {
    clearInterval(stopwatchInterval);
  }

  // Ha nincs stopper div, létrehozzuk
  if (!stopwatchDiv) {
    stopwatchDiv = document.createElement('div');
    stopwatchDiv.style.position = 'fixed';
    stopwatchDiv.style.left = '300px';   // alap X pozíció
    stopwatchDiv.style.top = '500px';    // alap Y pozíció
    stopwatchDiv.style.zIndex = '100000';
    stopwatchDiv.style.backgroundColor = 'rgba(0,0,0,0.7)';
    stopwatchDiv.style.color = '#fff';
    stopwatchDiv.style.padding = '10px 15px';
    stopwatchDiv.style.fontFamily = 'monospace';
    stopwatchDiv.style.fontSize = '18px';
    stopwatchDiv.style.borderRadius = '5px';
    stopwatchDiv.style.cursor = 'move';  // mutatja, hogy húzható
    stopwatchDiv.style.userSelect = 'none'; // ne jelölődjön ki véletlenül
    document.body.appendChild(stopwatchDiv);

    makeDraggable(stopwatchDiv);
  }

  startTime = Date.now();

  stopwatchDiv.style.display = 'block'; // biztos, hogy látható

  stopwatchInterval = setInterval(() => {
    const elapsedTime = Date.now() - startTime;
    stopwatchDiv.textContent = formatTime(elapsedTime);
  }, 1000);
}

function stopStopwatch() {
  if (stopwatchInterval) {
    clearInterval(stopwatchInterval);
    stopwatchInterval = null;
  }
  if (stopwatchDiv) {
    stopwatchDiv.style.display = 'none';
  }
}

function formatTime(ms) {
  let totalSeconds = Math.floor(ms / 1000);
  let hours = Math.floor(totalSeconds / 3600);
  let minutes = Math.floor((totalSeconds % 3600) / 60);
  let seconds = totalSeconds % 60;

  return (
    String(hours).padStart(2, '0') + ':' +
    String(minutes).padStart(2, '0') + ':' +
    String(seconds).padStart(2, '0')
  );
}

// Drag & drop funkció egérrel és érintéssel
function makeDraggable(element) {
  let pos = { x: 0, y: 0, left: 0, top: 0 };
  let dragging = false;

  // Egér események
  element.addEventListener('mousedown', dragStart);
  document.addEventListener('mouseup', dragEnd);
  document.addEventListener('mousemove', dragMove);

  // Érintés események
  element.addEventListener('touchstart', dragStart, { passive: false });
  document.addEventListener('touchend', dragEnd);
  document.addEventListener('touchmove', dragMove, { passive: false });

  function dragStart(e) {
    e.preventDefault();
    dragging = true;

    if (e.type === 'touchstart') {
      pos.x = e.touches[0].clientX;
      pos.y = e.touches[0].clientY;
    } else {
      pos.x = e.clientX;
      pos.y = e.clientY;
    }

    // Aktuális pozíció
    pos.left = parseInt(element.style.left, 10) || 0;
    pos.top = parseInt(element.style.top, 10) || 0;
  }

  function dragEnd(e) {
    dragging = false;
  }

  function dragMove(e) {
    if (!dragging) return;

    e.preventDefault();

    let clientX, clientY;
    if (e.type === 'touchmove') {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }

    let dx = clientX - pos.x;
    let dy = clientY - pos.y;

    element.style.left = (pos.left + dx) + 'px';
    element.style.top = (pos.top + dy) + 'px';
  }
}

// Például a fastradio() függvény elején hívd meg:
// startStopwatch();

function setRecordingState(isRecording) {
	/*
  // Update UI or internal state based on recording status
  if (isRecording) {
    console.log("Recording started");
    // e.g., disable start button, enable stop button, show recording indicator, etc.
  } else {
    console.log("Recording stopped");
    // e.g., enable start button, disable stop button, hide recording indicator, etc.
  }
  */
}



// radio end


    // instanttranslate

function instanTTranslate() {
	
	// Kapcsolás a két állapot között
    instanttranslate = (instanttranslate === 0) ? 1 : 0;

    // Hang lejátszása
    // button info stealth game 1.mp3
//playany(['snd/button/war of stealth click 1.mp3'], 1);

if (muteSounds) {
        playany(['snd/button/war of stealth click 1.mp3', 'snd/button/button info stealth game 1.mp3', 'snd/button/button info stealth game 2.mp3'], 1);
    }


    // Logolás a konzolon
    //console.log("instanttranslate értéke most: " + instanttranslate);
    
	// Animáció kezelése
    if (instanttranslate === 1) {
        startTypingAnimation('paragraphId', 'divId', 'instanttranslate on');
    } else {
        startTypingAnimation('paragraphId', 'divId', 'instanttranslate off');
    }
    
	}

// instanttranslate vége

// visszaszámlálás a delete előtt
















//manuális delete favoritbook

//itt várjon 5 másodpercet, mielőtt továbbfolytatódna a funkció további része









//let torpedoTimeoutId = null;

function stopmanualfavoritdelete() {
  if (torpedoTimeoutId) {
    clearTimeout(torpedoTimeoutId);
    torpedoTimeoutId = null;
    console.log('Manual favorit törlés leállítva');
    removeScriptButton("stop me");
    //alert('Manual favorit törlés leállítva');
    startTypingAnimation('paragraphId', 'divId', 'Manual favorit törlés leállítva');
fadeInOutText('Manual favourite deletion stopped', 40, 'rgba(250, 10, 10, 1)', 5);
  } else {
    console.log('Nincs futó manual favorit törlés');
  }
}



function manualbookdelete2() {
    // A törléshez szükséges lépések
    let currentFilePath = localStorage.getItem('readpathstorage');
    let origcurrentFilePath = localStorage.getItem('readpathstorage');
    
    startTypingAnimation('paragraphId', 'divId', 'Favoritból törlésre kerül: ' + currentFilePath);
    
    favoritsavetofile();
    
    playany(['sounds/explosion/Free Impact Explosion Stock Video Footage Download 4K & HD Clips_1715530781863.mp3'], 1);
    
    function extractLastPart(filePath) {
        let fileName = filePath.split('/').pop();
        let trimmedName = fileName.replace('.txt', '').trim();
        return trimmedName;
    }
    
    let trimmedName = extractLastPart(currentFilePath);
    
    let lines = [
        "törlésre kerül",
        " ",
        trimmedName,
        " ",
        "mentésre kerül a favorit és deletedfiles"
    ];
    createSimplePanel(
        lines,
        'rgba(111, 111, 255, 0.8)', 
        50, 
        30, 
        80, 
        5000, // Eltűnési idő: 5 másodperc
        20, 
        0 
    );
    
   // alert("Favoritból törlésre kerül: " + currentFilePath);
    
    readany = "Favoritból 5 másodperc múlva törlésre kerül:  " + trimmedName + ". Útvonal: " + currentFilePath;
    readanytexthun();
    
    // 5 másodperc után végrehajtjuk a törlést
    setTimeout(function() {
        let favoritContent = localStorage.getItem('favoritstorage');
        if (favoritContent) {
            let lines = favoritContent.split('\n');
            let indexToRemove = lines.findIndex(line => line.includes(currentFilePath));
            
            if (indexToRemove !== -1) {
                lines.splice(indexToRemove, 1);
                localStorage.setItem('favoritstorage', lines.join('\n'));
                
                let deletedFilepaths = localStorage.getItem('deletedFilepaths');
                if (deletedFilepaths) {
                    deletedFilepaths += '\n' + currentFilePath;
                } else {
                    deletedFilepaths = currentFilePath;
                }
                localStorage.setItem('deletedFilepaths', deletedFilepaths);
                
                stopSpeaking();  
                readany = "A favorit sorok törlése megtörtént.";
                readanytexthun();
                startTypingAnimation('paragraphId', 'divId', 'A favorit sorok törlése megtörtént. ' + currentFilePath);
                
                console.log('favoritstorage tartalom:', localStorage.getItem('favoritstorage'));
                console.log('deletedFilepaths tartalom:', localStorage.getItem('deletedFilepaths'));
                
                const currentDate = new Date();
                const year = currentDate.getFullYear();
                const month = (currentDate.getMonth() + 1).toString().padStart(2, '0');
                const day = currentDate.getDate().toString().padStart(2, '0');
                const hours = currentDate.getHours().toString().padStart(2, '0');
                const minutes = currentDate.getMinutes().toString().padStart(2, '0');
                const formattedDate = `${year}-${month}-${day} ${hours}:${minutes}`;
                
                const fileName = `deletedfile_${formattedDate.replace(/:/g, '-')}.txt`;
                const content = `
${currentFilePath}
${formattedDate}

DELETED FILES
${deletedFilepaths}
`;
                
                const blob = new Blob([content], { type: 'text/plain' });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = fileName;
                link.click();
                URL.revokeObjectURL(link.href);
            }
        }
        
        playrefreshSound();
        
    }, 1000); // 5 másodperc
    
    startCountdown(1); // 5 másodperces countdown
}





function manualbookdelete() {
	
	createScriptButton("stop me", function() {
  stopmanualfavoritdelete();
}, {
  position: "absolute",
    top: "3%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    fontSize: "16px",
    padding: "10px 20px",
    backgroundColor: "rgba(240, 75, 25, 0.9)",
    color: "rgba(255, 255, 255, 0.8)",
    border: "none",
    borderRadius: "4px",
    zIndex: '9999' // Beállítjuk a z-index értékét
}); 
	
	
    let currentFilePath = localStorage.getItem('readpathstorage');
    
    let origcurrentFilePath = localStorage.getItem('readpathstorage');
    
    
    startTypingAnimation('paragraphId', 'divId', 'Favoritból törlésre kerül: ' + currentFilePath);
    
    favoritsavetofile();
    
    playany(['snd You searched for notify Page 2 of 14 ZapSplat - Download free sound effects_1744032397551.mp3'], 1);

  
    
    function extractLastPart(filePath) {
  // Az utolsó perjel utáni rész kiszedése
  let fileName = filePath.split('/').pop();
  
  // A .txt kiterjesztés eltávolítása
  let trimmedName = fileName.replace('.txt', '').trim();
  
  return trimmedName;
}


let trimmedName = extractLastPart(currentFilePath);


    
    let lines = [
    "törlésre kerül",
    " ",
    trimmedName,
    " ",
    "mentésre kerül a favorit és deletedfiles"
];
createSimplePanel(
    lines,
    'rgba(111, 111, 255, 0.8)', 
    50, // X pozíció: 50%
    30, // Y pozíció: 12%
    80, // 
    140000, // Eltűnési idő: 140 másodperc
    20, // Betűméret: 24 pixel
    0 // Randomizálás bekapcsolva
);

    
    //alert muszály ha firstload lenne, oscillát sem játszik le
    alert("Favoritból törlésre kerül: " + currentFilePath);
    
    
    readany = "Favoritból 2 perc múlva törlésre kerül:  " + trimmedName + ". Útvonal: " + currentFilePath;
    readanytexthun();
    
    // 20 másodperc után megjelenítjük a popup gombokat
    setTimeout(function() {
        createPopupButtons();
        
        // 5 másodperc után elrejtjük a popup gombokat, ha nem lettek lenyomva
        setTimeout(function() {
            if (popupButton1 && popupButton1.style.display === 'inline-block') {
                popupButton1.style.display = 'none';
            }
            if (popupButton2 && popupButton2.style.display === 'inline-block') {
                popupButton2.style.display = 'none';
            }
        }, 5000);
    }, 20000);
    
    
    // 5 másodperc után elrejtjük a popup gombot, ha nem lett lenyomva
    torpedoTimeoutId = setTimeout(function() {
        popupButton1.style.display = 'none';
        popupButton2.style.display = 'none';
    }, 40000);
    
    
    let favoritContent = localStorage.getItem('favoritstorage');

    if (favoritContent) {
        let lines = favoritContent.split('\n');
        let indexToRemove = lines.findIndex(line => line.includes(currentFilePath));

        if (indexToRemove !== -1) {
            // 20 másodperc után végrehajtjuk a favorit sorok törlését és a 'readany' üzenet módosítását
            
            torpedoTimeoutId = setTimeout(function() {
                lines.splice(indexToRemove, 1);
                localStorage.setItem('favoritstorage', lines.join('\n'));

                let deletedFilepaths = localStorage.getItem('deletedFilepaths');
                if (deletedFilepaths) {
                    deletedFilepaths += '\n' + currentFilePath;
                } else {
                    deletedFilepaths = currentFilePath;
                }
                localStorage.setItem('deletedFilepaths', deletedFilepaths);

                stopSpeaking();  
                readany = "A favorit sorok törlése megtörtént.";
                readanytexthun();
                startTypingAnimation('paragraphId', 'divId', 'A favorit sorok törlése megtörtént. ' + currentFilePath);

                // Kiírás a konzolra
                console.log('favoritstorage tartalom:', localStorage.getItem('favoritstorage'));
                console.log('deletedFilepaths tartalom:', localStorage.getItem('deletedFilepaths'));
                
                //log menrése
                
                
    // Aktuális dátum és idő formázása
const currentDate = new Date();
const year = currentDate.getFullYear();
const month = (currentDate.getMonth() + 1).toString().padStart(2, '0');
const day = currentDate.getDate().toString().padStart(2, '0');
const hours = currentDate.getHours().toString().padStart(2, '0');
const minutes = currentDate.getMinutes().toString().padStart(2, '0');

const formattedDate = `${year}-${month}-${day} ${hours}:${minutes}`;

console.log(formattedDate);


    // Fájlnév generálása
    const fileName = `deletedfile_${formattedDate.replace(/:/g, '-')}.txt`;

    // Tartalom összeállítása
  //  const currentFilePath = "currentFilePath"; // Példaérték
    //const deletedFilepaths = localStorage.getItem('deletedFilepaths'); // Törölt fájlok listája
    
    const content = `
${currentFilePath}
${formattedDate}


DELETED FILES
${deletedFilepaths}
`;

    // Blob létrehozása és fájl mentése
    const blob = new Blob([content], { type: 'text/plain' });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = fileName;
    link.click();
    URL.revokeObjectURL(link.href);




                
            }, 120000);
        }
    }
    
    startCountdown(120);
}


function createPopupButtons() {
    popupButton1 = document.createElement('button');
    popupButton1.textContent = 'Letöltés';
    popupButton1.style.position = 'fixed';
    popupButton1.style.bottom = '80%';
    popupButton1.style.left = '50%';
    popupButton1.style.transform = 'translate(-50%, 50%)';
    popupButton1.style.zIndex = '9998';
    popupButton1.style.padding = '10px 20px';
    popupButton1.style.backgroundColor = '#007bff';
    popupButton1.style.color = '#fff';
    popupButton1.style.border = 'none';
    popupButton1.style.borderRadius = '5px';
    popupButton1.style.cursor = 'pointer';
    popupButton1.addEventListener('click', downloadDeletedContent);
    document.body.appendChild(popupButton1);
    
    popupButton2 = document.createElement('button');
    popupButton2.textContent = 'Törlés';
    popupButton2.style.position = 'fixed';
    popupButton2.style.bottom = '70%';
    popupButton2.style.left = '50%';
    popupButton2.style.transform = 'translate(-50%, 50%)';
    popupButton2.style.zIndex = '9998';
    popupButton2.style.padding = '10px 20px';
    popupButton2.style.backgroundColor = '#dc3545';
    popupButton2.style.color = '#fff';
    popupButton2.style.border = 'none';
    popupButton2.style.borderRadius = '5px';
    popupButton2.style.cursor = 'pointer';
    popupButton2.addEventListener('click', clearDeletedFilepaths);
    document.body.appendChild(popupButton2);
}

function downloadDeletedContent() {
    let deletedFilepaths = localStorage.getItem('deletedFilepaths');
    let blob = new Blob([deletedFilepaths], { type: 'text/plain' });
    let url = URL.createObjectURL(blob);
    let link = document.createElement('a');
    link.href = url;
    link.download = 'deleted_files.txt';
    link.click();
    URL.revokeObjectURL(url);
    popupButton1.style.display = 'none';
    popupButton2.style.display = 'none';
}

function clearDeletedFilepaths() {
    localStorage.removeItem('deletedFilepaths');
    popupButton1.style.display = 'none';
    popupButton2.style.display = 'none';
}



function gptnewtab() {
    window.open("https://gemini.google.com/app", "_blank");
    playOscillatorSound(440, 300);
}





// news bezáró
function closeNewsDisplayContainer() {
  const container = document.getElementById('newsDisplayContainer');
  if (container) {
    container.remove();
  }
  const controls = document.getElementById('newsControlButtons');
  if (controls) {
    controls.remove();
  }
}






///// google random a halk beszédmentes





// Inputmező és gomb létrehozása, de nem automatikusan oldalbetöltéskor
function createGoogleSearchInputAndButton() {
  if (document.getElementById('googleSearchInputContainer')) return;

  newsflag = 1;

  const container = document.createElement('div');
  container.id = 'googleSearchInputContainer';
  Object.assign(container.style, {
    position: 'fixed',
    bottom: '360px',   // vagy bottom: '0px' a pontos aljához
    left: '300px',
    zIndex: '10001',
    backgroundColor: 'rgba(0,0,0,0.7)',
    padding: '8px',
    borderRadius: '8px',
    fontFamily: 'Arial, sans-serif',
    display: 'flex',
    alignItems: 'center',
    gap: '6px',
  });

  const input = document.createElement('input');
  input.type = 'search';
  input.id = 'googleSearchInput';
  input.placeholder = 'Keresés...';
  Object.assign(input.style, {
    padding: '6px 10px',
    fontSize: '16px',
    borderRadius: '4px',
    border: '1px solid #ccc',
    width: '250px',
  });

  const button = document.createElement('button');
  button.id = 'googleSearchButton';
  button.textContent = 'Keresés';
  Object.assign(button.style, {
    padding: '6px 12px',
    fontSize: '16px',
    borderRadius: '4px',
    border: 'none',
    backgroundColor: '#2196F3',
    color: 'white',
    cursor: 'pointer',
  });

  // Fontos módosítás: beszéd leállítása keresés indítás előtt
  button.addEventListener('click', () => {
    stopSpeechSynthesis123();  // Leállítjuk a beszédet, ha fut
    const query = input.value.trim();
    if (query) {
      performGoogleSearchAndRead123(query, lastLangCode, lastRegionCode, lastSpeechLang);
    }
  });

  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      stopSpeechSynthesis123();  // Leállítjuk a beszédet, ha fut
      button.click();
    }
  });

  container.appendChild(input);
  container.appendChild(button);

  document.body.appendChild(container);
}

// Konténer létrehozása vagy lekérése a keresési eredményekhez
function getOrCreateSearchResultsContainer123() {
  let container = document.getElementById('googleSearchResultsContainer');
  if (!container) {
    container = document.createElement('div');
    container.id = 'googleSearchResultsContainer';
    Object.assign(container.style, {
      position: 'fixed',
      top: '35%',
      left: '40%',
      transform: 'translate(-50%, -50%)',
      width: '400px',
      height: '300px',
      maxHeight: '80vh',
      overflowY: 'auto',
      backgroundColor: 'rgba(10, 10, 50, 0.95)',
      color: 'white',
      padding: '15px',
      borderRadius: '8px',
      fontFamily: 'Arial, sans-serif',
      fontSize: '16px',
      zIndex: '10200',
      boxShadow: '0 0 15px rgba(0,0,0,0.9)',
      border: '1px solid #444',
      boxSizing: 'border-box',
      whiteSpace: 'normal',
      wordBreak: 'break-word',
    });
    document.body.appendChild(container);
  }
  return container;
}

// Vezérlőgombok létrehozása a Google kereséshez
function createSearchControlButtons123() {
  let container = document.getElementById('googleSearchControlButtons');
  if (!container) {
    container = document.createElement('div');
    container.id = 'googleSearchControlButtons';

    const resultsContainer = getOrCreateSearchResultsContainer123();
    const rect = resultsContainer.getBoundingClientRect();

    Object.assign(container.style, {
      position: 'fixed',
      top: (rect.bottom + 10) + 'px',
      left: '30%',
      transform: 'translateX(-50%)',
      zIndex: '10200',
      backgroundColor: 'rgba(0,0,0,0.7)',
      padding: '8px',
      borderRadius: '8px',
      color: 'white',
      fontFamily: 'Arial, sans-serif',
      display: 'flex',
      gap: '10px',
      alignItems: 'center',
      maxWidth: '420px',
      boxSizing: 'border-box',
    });

    document.body.appendChild(container);
  }

  // Kérések számláló
  let counter = document.getElementById('searchRequestCounter');
  if (!counter) {
    counter = document.createElement('span');
    counter.id = 'searchRequestCounter';
    counter.style.fontWeight = 'bold';
    counter.style.fontSize = '16px';
    container.appendChild(counter);
  }
  counter.textContent = `Kérések száma: ${searchRequestCount}`;

  // Reset gomb
  let resetBtn = document.getElementById('resetSearchRequestCounterBtn');
  if (!resetBtn) {
    resetBtn = document.createElement('button');
    resetBtn.id = 'resetSearchRequestCounterBtn';
    resetBtn.textContent = 'Reset';
    Object.assign(resetBtn.style, {
      cursor: 'pointer',
      padding: '6px 12px',
      fontSize: '16px',
      borderRadius: '4px',
      border: 'none',
      backgroundColor: '#cc3300',
      color: 'white'
    });
    resetBtn.addEventListener('click', () => {
      searchRequestCount = 0;
      localStorage.setItem('searchRequestCount', '0');
      counter.textContent = `Kérések száma: ${searchRequestCount}`;
    });
    container.appendChild(resetBtn);
  }

  // Shuffle kapcsoló
  let shuffleBtn = document.getElementById('searchShuffleToggleBtn');
  if (!shuffleBtn) {
    shuffleBtn = document.createElement('button');
    shuffleBtn.id = 'searchShuffleToggleBtn';
    shuffleBtn.textContent = isSearchShuffleOn ? 'Random ON' : 'Random OFF';
    Object.assign(shuffleBtn.style, {
      cursor: 'pointer',
      padding: '6px 12px',
      fontSize: '16px',
      borderRadius: '4px',
      border: 'none',
      backgroundColor: isSearchShuffleOn ? '#009900' : '#666666',
      color: 'white'
    });
    shuffleBtn.addEventListener('click', () => {
      isSearchShuffleOn = !isSearchShuffleOn;
      localStorage.setItem('isSearchShuffleOn', isSearchShuffleOn.toString());
      shuffleBtn.textContent = isSearchShuffleOn ? 'Random ON' : 'Random OFF';
      shuffleBtn.style.backgroundColor = isSearchShuffleOn ? '#009900' : '#666666';
      if (searchArticles.length > 0) {
        if (isSearchShuffleOn) {
          shuffleArray123(searchArticles);
        } else if (lastSearchQuery) {
          performGoogleSearchAndRead123(lastSearchQuery, lastLangCode, lastRegionCode, lastSpeechLang);
          return;
        }
        currentSearchIndex = 0;
        stopSpeechSynthesis123();
        showSearchResult123(currentSearchIndex);
      }
    });
    container.appendChild(shuffleBtn);
  }

  // Következő gomb
  let nextBtn = document.getElementById('nextSearchBtn');
  if (!nextBtn) {
    nextBtn = document.createElement('button');
    nextBtn.id = 'nextSearchBtn';
    nextBtn.textContent = 'Következő';
    Object.assign(nextBtn.style, {
      cursor: 'pointer',
      padding: '6px 12px',
      fontSize: '16px',
      borderRadius: '4px',
      border: 'none',
      backgroundColor: '#0055cc',
      color: 'white'
    });
    nextBtn.addEventListener('click', () => {
      stopSpeechSynthesis123();
      showNextSearchResult123();
    });
    container.appendChild(nextBtn);
  }

  // Kilépés gomb
  let exitBtn = document.getElementById('exitSearchBtn');
  if (!exitBtn) {
    exitBtn = document.createElement('button');
    exitBtn.id = 'exitSearchBtn';
    exitBtn.textContent = 'Kilépés';
    Object.assign(exitBtn.style, {
      cursor: 'pointer',
      padding: '6px 12px',
      fontSize: '16px',
      borderRadius: '4px',
      border: 'none',
      backgroundColor: '#cc0000',
      color: 'white'
    });
    exitBtn.addEventListener('click', () => {
      stopSpeechSynthesis123();

      // Eredményeket tartalmazó konténer eltávolítása
      const resultsContainer = document.getElementById('googleSearchResultsContainer');
      if (resultsContainer) resultsContainer.remove();

      // Vezérlőgombokat tartalmazó konténer eltávolítása
      const controlButtons = document.getElementById('googleSearchControlButtons');
      if (controlButtons) controlButtons.remove();

      // Inputmezőt és keresés gombot tartalmazó konténer eltávolítása
      const inputContainer = document.getElementById('googleSearchInputContainer');
      if (inputContainer) inputContainer.remove();
    });
    container.appendChild(exitBtn);
  }

  // Restart gomb
  let restartBtn = document.getElementById('restartSearchBtn');
  if (!restartBtn) {
    restartBtn = document.createElement('button');
    restartBtn.id = 'restartSearchBtn';
    restartBtn.textContent = 'Restart';
    Object.assign(restartBtn.style, {
      cursor: 'pointer',
      padding: '6px 12px',
      fontSize: '16px',
      borderRadius: '4px',
      border: 'none',
      backgroundColor: '#007acc',
      color: 'white',
    });
    restartBtn.addEventListener('click', () => {
      stopSpeechSynthesis123();

      // Eredményeket tartalmazó konténer eltávolítása
      const resultsContainer = document.getElementById('googleSearchResultsContainer');
      if (resultsContainer) resultsContainer.remove();

      // Vezérlőgombokat tartalmazó konténer eltávolítása
      const controlButtons = document.getElementById('googleSearchControlButtons');
      if (controlButtons) controlButtons.remove();

      // Inputmezőt és keresés gombot tartalmazó konténer eltávolítása
      const inputContainer = document.getElementById('googleSearchInputContainer');
      if (inputContainer) inputContainer.remove();

      // Változók alaphelyzetbe állítása
      searchArticles = [];
      lastSearchQuery = '';
      searchRequestCount = 0;
      localStorage.setItem('searchRequestCount', '0');

      ujsaggoogle();
    });
    container.appendChild(restartBtn);
  }
}

// Eredmény megjelenítése és felolvasása
async function showSearchResult123(index) {
  const container = getOrCreateSearchResultsContainer123();

  if (index < 0 || index >= searchArticles.length) {
    container.innerHTML = 'Nincs több találat.';
    await speakText_google123('Nincs több találat.');
    return;
  }

  const item = searchArticles[index];
  const textParts = [
    `Találat ${index + 1}: ${item.title}.`,
    item.snippet ? `Leírás: ${item.snippet}.` : '',
    `Link: ${item.link}.`
  ].filter(Boolean).join(' ');

  container.innerHTML = '';
  const resultElem = document.createElement('div');
  Object.assign(resultElem.style, {
    marginBottom: '15px',
    borderBottom: '1px solid #ccc',
    paddingBottom: '10px',
    cursor: 'pointer',
    color: '#aaddff'
  });
  resultElem.textContent = textParts;
  resultElem.dataset.url = item.link;
  resultElem.addEventListener('click', () => {
    window.open(item.link, '_blank');
  });

  container.appendChild(resultElem);

  await speakText_google123(textParts);

  currentSearchIndex++;
  if (currentSearchIndex >= Math.min(maxSearchArticles, searchArticles.length)) currentSearchIndex = 0;
  showSearchResult123(currentSearchIndex);
}

// Következő találat megjelenítése
function showNextSearchResult123() {
  if (searchArticles.length === 0) return;
  currentSearchIndex++;
  if (currentSearchIndex >= Math.min(maxSearchArticles, searchArticles.length)) currentSearchIndex = 0;
  showSearchResult123(currentSearchIndex);
}

// Segédfüggvény a beszéd leállításához
function stopSpeechSynthesis123() {
  if ('speechSynthesis' in window && speechSynthesis.speaking) speechSynthesis.cancel();
}

// Szövegfelolvasó függvény Google kereséshez
function speakText_google123(text) {
  return new Promise((resolve) => {
    if ('speechSynthesis' in window) {
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = lastSpeechLang || 'hu-HU';
      utterance.onend = () => resolve();
      speechSynthesis.speak(utterance);
    } else {
      console.log('A böngésződ nem támogatja a szövegfelolvasást.');
      resolve();
    }
  });
}

// Tömb összekeverése
function shuffleArray123(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

// Fő keresőfüggvény
async function performGoogleSearchAndRead123(query, langCode = 'hu', regionCode = 'hu', speechLang = 'hu-HU') {
  // Ha még nincs inputmező, akkor létrehozzuk és megjelenítjük
  if (!document.getElementById('googleSearchInputContainer')) {
    createGoogleSearchInputAndButton();
  }

  lastSearchQuery = query;
  lastLangCode = langCode;
  lastRegionCode = regionCode;
  lastSpeechLang = speechLang;

  searchRequestCount++;
  localStorage.setItem('searchRequestCount', searchRequestCount.toString());
  const counterElem = document.getElementById('searchRequestCounter');
  if (counterElem) counterElem.textContent = `Kérések száma: ${searchRequestCount}`;

  const url = `https://www.googleapis.com/customsearch/v1?key=${googleApiKey}&cx=${googleCx}&q=${encodeURIComponent(query)}&lr=lang_${langCode}&gl=${regionCode}`;

  const container = getOrCreateSearchResultsContainer123();

  try {
    const response = await fetch(url);
    if (!response.ok) throw new Error(`HTTP hiba: ${response.status}`);
    const data = await response.json();

    if (!data.items || data.items.length === 0) {
      container.innerHTML = 'Nincs találat.';
      await speakText_google123('Nincs találat.');
      return;
    }

    searchArticles = data.items.slice(0, maxSearchArticles);
    if (isSearchShuffleOn) shuffleArray123(searchArticles);

    currentSearchIndex = 0;
    createSearchControlButtons123();
    await showSearchResult123(currentSearchIndex);

  } catch (error) {
    container.innerHTML = 'Hiba történt a keresés során.';
    console.error('Hiba a keresés során:', error);
    await speakText_google123('Hiba történt a keresés során.');
  }
}












///// google api napi 100 


// --- Google kereső felolvasó (News felolvasóhoz igazítva, külön hangfelismerő változóval) ---

const googleApiKey = 'AIzaSyAlt__u0fBX_Dz5rgNb39zUKT4N190YXGA';
const googleCx = '8009ff5ce45e14013';

// Globális változók
let searchArticles = [];
let currentSearchIndex = 0;
let maxSearchArticles = 5;

let searchRequestCount = parseInt(localStorage.getItem('searchRequestCount') || '0', 10);
const savedMaxSearch = localStorage.getItem('maxSearchArticles');
if (savedMaxSearch) maxSearchArticles = parseInt(savedMaxSearch, 10);

let isSearchShuffleOn = localStorage.getItem('isSearchShuffleOn') === 'true';

let googleRecognition = null; // Külön hangfelismerő változó a Google keresőhöz

// --- Segédfüggvények ---

function getOrCreateSearchResultsContainer() {
  let container = document.getElementById('searchResultsContainer');
  if (!container) {
    container = document.createElement('div');
    container.id = 'searchResultsContainer';
    Object.assign(container.style, {
      position: 'fixed',
      top: '100px',
      right: '10px',
      width: '360px',
      minHeight: '300px',
      maxHeight: '80vh',
      overflowY: 'auto',
      backgroundColor: 'rgba(0, 10, 53, 0.85)',
      color: 'white',
      padding: '15px',
      borderRadius: '10px',
      fontFamily: 'Arial, sans-serif',
      fontSize: '16px',
      zIndex: '9999',
      boxShadow: '0 0 15px rgba(0,0,0,0.8)',
      border: '1px solid #555',
      boxSizing: 'border-box',
      wordWrap: 'break-word',
      userSelect: 'text',
      whiteSpace: 'normal',
      cursor: 'default',
    });

    document.body.appendChild(container);
  }
  return container;
}

function stopSpeechSynthesis() {
  if ('speechSynthesis' in window && speechSynthesis.speaking) speechSynthesis.cancel();
}

function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

function createSearchControlButtons() {
  let container = document.getElementById('searchControlButtons');
  if (!container) {
    container = document.createElement('div');
    container.id = 'searchControlButtons';

    const resultsContainer = getOrCreateSearchResultsContainer();
    const rect = resultsContainer.getBoundingClientRect();

    Object.assign(container.style, {
      position: 'fixed',
      top: (rect.top + rect.height + 5) + 'px',
      right: (window.innerWidth - (rect.left + rect.width)) + 'px',
      left: 'auto',
      zIndex: '10000',
      backgroundColor: 'rgba(0,0,0,0.6)',
      padding: '8px',
      borderRadius: '8px',
      color: 'white',
      fontFamily: 'Arial, sans-serif',
      display: 'flex',
      gap: '10px',
      alignItems: 'center',
    });

    document.body.appendChild(container);
  }

  // Kérések számláló
  let counter = document.getElementById('searchRequestCounter');
  if (!counter) {
    counter = document.createElement('span');
    counter.id = 'searchRequestCounter';
    counter.style.fontWeight = 'bold';
    counter.style.fontSize = '16px';
    container.appendChild(counter);
  }
  counter.textContent = `Kérések száma: ${searchRequestCount}`;

  // Reset gomb
  let resetBtn = document.getElementById('resetSearchRequestCounterBtn');
  if (!resetBtn) {
    resetBtn = document.createElement('button');
    resetBtn.id = 'resetSearchRequestCounterBtn';
    resetBtn.textContent = 'Reset';
    Object.assign(resetBtn.style, {
      cursor: 'pointer',
      padding: '6px 12px',
      fontSize: '16px',
      borderRadius: '4px',
      border: 'none',
      backgroundColor: '#cc3300',
      color: 'white',
    });
    resetBtn.addEventListener('click', () => {
      searchRequestCount = 0;
      localStorage.setItem('searchRequestCount', '0');
      counter.textContent = `Kérések száma: ${searchRequestCount}`;
    });
    container.appendChild(resetBtn);
  }

  // Shuffle kapcsoló gomb
  let shuffleBtn = document.getElementById('searchShuffleToggleBtn');
  if (!shuffleBtn) {
    shuffleBtn = document.createElement('button');
    shuffleBtn.id = 'searchShuffleToggleBtn';
    shuffleBtn.textContent = isSearchShuffleOn ? 'Random ON' : 'Random OFF';
    Object.assign(shuffleBtn.style, {
      cursor: 'pointer',
      padding: '6px 12px',
      fontSize: '16px',
      borderRadius: '4px',
      border: 'none',
      backgroundColor: isSearchShuffleOn ? '#009900' : '#666666',
      color: 'white',
    });
    shuffleBtn.addEventListener('click', () => {
      isSearchShuffleOn = !isSearchShuffleOn;
      localStorage.setItem('isSearchShuffleOn', isSearchShuffleOn.toString());
      shuffleBtn.textContent = isSearchShuffleOn ? 'Random ON' : 'Random OFF';
      shuffleBtn.style.backgroundColor = isSearchShuffleOn ? '#009900' : '#666666';
      if (searchArticles.length > 0) {
        if (isSearchShuffleOn) {
          shuffleArray(searchArticles);
        } else {
          // Újra lekérjük a keresést az eredeti sorrendért
          if (lastSearchQuery) {
            fetchAndReadGoogleSearch(lastSearchQuery, lastLangCode, lastRegionCode, lastSpeechLang);
            return;
          }
        }
        currentSearchIndex = 0;
        stopSpeechSynthesis();
        showSearchResult(currentSearchIndex);
      }
    });
    container.appendChild(shuffleBtn);
  }

  // Következő találat gomb (opcionális, ha automatikus felolvasást szeretnél)
  let nextBtn = document.getElementById('nextSearchResultBtn');
  if (!nextBtn) {
    nextBtn = document.createElement('button');
    nextBtn.id = 'nextSearchResultBtn';
    nextBtn.textContent = 'Következő találat';
    Object.assign(nextBtn.style, {
      cursor: 'pointer',
      padding: '6px 12px',
      fontSize: '16px',
      borderRadius: '4px',
      border: 'none',
      backgroundColor: '#0055cc',
      color: 'white',
    });
    nextBtn.addEventListener('click', () => {
      stopSpeechSynthesis();
      showNextSearchResult();
    });
    container.appendChild(nextBtn);
  }

  // Max találatok száma választó
  let maxSelect = document.getElementById('maxSearchArticlesSelect');
  if (!maxSelect) {
    maxSelect = document.createElement('select');
    maxSelect.id = 'maxSearchArticlesSelect';
    maxSelect.title = 'Max találatok száma';
    [1, 5, 10, 25, 50].forEach(num => {
      const option = document.createElement('option');
      option.value = num;
      option.textContent = num;
      if (num === maxSearchArticles) option.selected = true;
      maxSelect.appendChild(option);
    });
    Object.assign(maxSelect.style, {
      cursor: 'pointer',
      padding: '6px 8px',
      fontSize: '16px',
      borderRadius: '4px',
      border: 'none',
      backgroundColor: '#0044aa',
      color: 'white',
    });
    maxSelect.addEventListener('change', () => {
      maxSearchArticles = parseInt(maxSelect.value, 10);
      localStorage.setItem('maxSearchArticles', maxSearchArticles);
      if (searchArticles.length > 0) {
        currentSearchIndex = 0;
        stopSpeechSynthesis();
        showSearchResult(currentSearchIndex);
      }
    });
    container.appendChild(maxSelect);
  }
}

async function showSearchResult(index) {
  stopSpeechSynthesis();

  const container = getOrCreateSearchResultsContainer();

  if (index < 0 || index >= searchArticles.length) {
    container.innerHTML = 'Nincs több találat.';
    await speakText_google('Nincs több találat.');
    currentSearchIndex = 0; // Reset index, ha végére értünk
    return;
  }

  const item = searchArticles[index];

  container.innerHTML = '';

  const itemDiv = document.createElement('div');
  Object.assign(itemDiv.style, {
    marginBottom: '15px',
    borderBottom: '1px solid #ccc',
    paddingBottom: '10px',
    cursor: 'pointer',
  });
  itemDiv.textContent = `${index + 1}. ${item.title}. ${item.snippet}`;
  itemDiv.title = 'Kattints a megnyitáshoz';
  itemDiv.onclick = () => window.open(item.link, '_blank');

  container.appendChild(itemDiv);
  container.style.opacity = '1';

  await speakText_google(`${item.title}. ${item.snippet}`);

  currentSearchIndex++;
  if (currentSearchIndex >= Math.min(maxSearchArticles, searchArticles.length)) {
    currentSearchIndex = 0; // Kezdje elölről, ha elértük a maximumot/véget
    // Ha nem akarod, hogy elölről kezdje, akkor itt return-ölhetsz: return;
    return; // Hozzáadva, hogy ne kezdje automatikusan elölről a végén
  }

  // **Fontos: itt hívjuk meg újra a függvényt a következő találat felolvasásához:**
  showSearchResult(currentSearchIndex);
}

function showNextSearchResult() {
  if (searchArticles.length === 0) return;
  currentSearchIndex++;
  if (currentSearchIndex >= Math.min(maxSearchArticles, searchArticles.length)) currentSearchIndex = 0;
  showSearchResult(currentSearchIndex);
}

function showPreviousSearchResult() {
  if (searchArticles.length === 0) return;
  currentSearchIndex--;
  if (currentSearchIndex < 0) currentSearchIndex = Math.min(maxSearchArticles, searchArticles.length) - 1;
  showSearchResult(currentSearchIndex);
}

let lastSearchQuery = '';
let lastLangCode = 'hu';
let lastRegionCode = 'hu';
let lastSpeechLang = 'hu-HU';

async function fetchAndReadGoogleSearch(query, langCode = 'hu', regionCode = 'hu', speechLang = 'hu-HU') {
  lastSearchQuery = query;
  lastLangCode = langCode;
  lastRegionCode = regionCode;
  lastSpeechLang = speechLang;

  searchRequestCount++;
  localStorage.setItem('searchRequestCount', searchRequestCount.toString());
  const counterElem = document.getElementById('searchRequestCounter');
  if (counterElem) counterElem.textContent = `Kérések száma: ${searchRequestCount}`;

  const url = `https://www.googleapis.com/customsearch/v1?key=${googleApiKey}&cx=${googleCx}&q=${encodeURIComponent(query)}&lr=lang_${langCode}&gl=${regionCode}`;

  const container = getOrCreateSearchResultsContainer();

  try {
    const response = await fetch(url);
    if (!response.ok) throw new Error(`HTTP hiba: ${response.status}`);
    const data = await response.json();

    if (!data.items || data.items.length === 0) {
      container.innerHTML = 'Nincs találat.';
      await speakText_google('Nincs találat.');
      return;
    }

    searchArticles = data.items.slice(0, maxSearchArticles);
    if (isSearchShuffleOn) shuffleArray(searchArticles);

    currentSearchIndex = 0;
    createSearchControlButtons();
    // **Fontos: itt indítjuk el az első felolvasást:**
    await showSearchResult(currentSearchIndex);

  } catch (error) {
    container.innerHTML = 'Hiba történt a keresés során.';
    console.error('Hiba a keresés során:', error);
    await speakText_google('Hiba történt a keresés során.');
  }
}

function speakText_google(text) {
  return new Promise((resolve) => {
    if ('speechSynthesis' in window) {
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = 'hu-HU';
      utterance.onend = () => resolve();
      speechSynthesis.speak(utterance);
    } else {
      console.log('A böngésződ nem támogatja a szövegfelolvasást.');
      resolve();
    }
  });
}

// --- Hangfelismerés ---

function recognizeSpeech(lang) {
  return new Promise((resolve, reject) => {
    googleRecognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
    googleRecognition.lang = lang;
    googleRecognition.continuous = false;
    googleRecognition.interimResults = false;

    googleRecognition.onstart = () => {
      console.log('Beszélj most...');
    };

    googleRecognition.onresult = (event) => {
      const text = event.results[0][0].transcript.trim().toLowerCase();
      console.log('Felismert:', text);
      resolve(text);
    };

    googleRecognition.onerror = (event) => {
      console.error('Hiba:', event.error);
      reject(event.error);
    };

    googleRecognition.start();
  });
}

async function startGoogleVoiceSearch() {
  while (true) {
    try {
      let recogLang = 'hu-HU';
      let speechLang = 'hu-HU';

      const text = await recognizeSpeech(recogLang);

      let langCode = 'hu';
      let regionCode = 'hu';

      let query = text;

      if (text.startsWith('magyar ')) {
        langCode = 'hu';
        regionCode = 'hu';
        recogLang = 'hu-HU';
        speechLang = 'hu-HU';
        query = text.replace(/^magyar\s+/, '');
      } else if (text.startsWith('angol ')) {
        langCode = 'en';
        regionCode = 'us';
        recogLang = 'en-US';
        speechLang = 'en-US';
        query = text.replace(/^angol\s+/, '');
      } else {
        await speakText_google('Kérlek, mondd azt, hogy magyar vagy angol, majd a keresendő szavakat.', 'hu-HU');
        continue;
      }

      if (recogLang !== (langCode === 'hu' ? 'hu-HU' : 'en-US')) {
        // Ha nem egyezik, újra kérjük a beszédet
        continue;
      }

      await fetchAndReadGoogleSearch(query, langCode, regionCode, speechLang);

    } catch (err) {
      console.error('Hiba a hangfelismerésben:', err);
      await speakText_google('Hiba történt a hangfelismerésben.');
      break;
    }
  }
}

// --- Bezáró funkció ---

function closeSearchResults() {
  const container = document.getElementById('searchResultsContainer');
  if (container) {
    container.style.display = 'none';
    container.innerHTML = '';
  }
  stopSpeechSynthesis();
  if (googleRecognition) {
    googleRecognition.abort();
  }
}

// --- Opció: automatikus indítás ---
// startGoogleVoiceSearch();


/////// író text alapján google keresés

function googlefromiro(textarea, recognizer) {
  const text = textarea.value.trim();
  if (!text) return;

if (recognizer && recognizer.isRecognizing) {
          recognizer.stop();
          playany(['snd/button/Digital high tech beep 1.mp3', 'snd/button/mixkit-game-ball-tap-2073.wav', 'snd/button/mixkit-quick-jump-arcade-game-239.wav'], 1);
        }
        if (textarea) {
          textarea.style.display = 'none';
        }
        
  let langCode = 'hu';
  let regionCode = 'hu';
  let speechLang = 'hu-HU';

  fetchAndReadGoogleSearch(text, langCode, regionCode, speechLang);
}

/////// hangfel egyszer

  /// a felismerés utáni kódok itt: recognition.onresult
  
var recogbookNum;

var recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
recognition.lang = 'hu-HU';
recognition.continuous = false;
recognition.interimResults = false;

commands = {
	  "OLVAS": "readTextinfinite",
	"HÍREK": "fetchAndReadNews_7d18",
	
		  "RADIO": "fast3radio",
			  "FÖLD": "contentarchive",
				  "BTZ": "btz2D",
  "READ": "readTextinfiniteTranslated",
  "STUDY": "studyreadTextinfiniteTranslated",
  "LEARN": "studyreadTextinfiniteTranslated",
	  "HOLD": "hold",
	"FIND": "textselect",
	  "BTZ HANG": "btzread3D",
  "WRITER": "diktálás",
  "INFO": "showCommands",
  "INFÓ": "showCommands",
  "KALAND": "kalandjatekkockazatOnOff",
  "NYUSZI OFF": "nyusziout",
  "NYUSZI ON": "nyusziin",
  "NYUSZI TÖRÖL": "kjkhistorydelone",
  "NYUSZI KAPAR": "kjkhistorydeltwo",
  "HEWLETT PACKARD": "kjkhistorydelall",
  "NYUSZI LAP": "kjkhistoryshow",
  "GOOGLE": "startGoogleVoiceSearch",
  "MUSIC": "mainAsySuno", 
  "SONG": "mainAsySuno", 
  "ELŐZŐ": "lastbookload",
  "RESTART": "playrefreshSound",
  "MELÓ": "contentarchive",
  "ZAGOR": "selectzagor",
  "ORIGINAL": "legorig",
  "FILTER": "szurt",
  "TÖRÖL": "manualbookdelete2",
  "OKOS": "userbookmarksave",
  "HÜLYE": "userbookmarkload",
  "TUNER": "toggleFastRadioFunction",
  "OLD": "fastradio",
  "HANGOSABB": "hangosabbradio",
  "HALKABB": "halkabbradio",
  "TOMPA": "tomparadio",


  "CSERE": "toggleFavoritStorage",
  "MARS": "mars",
  "LOGTISZTÍT": "marsClear",
  "LOKTISZTÍT": "marsClear",
  "GYORSABB": "gyorsabb",
  "LASSABB": "lassabb",
  "HARC": "newpagekjkgame",
    "MAGYAR": "toggleMagyart",
  "MARINA": "startWeatherApp",
  "RANDOM": "random",
  "ÍRÓ": "startBeszed",
  "FEJLESZT": "fejlesztoi",
  "SZAVAK": "randomszavak",
  "KÖNYV": "hangalapuKereses",
  "SZÓ": "hangalapuszokereses",
  
  "GPT": "gptnewtab",
  "JUMP": "jumpByNum",
  "KÉP": "kepet",
  "TÖRDEL": "tordelttsmaker",
  "SPLIT": "tordelttsmaker",

  
  
//  "LISTA": "biglista",
  
  
  //"HARC": "newpagekjkgame",
  //"HARC": "newpagekjkgame",
  
  // További parancsok...
};





const newsApiKey_7d18 = '7d187861e8ff488081e35d108729d6bd';

// Globális változók
let articles = [];
let currentArticleIndex = 0;
let maxArticles = 5;

let requestCount = parseInt(localStorage.getItem('requestCount') || '0', 10);
const savedMax = localStorage.getItem('maxArticles');
if (savedMax) maxArticles = parseInt(savedMax, 10);

let isShuffleOn = localStorage.getItem('isShuffleOn') === 'true';

let lastQuery = 'gazdaság';

// Segédfüggvények

function getOrCreateNewsDisplayContainer() {
  let container = document.getElementById('newsDisplayContainer');
  if (!container) {
    container = document.createElement('div');
    container.id = 'newsDisplayContainer';
    Object.assign(container.style, {
      position: 'fixed',
      top: '100px',
      right: '10px',
      width: '320px',
      minHeight: '250px',
      maxHeight: '80vh',
      overflowY: 'auto',
      backgroundColor: 'rgba(0, 10, 53, 0.75)',
      color: 'white',
      padding: '10px',
      borderRadius: '8px',
      fontFamily: 'Arial, sans-serif',
      fontSize: '18px',
      zIndex: '9999',
      boxShadow: '0 0 12px rgba(0,0,0,0.7)',
      border: '1px solid #555',
      boxSizing: 'border-box',
      wordWrap: 'break-word'
    });
    document.body.appendChild(container);
  }
  return container;
}

function stopSpeechSynthesis() {
  if ('speechSynthesis' in window && speechSynthesis.speaking) speechSynthesis.cancel();
}

function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

function createControlButtons() {
  let container = document.getElementById('newsControlButtons');
  if (!container) {
    container = document.createElement('div');
    container.id = 'newsControlButtons';

    const newsContainer = getOrCreateNewsDisplayContainer();
    const rect = newsContainer.getBoundingClientRect();

    Object.assign(container.style, {
      position: 'fixed',
      top: (rect.top + rect.height + 5) + 'px',
      right: (window.innerWidth - (rect.left + rect.width)) + 'px',
      left: 'auto',
      zIndex: '10000',
      backgroundColor: 'rgba(0,0,0,0.6)',
      padding: '8px',
      borderRadius: '8px',
      color: 'white',
      fontFamily: 'Arial, sans-serif',
      display: 'flex',
      gap: '10px',
      alignItems: 'center'
    });

    document.body.appendChild(container);
  }

  // Request számláló
  let counter = document.getElementById('requestCounter');
  if (!counter) {
    counter = document.createElement('span');
    counter.id = 'requestCounter';
    counter.style.fontWeight = 'bold';
    counter.style.fontSize = '16px';
    container.appendChild(counter);
  }
  counter.textContent = `Kérések száma: ${requestCount}`;

  // Reset gomb
  let resetBtn = document.getElementById('resetRequestCounterBtn');
  if (!resetBtn) {
    resetBtn = document.createElement('button');
    resetBtn.id = 'resetRequestCounterBtn';
    resetBtn.textContent = 'Reset';
    Object.assign(resetBtn.style, {
      cursor: 'pointer',
      padding: '6px 12px',
      fontSize: '16px',
      borderRadius: '4px',
      border: 'none',
      backgroundColor: '#cc3300',
      color: 'white'
    });
    resetBtn.addEventListener('click', () => {
      requestCount = 0;
      localStorage.setItem('requestCount', '0');
      counter.textContent = `Kérések száma: ${requestCount}`;
    });
    container.appendChild(resetBtn);
  }

  // Shuffle kapcsoló gomb
  let shuffleBtn = document.getElementById('shuffleToggleBtn');
  if (!shuffleBtn) {
    shuffleBtn = document.createElement('button');
    shuffleBtn.id = 'shuffleToggleBtn';
    shuffleBtn.textContent = isShuffleOn ? 'Random ON' : 'Random OFF';
    Object.assign(shuffleBtn.style, {
      cursor: 'pointer',
      padding: '6px 12px',
      fontSize: '16px',
      borderRadius: '4px',
      border: 'none',
      backgroundColor: isShuffleOn ? '#009900' : '#666666',
      color: 'white'
    });
    shuffleBtn.addEventListener('click', () => {
      isShuffleOn = !isShuffleOn;
      localStorage.setItem('isShuffleOn', isShuffleOn.toString());
      shuffleBtn.textContent = isShuffleOn ? 'Random ON' : 'Random OFF';
      shuffleBtn.style.backgroundColor = isShuffleOn ? '#009900' : '#666666';
      if (articles.length > 0) {
        if (isShuffleOn) {
          shuffleArray(articles);
        } else if (lastQuery) {
          fetchAndReadNews_7d18(lastQuery);
          return;
        }
        currentArticleIndex = 0;
        stopSpeechSynthesis();
        showArticle(currentArticleIndex);
      }
    });
    container.appendChild(shuffleBtn);
  }

  // Következő hír gomb
  let nextBtn = document.getElementById('nextNewsBtn');
  if (!nextBtn) {
    nextBtn = document.createElement('button');
    nextBtn.id = 'nextNewsBtn';
    nextBtn.textContent = 'Következő hír';
    Object.assign(nextBtn.style, {
      cursor: 'pointer',
      padding: '6px 12px',
      fontSize: '16px',
      borderRadius: '4px',
      border: 'none',
      backgroundColor: '#0055cc',
      color: 'white'
    });
    nextBtn.addEventListener('click', () => {
      stopSpeechSynthesis();
      showNextArticle();
    });
    container.appendChild(nextBtn);
  }

  // Max cikkszám választó
  let maxSelect = document.getElementById('maxArticlesSelect');
  if (!maxSelect) {
    maxSelect = document.createElement('select');
    maxSelect.id = 'maxArticlesSelect';
    maxSelect.title = 'Max cikkszám beállítása';
    [1, 5, 10, 25, 50].forEach(num => {
      const option = document.createElement('option');
      option.value = num;
      option.textContent = num;
      if (num === maxArticles) option.selected = true;
      maxSelect.appendChild(option);
    });
    Object.assign(maxSelect.style, {
      cursor: 'pointer',
      padding: '6px 8px',
      fontSize: '16px',
      borderRadius: '4px',
      border: 'none',
      backgroundColor: '#0044aa',
      color: 'white'
    });
    maxSelect.addEventListener('change', () => {
      maxArticles = parseInt(maxSelect.value, 10);
      localStorage.setItem('maxArticles', maxArticles);
      if (articles.length > 0) {
        currentArticleIndex = 0;
        stopSpeechSynthesis();
        showArticle(currentArticleIndex);
      }
    });
    container.appendChild(maxSelect);
  }

  // Sebesség beállító wrapper
  let speedWrapper = document.getElementById('speechSpeedWrapper');
  if (!speedWrapper) {
    speedWrapper = document.createElement('div');
    speedWrapper.id = 'speechSpeedWrapper';
    speedWrapper.style.display = 'flex';
    speedWrapper.style.alignItems = 'center';
    speedWrapper.style.gap = '6px';
    speedWrapper.style.color = 'white';

speedWrapper.style.top = '80px';    // 10 pixelrel lentebb
speedWrapper.style.left = '80px';   // 10 pixelrel jobbra
    const label = document.createElement('label');
    label.textContent = 'Sebesség:';
    label.style.userSelect = 'none';

    const speedInput = document.createElement('input');
    speedInput.id = 'speechSpeedInput';
    speedInput.type = 'range';
    speedInput.min = 0.5;
    speedInput.max = 2.0;
    speedInput.step = 0.1;
    speedInput.value = localStorage.getItem('speechSpeed') || 1;

    const speedValueDisplay = document.createElement('span');
    speedValueDisplay.id = 'speechSpeedValue';
    speedValueDisplay.textContent = speedInput.value;

    speedInput.addEventListener('input', () => {
      speedValueDisplay.textContent = speedInput.value;
    });

    speedInput.addEventListener('change', () => {
      localStorage.setItem('speechSpeed', speedInput.value);
      stopSpeechSynthesis();
      if (articles.length > 0) {
        showArticle(currentArticleIndex);
      }
    });

    speedWrapper.appendChild(label);
    speedWrapper.appendChild(speedInput);
    speedWrapper.appendChild(speedValueDisplay);

    container.appendChild(speedWrapper);
  }

  // Exit gomb
  let exitBtn = document.getElementById('exitBtn');
  if (!exitBtn) {
    exitBtn = document.createElement('button');
    exitBtn.id = 'exitBtn';
    exitBtn.textContent = 'Kilépés';
    Object.assign(exitBtn.style, {
      cursor: 'pointer',
      padding: '6px 12px',
      fontSize: '16px',
      borderRadius: '4px',
      border: 'none',
      backgroundColor: '#cc0000',
      color: 'white'
    });
    exitBtn.addEventListener('click', () => {
      stopSpeechSynthesis();

      // Panel eltávolítása
      const newsContainer = document.getElementById('newsDisplayContainer');
      if (newsContainer) newsContainer.remove();

      // Vezérlőgombok eltávolítása
      const controlButtons = document.getElementById('newsControlButtons');
      if (controlButtons) controlButtons.remove();

      // Kereső input és gomb eltávolítása
      const searchContainer = document.getElementById('newsSearchContainer');
      if (searchContainer) searchContainer.remove();
    });

    container.appendChild(exitBtn);
  }

  // Random gomb
  let alertBtn = document.getElementById('alertBtn');
  if (!alertBtn) {
    alertBtn = document.createElement('button');
    alertBtn.id = 'alertBtn';
    alertBtn.textContent = 'Random';
    Object.assign(alertBtn.style, {
      cursor: 'pointer',
      padding: '6px 12px',
      fontSize: '16px',
      borderRadius: '4px',
      border: 'none',
      backgroundColor: '#ffaa00',
      color: 'black'
    });
    alertBtn.addEventListener('click', () => {
      stopSpeechSynthesis();
      // Panel és gombok eltávolítása
      const newsContainer = document.getElementById('newsDisplayContainer');
      if (newsContainer) newsContainer.remove();
      const controlButtons = document.getElementById('newsControlButtons');
      if (controlButtons) controlButtons.remove();

      // Itt folytathatod a saját logikáddal...
      ujsag();

    });
    container.appendChild(alertBtn);
  }

  // Alert gomb wrapper és elhelyezése
  let alertWrapper = document.getElementById('alertBtnWrapper');
  if (!alertWrapper) {
    alertWrapper = document.createElement('div');
    alertWrapper.id = 'alertBtnWrapper';
    alertWrapper.style.marginTop = '100px';  // távolság a többi gombtól
    container.appendChild(alertWrapper);
  }

  alertWrapper.appendChild(alertBtn);
}










function createSearchInputWithButton() {
  let container = document.getElementById('newsSearchContainer');
  if (!container) {
    container = document.createElement('div');
    container.id = 'newsSearchContainer';
    Object.assign(container.style, {
      position: 'fixed',
      bottom: '300px',       // a paneltől kb. 100px-re
      right: '10px',
      width: '340px',     // input + gomb szélessége együtt
      display: 'flex',
      gap: '8px',
      zIndex: '10001',
      boxSizing: 'border-box',
      fontFamily: 'Arial, sans-serif'
    });
    document.body.appendChild(container);
  }

  let input = document.getElementById('newsSearchInput');
  if (!input) {
    input = document.createElement('input');
    input.id = 'newsSearchInput';
    input.type = 'text';
    input.placeholder = 'Keresés hírekben...';
    Object.assign(input.style, {
      flexGrow: '1',
      padding: '8px 12px',
      fontSize: '16px',
      borderRadius: '6px',
      border: '1px solid #ccc',
      outline: 'none',
      boxSizing: 'border-box'
    });

    // Enter lenyomásakor is induljon a keresés
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        triggerSearch();
      }
    });

    container.appendChild(input);
  }

  let button = document.getElementById('newsSearchBtn');
  if (!button) {
    button = document.createElement('button');
    button.id = 'newsSearchBtn';
    button.textContent = 'Keresés';
    Object.assign(button.style, {
      padding: '8px 16px',
      fontSize: '16px',
      borderRadius: '6px',
      border: 'none',
      backgroundColor: '#0055cc',
      color: 'white',
      cursor: 'pointer',
      userSelect: 'none'
    });

    button.addEventListener('click', () => {
      triggerSearch();
    });

    container.appendChild(button);
  }

  function triggerSearch() {
    const query = input.value.trim();
    if (query.length > 0) {
      stopSpeechSynthesis();
      fetchAndReadNews_7d18(query);
    }
  }

  return { input, button };
}





async function showArticle(index) {
  stopSpeechSynthesis();

  const newsContainer = getOrCreateNewsDisplayContainer();

  if (index < 0 || index >= articles.length) {
    newsContainer.innerHTML = 'Nincs több hír.';
    await speakText_7d18('Nincs több hír.');
    return;
  }

  const article = articles[index];

  // Megjelenített szöveg (HTML-ben a link szöveggel)
  const displayTextParts = [
    `Cikk ${index + 1}. címe: ${article.title}.`,
    article.description ? `Leírás: ${article.description}.` : '',
    `Forrás: ${article.source.name}.`,
    `Megjelent: ${new Date(article.publishedAt).toLocaleDateString('hu-HU')}.`,
    `További információ a következő linken: <a href="${article.url}" target="_blank">${article.url}</a>.`
  ].filter(Boolean).join(' ');

  newsContainer.innerHTML = '';
  const articleElem = document.createElement('div');
  Object.assign(articleElem.style, {
    marginBottom: '15px',
    borderBottom: '1px solid #ccc',
    paddingBottom: '10px',
    cursor: 'pointer'
  });

  articleElem.innerHTML = displayTextParts; // itt HTML-t használunk a linkhez
  articleElem.dataset.url = article.url;

  articleElem.addEventListener('click', function() {
  	stopSpeaking();
    window.open(this.dataset.url, '_blank');
  });

  newsContainer.appendChild(articleElem);
  newsContainer.style.opacity = '1';

  // Felolvasandó szöveg: NEM tartalmazza a „További információ...” szöveget, csak a link nélküli részt
  const speechTextParts = [
    `Cikk ${index + 1}. címe: ${article.title}.`,
    article.description ? `Leírás: ${article.description}.` : '',
    `Forrás: ${article.source.name}.`,
    `Megjelent: ${new Date(article.publishedAt).toLocaleDateString('hu-HU')}.`
  ].filter(Boolean).join(' ');

  await speakText_7d18(speechTextParts);

  currentArticleIndex++;
  if (currentArticleIndex >= Math.min(maxArticles, articles.length)) currentArticleIndex = 0;
  showArticle(currentArticleIndex);
}



function showNextArticle() {
  if (articles.length === 0) return;
  currentArticleIndex++;
  if (currentArticleIndex >= Math.min(maxArticles, articles.length)) currentArticleIndex = 0;
  showArticle(currentArticleIndex);
}

function showPreviousArticle() {
  if (articles.length === 0) return;
  currentArticleIndex--;
  if (currentArticleIndex < 0) currentArticleIndex = Math.min(maxArticles, articles.length) - 1;
  showArticle(currentArticleIndex);
}


async function fetchAndReadNews_7d18(query = 'gazdaság') {
  lastQuery = query;

  requestCount++;
  localStorage.setItem('requestCount', requestCount.toString());
  const counterElem = document.getElementById('requestCounter');
  if (counterElem) counterElem.textContent = `Kérések száma: ${requestCount}`;

  const url = `https://newsapi.org/v2/everything?q=${encodeURIComponent(query)}&language=hu&sortBy=publishedAt&apiKey=${newsApiKey_7d18}`;

  const newsContainer = getOrCreateNewsDisplayContainer();

  try {
    const response = await fetch(url);
    if (!response.ok) throw new Error(`HTTP hiba: ${response.status}`);
    const newsData = await response.json();

    if (newsData.articles && newsData.articles.length > 0) {
      articles = newsData.articles.slice(0, maxArticles);
      if (isShuffleOn) shuffleArray(articles);
      currentArticleIndex = 0;
      createControlButtons();
      await showArticle(currentArticleIndex);
    } else {
      articles = [];
      newsContainer.innerHTML = '';
      const noNewsText = 'Nincs találat a keresésre.';
      const noNewsElem = document.createElement('div');
      noNewsElem.textContent = noNewsText;
      newsContainer.appendChild(noNewsElem);
      newsContainer.style.opacity = '1';
      console.log(noNewsText);
      await speakText_7d18(noNewsText);
      newsContainer.style.opacity = '0';
    }
  } catch (error) {
    articles = [];
    newsContainer.innerHTML = '';
    const errorElem = document.createElement('div');
    errorElem.textContent = 'Hiba történt a hírek lekérésekor.';
    newsContainer.appendChild(errorElem);
    newsContainer.style.opacity = '1';
    console.error('Hiba a hírek lekérésekor:', error);
    await speakText_7d18('Hiba történt a hírek lekérésekor.');
    newsContainer.style.opacity = '0';
  }
}

function speakText_7d18(text) {
  return new Promise((resolve) => {
    if ('speechSynthesis' in window) {
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = 'hu-HU';

      const savedSpeed = localStorage.getItem('speechSpeed');
      utterance.rate = savedSpeed ? parseFloat(savedSpeed) : 1;

      utterance.onend = () => resolve();
      speechSynthesis.speak(utterance);
    } else {
      console.log('A böngésződ nem támogatja a szövegfelolvasást.');
      resolve();
    }
  });
}






const cityTranslation = {
  'budapest': 'budapest',
  'bécs': 'vienna',
  'wien': 'vienna',
  'prága': 'prague',
  'pozsony': 'bratislava',
  'münchen': 'munich',
  'varsó': 'warsaw',
  'krakkó': 'krakow',
  'kassa': 'kosice',
  'nagyszeben': 'sibiu',
  'marosvásárhely': 'targu mures',
  'kolozsvár': 'cluj-napoca',
  'szabadka': 'subotica',
  'újvidék': 'novi sad',
  'temesvár': 'timisoara',
  'szeged': 'szeged',
  'debrecen': 'debrecen',
  'moszkva': 'moscow',
  'amsterdam': 'amsterdam',
  'amszterdam': 'amsterdam',
  'róma': 'rome',
  // további városok, helyszínek...
};



recognition.onresult = async function(event) {
  var last = event.results.length - 1;
  var text = event.results[last][0].transcript.trim().toLowerCase();
  console.log('Felismert szöveg : ' + text);

  if (text.includes('weather') || text.includes('időjárás')) {
    let words = text.split(' ');
    let city = null;

    // Keresünk olyan szót, ami nem "weather" vagy "időjárás"
    for (let w of words) {
      if (w !== 'weather' && w !== 'időjárás') {
        city = w;
        break;
      }
    }

    if (city) {
      // Fordítás angolra, ha van a szótárban
      let cityEn = cityTranslation[city] || city;
      try {
        const weatherData = await fetchWeather(cityEn);
        if (weatherData) {
          const uvIndex = weatherData.current.uv;
          const temp = weatherData.current.temp_c;
          const localTime = new Date(weatherData.location.localtime);
          const timeStr = localTime.getHours().toString().padStart(2,'0') + ':' + localTime.getMinutes().toString().padStart(2,'0');
          const conditionText = weatherData.current.condition.text; // angolul

          const speechText = `${city} aktuális időjárása: UV index ${uvIndex}, hőmérséklet ${temp} Celsius fok, helyi idő: ${timeStr}.`;
          await speakText(speechText);
          await speakText(`Weather condition: ${conditionText}.`);
        }
      } catch (err) {
        console.error('Időjárás lekérés hiba:', err);
        speakText('Nem sikerült lekérni az időjárási adatokat.');
      }
    } else {
      speakText('Kérlek, mondj egy városnevet az időjárás lekéréséhez.');
    }
    return;
  }
  // ... további parancsok



  
  
  
  
  
  
  var last = event.results.length - 1;
var text = event.results[last][0].transcript.trim().toUpperCase();
console.log('Felismert szöveg: ' + text);

// Ellenőrzés, hogy a text szerepel-e a commands objektumban
if (commands.hasOwnProperty(text)) {
  console.log(`Parancs felismerve: ${text}`);
  
  playany(['snd/button/Digital high tech beep 1.mp3', 'snd/button/mixkit-game-ball-tap-2073.wav', 'snd/button/mixkit-quick-jump-arcade-game-239.wav'], 1);
  
}

var recognizedTextElement = document.getElementById('recognizedText');
if (!recognizedTextElement) {
  recognizedTextElement = document.createElement('div');
  recognizedTextElement.id = 'recognizedText';
  Object.assign(recognizedTextElement.style, {
    position: 'fixed',
    bottom: '10px',
    left: '50%',
    transform: 'translateX(-50%)',
    backgroundColor: 'rgba(0,0,0,0.7)',
    color: 'white',
    padding: '10px 20px',
    borderRadius: '10px',
    fontSize: '18px',
    fontFamily: 'Arial, sans-serif',
    zIndex: '10000',
    opacity: '0',
    transition: 'opacity 0.3s ease'
  });
  document.body.appendChild(recognizedTextElement);
}
recognizedTextElement.textContent = text;

// Opció: megjelenítés animációval (pl. 2 mp-ig látható)
recognizedTextElement.style.opacity = '1';
setTimeout(() => {
  recognizedTextElement.style.opacity = '0';
}, 2000);

  
  
  if (text === 'NEWS RANDOM' || text === 'ÚJSÁG') {
    recognizedTextElement.style.color = 'purple';
    recognizedTextElement.style.textShadow = 'none';
    console.log('News random keresés indítása');
    newsflag = 1;
    await randomWordFunction();
    if (typeof rndWord === 'string' && rndWord.length > 0) {
      console.log(`Random szó a kereséshez: ${rndWord}`);
      await fetchAndReadNews_7d18(rndWord);
    } else {
      console.log('Nem sikerült random szót generálni.');
      await speakText_7d18('Nem sikerült random szót generálni.');
    }
    return;
  }

  if (text.startsWith('NEWS ')) {
    const words = text.split(/\s+/);
    if (words.length >= 2) {
      const keresettSzó = words[1].toLowerCase();
      recognizedTextElement.style.color = 'blue';
      recognizedTextElement.style.textShadow = 'none';
      console.log(`News keresés indítása: ${keresettSzó}`);
      await fetchAndReadNews_7d18(keresettSzó);
      return;
    } else {
      recognizedTextElement.style.color = 'red';
      recognizedTextElement.textContent = 'Kérlek, mondj egy keresőszót a "news" után!';
      await speakText_7d18('Kérlek, mondj egy keresőszót a news után!');
      return;
    }
  }

  var isCommand = false;
  for (var command in commands) {
    if (text.includes(command)) {
      recognizedTextElement.style.color = 'green';
      if (typeof window[commands[command]] === 'function') {
        window[commands[command]]();
      } else {
        console.warn(`Nincs definiálva a(z) ${commands[command]} függvény.`);
      }
      isCommand = true;
      break;
    }
  }

  if (!isCommand) {
  recognizedTextElement.style.color = 'white';
  recognizedTextElement.style.textShadow = '2px 2px 4px rgba(0, 0, 0, 0.5)';
  recognizedTextElement.style.zIndex = '10001';
  recognizedTextElement.style.opacity = '1';
  
  // A felismerési szöveg megjelenítése a buborékban
  showBubble('Nem ismert parancs: ' + text, 'rgb(201,91,51)', [40, 300]);
}

  recognizedTextElement.style.opacity = '1';

  var audio = new SpeechSynthesisUtterance(text);
  audio.lang = 'hu-HU';
  audio.volume = 1;
  audio.pitch = 1.0;
  audio.rate = 0.3 + Math.random() * 0.4;
  speechSynthesis.speak(audio);

  setTimeout(() => {
    recognizedTextElement.style.opacity = '0';
  }, 3000);












 







// Ellenőrizzük, hogy a felismert szöveg szám-e
var text = text.toUpperCase();
var numText = text.replace(/[^0-9]/g, '');
// Ellenőrizzük, hogy a felismert szöveg szám-e
var text = text.toUpperCase();
if (text === "EGY" || text === "1") {
    recogbookNum = 1;
    BookNum(recogbookNum);
    //alert(recogbookNum);
} else if (text === "KETT" || text === "2") {
    recogbookNum = 2;
    BookNum(recogbookNum);
    //alert(recogbookNum);
} else if (text === "HÁROM" || text === "3") {
    recogbookNum = 3;
    BookNum(recogbookNum);
    //alert(recogbookNum);
} else if (text === "NÉGY" || text === "4") {
    recogbookNum = 4;
    BookNum(recogbookNum);
    //alert(recogbookNum);
} else if (text === "ÖT" || text === "5") {
    recogbookNum = 5;
    BookNum(recogbookNum);
    //alert(recogbookNum);
} else if (text === "HAT" || text === "6") {
    recogbookNum = 6;
    BookNum(recogbookNum);
    //alert(recogbookNum);
} else if (text === "HET" || text === "7") {
    recogbookNum = 7;
    BookNum(recogbookNum);
    //alert(recogbookNum);
} else if (text === "NYOLC" || text === "8") {
    recogbookNum = 8;
    BookNum(recogbookNum);
    //alert(recogbookNum);
} else if (text === "KILENC" || text === "9") {
    recogbookNum = 9;
    BookNum(recogbookNum);
    //alert(recogbookNum);
} else {
    var numText = text.replace(/[^0-9]/g, '');
    if (!isNaN(parseInt(numText))) {
        recogbookNum = parseInt(numText);
     //   alert(recogbookNum);
     BookNum(recogbookNum);
     
     


     
    }
    
}
// A four() funkció 6 másodperc múlva lesz végrehajtva
currentbooknumber = recogbookNum;
//alert(currentbooknumber);

//setTimeout(bookpercent, 5000);
//setTimeout(four, 6000);

}


// százalékos kijelzés a html-ben
document.getElementById("TheSlider").addEventListener("input", bookpercent2);

function bookpercent2() {
	readpercentage = Math.round((currentsentencenumber / allsentencenumber) * 100);
let percentshow = readpercentage;
let readpercentageText = percentshow + "%";
    document.getElementById("readpercentagehtml").textContent = readpercentageText;
}

// felolvasáshoz
function bookpercent() {
	
	
	
	let readpercentage = Math.round((currentsentencenumber / allsentencenumber) * 100);
	
	
	
	
        readpercentage = (readpercentage + " százalék." + " ");
        
        
    
        console.log(readpercentage); 
        var textToRead2 = readpercentage;
        var lang2 = 'hu-Hun';
        var audio2 = new SpeechSynthesisUtterance(textToRead2);
        audio2.lang = lang2;
        audio2.rate = 0.6;
        audio2.volume = 0.5; // Hangerő beállítása (0.1 - 1 közötti érték)
        audio2.pitch = 1.0;
        speechSynthesis.speak(audio2);
        // csak fun
        //readany = ("yeah."); // lehet funkción kívül, de a funkció nevekre figyelni és Buttonkell
        //readanytext();
        
        
        
        /*
        csak az egyszerű felfoghatóság miatt kommenteltem ki az összoldalszámot
        var textToRead2 = allsentencenumber;
        var audio2 = new SpeechSynthesisUtterance(textToRead2);
        speechSynthesis.speak(audio2);
        */
        
        }
        
        



function showCommandInfo(command, functionName) {
    var infoModal = document.createElement('div');
    infoModal.classList.add('info-modal');
    infoModal.innerHTML = '<div class="info-modal-content"><h2>Vezényszavak</h2><ul></ul><button class="close-button">Bezár</button></div>';
    var infoList = infoModal.querySelector('ul');

    for (var cmd in commands) {
        var listItem = document.createElement('li');
        listItem.textContent = cmd + ' - ' + commands[cmd];
        infoList.appendChild(listItem);
    }

    document.body.appendChild(infoModal);

    var closeButton = infoModal.querySelector('.close-button');
    closeButton.addEventListener('click', function() {
        infoModal.remove();
    });

    // Az infoModal eltávolítása 30 másodperc elteltével
    setTimeout(function() {
        infoModal.remove();
    }, 30000);

/*
    // Szöveg kinyerése a modális ablakból
    var textToRead = infoModal.querySelector('h2').textContent + '\n';
var listItems = infoModal.querySelectorAll('li');
listItems.forEach(function(item) {
    textToRead += item.textContent + '\n';
});


    // Szöveg felolvasása bugos!!
  //  readanytexthun(textToRead);
  */
  
}



//Folytasd. A document.getElementById('current-letter') tartalmát olvassa ki és ha nem üres akkor indítson új ablakban google keresést a tartalom-ra.

//Ha üres lenne a document.getElementById('current-letter') akkor a document.getElementById('selectedtextblock') tartalmát olvassa ki és indítson új ablakban google keresést a tartalom-ra.

function gugliSearch() {
    var content = document.getElementById('current-letter').textContent;
    if (content.trim() === '') {
        content = document.getElementById('selectedtextblock').textContent;
    }
    if (content.trim() !== '') {
        window.open('https://www.google.com/search?q=' + content, '_blank');
    }
}
	
	
function diktálás() {
// Whistle tune from "The Good, The Bad and The Ugly"
//playoscilla(392, 200); // G4
playoscilla(519, 100); // F4
playoscilla(392, 100); // G4
playoscilla(349, 150); // F4
playoscilla(392, 100); // G4
playoscilla(523, 200); // C5
playoscilla(392, 100); // G4
    // Nyissa meg a címet egy új ablakban
  //  var url = 'https://gregrutor.000webhostapp.com/hanfel/hanfel.html';
 //   window.open(url, '_blank');
    
    fetch('hanfel/hanfel.html')
    .then(response => response.text())
    .then(htmlContent => {
      let win = window.open('', '_blank', 'width=600,height=450');
      win.document.write(htmlContent);
      win.document.close();
    })
    .catch(err => alert('Nem sikerült betölteni a fájlt: ' + err));
    
}


function fejlesztoi() {
// Whistle tune from "The Good, The Bad and The Ugly"
//playoscilla(392, 200); // G4
playoscilla(519, 100); // F4
playoscilla(392, 100); // G4
playoscilla(349, 150); // F4
playoscilla(392, 100); // G4
playoscilla(523, 200); // C5
playoscilla(392, 100); // G4
    // Nyissa meg a címet egy új ablakban
  //  var url = 'https://gregrutor.000webhostapp.com/hanfel/hanfel.html';
 //   window.open(url, '_blank');
    
    fetch('fejlesztői playany fullextra.html')
    .then(response => response.text())
    .then(htmlContent => {
      let win = window.open('', '_blank', 'width=600,height=450');
      win.document.write(htmlContent);
      win.document.close();
    })
    .catch(err => alert('Nem sikerült betölteni a fájlt: ' + err));
    
}




function infoFunkcio() {
	
	//function showCommandInfo
	
    console.log('Info funkció elindítva!');
    stopMonitoring();
}

let kaland;

function kalandjatekkockazatOnOff() {
  // Játék kockázat hang lejátszása
  
  // Toggle a kaland változó értékét
  kaland = !kaland;
  
  if (kaland === true) {
  	
  playoscilla(392, 100); // G4
  playoscilla(349, 150); // F4


}
  
  // Ellenőrizzük a kaland változó értékét és írjunk ki egy tesztet
  //console.log(kaland);
  if (kaland === false) {
    console.log("false kaland");
    //stopPlayany();
    playoscilla(392, 100); // G4
    playoscilla(349, 150); // F4
  }
}


// hangfel egyszer end



////// mars naplózás

//marsSave(bookname);
//mars();


function marsSave(bookName) {
  const now = new Date();

  // Dátum és idő formázása: ÉÉÉÉ-HH-NN ÓÓ:PP
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  const hour = String(now.getHours()).padStart(2, '0');
  const minute = String(now.getMinutes()).padStart(2, '0');

  const formattedDate = `${year}-${month}-${day} ${hour}:${minute}`;

  // Kiolvassuk a korábbi listát (tömböt)
  let marsList = [];
  const stored = localStorage.getItem('mars');
  if (stored) {
    try {
      marsList = JSON.parse(stored);
      if (!Array.isArray(marsList)) marsList = [];
    } catch {
      marsList = [];
    }
  }

  // Új elem hozzáadása az elejére (legújabb lesz elöl)
  marsList.unshift({
    bookName: bookName,
    savedAt: formattedDate
  });

  // Mentés vissza localStorage-ba
  localStorage.setItem('mars', JSON.stringify(marsList));
}




let marsContainer;

function mars() {
  if (marsContainer) {
    marsContainer.remove();
  }

  const marsDataRaw = localStorage.getItem('mars');
  if (!marsDataRaw) {
    alert('Nincs elmentett Mars adat.');
    return;
  }

  let marsList;
  try {
    marsList = JSON.parse(marsDataRaw);
    if (!Array.isArray(marsList) || marsList.length === 0) {
      alert('Nincs elmentett Mars adat.');
      return;
    }
  } catch {
    alert('Hibás Mars adat formátum.');
    return;
  }

  marsContainer = document.createElement('div');
  marsContainer.className = 'marsContainer';
  marsContainer.style.position = 'fixed';
  marsContainer.style.top = '0';
  marsContainer.style.left = '0';
  marsContainer.style.width = '100%';
  marsContainer.style.height = '100%';
  marsContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
  marsContainer.style.display = 'flex';
  marsContainer.style.justifyContent = 'center';
  marsContainer.style.alignItems = 'center';
  marsContainer.style.zIndex = '9999';
  marsContainer.style.opacity = '0';
  marsContainer.style.transition = 'opacity 0.5s ease-in-out';

  const marsContent = document.createElement('div');
  marsContent.style.backgroundColor = 'rgba(200, 100, 100, 0.9)';
  marsContent.style.padding = '20px 30px';
  marsContent.style.borderRadius = '8px';
  marsContent.style.maxWidth = '400px';
  marsContent.style.maxHeight = '70vh'; // Magasság korlátozása, hogy legyen görgetés
  marsContent.style.overflowY = 'auto';
  marsContent.style.color = 'white';
  marsContent.style.fontSize = '18px';
  marsContent.style.fontFamily = 'Arial, sans-serif';
  marsContent.style.boxShadow = '0 0 15px rgba(0,0,0,0.6)';
  marsContent.style.cursor = 'pointer';

  // Fejléc
  const header = document.createElement('h2');
  header.textContent = 'Mars könyvek listája';
  header.style.marginBottom = '15px';
  marsContent.appendChild(header);

  // Lista elemek hozzáadása
  marsList.forEach((item, index) => {
    const p = document.createElement('p');
    p.style.marginBottom = '12px';
    p.style.padding = '8px';
    p.style.borderRadius = '5px';
    p.style.backgroundColor = index % 2 === 0 ? 'rgba(255, 255, 255, 0.1)' : 'rgba(255, 255, 255, 0.2)';
    p.innerHTML = `<strong>${item.bookName}</strong><br><small>${item.savedAt}</small>`;
    marsContent.appendChild(p);
  });

  // Bezárás kattintásra
  marsContent.addEventListener('click', () => {
    marsContainer.style.opacity = '0';
    setTimeout(() => {
      if (marsContainer) marsContainer.remove();
      marsContainer = null;
    }, 500);
  });

  marsContainer.appendChild(marsContent);
  document.body.appendChild(marsContainer);

  setTimeout(() => {
    marsContainer.style.opacity = '1';
  }, 50);

  // Beszéd szintetizálás: összes könyv számának beolvasása
  const speechText = `Összesen ${marsList.length} könyv van elmentve. A legújabb: ${marsList[0].bookName}, mentve: ${marsList[0].savedAt}.`;
  const utterance = new SpeechSynthesisUtterance(speechText);
  speechSynthesis.speak(utterance);
}


function marsClear() {
  const confirmClear = confirm('Biztosan törölni szeretnéd a Mars adatok tartalmát? Ez a művelet nem visszavonható.');
  if (confirmClear) {
    // Üres tömböt mentünk a "mars" kulcs alá, így töröljük a benne lévő adatokat, de a kulcs megmarad
    localStorage.setItem('mars', JSON.stringify([]));
    alert('A Mars adatok tartalma törölve lett.');
  } else {
    alert('A Mars adatok tartalma nem lett törölve.');
  }
}




// Időjárás lekérő függvény WeatherAPI-ról
async function fetchWeather(city) {
  const apiKey = 'abd7bd86bde4449ba8c80819230411';
  const url = `https://api.weatherapi.com/v1/current.json?key=${apiKey}&q=${encodeURIComponent(city)}`;
  const response = await fetch(url);
  if (!response.ok) throw new Error('Hálózati hiba');
  const data = await response.json();
  if (data.error) throw new Error(data.error.message);
  return data;
}

// Hangos felolvasás
function speakText(text) {
  if (!('speechSynthesis' in window)) return;
  window.speechSynthesis.cancel();
  const utterance = new SpeechSynthesisUtterance(text);
  utterance.lang = 'hu-HU';
  window.speechSynthesis.speak(utterance);
}

// Opció: megjelenítés az oldalon
function showRecognizedText(text) {
  let elem = document.getElementById('recognizedText');
  if (!elem) {
    elem = document.createElement('div');
    elem.id = 'recognizedText';
    Object.assign(elem.style, {
      position: 'fixed',
      bottom: '10px',
      left: '50%',
      transform: 'translateX(-50%)',
      backgroundColor: 'rgba(0,0,0,0.7)',
      color: 'white',
      padding: '10px 20px',
      borderRadius: '10px',
      fontSize: '18px',
      fontFamily: 'Arial, sans-serif',
      zIndex: '10000',
      opacity: '1',
      transition: 'opacity 0.3s ease'
    });
    document.body.appendChild(elem);
  }
  elem.textContent = text;
  setTimeout(() => { elem.style.opacity = '0'; }, 3000);
}




function random() {

stopSpeaking();
     //   randomBooknewAndrandomsentence();
     randomBooknew();
        setTimeout(randomSentence, 4000);
  setTimeout(readTextinfinite, 6000);
  
}






// Globális olvasási sebesség változó, betöltés localStorage-ból vagy alapértelmezett 1.0
//var olvassebesseg = parseFloat(localStorage.getItem('olvassebesseg')) || 1.0;

// Globális timeout ID a slider eltüntetéséhez
var sliderTimeoutId = null;

// Gyorsabb funkció: növeli 0.1-gyel, max 5, és megjeleníti a slider-t

//let olvassebesseg = 1.0;  // alapértelmezett érték
//let sliderTimeoutId = null;

function gyorsabb() {
  // Növeljük 0.1-gyel, majd kerekítjük egy tizedesre és max 5
  olvassebesseg = Math.round((olvassebesseg + 0.1) * 10) / 10;
  olvassebesseg = Math.min(olvassebesseg, 5);

  console.log("Olvasási sebesség gyorsabb: " + olvassebesseg.toFixed(1));

  // Frissítés localStorage-ban
  localStorage.setItem('olvassebesseg', olvassebesseg.toFixed(1));

  showVerticalSliderWithValue(olvassebesseg);
}

// Slider és értékkijelző létrehozása, megjelenítése, eltüntetése 10 mp után
function showVerticalSliderWithValue(value) {
  // Ha már van slider konténer, töröljük
  const existingContainer = document.getElementById('uniqueSliderContainer');
  if (existingContainer) {
    existingContainer.remove();
  }

  // Ha fut timeout, töröljük, hogy ne legyen galiba
  if (sliderTimeoutId !== null) {
    clearTimeout(sliderTimeoutId);
    sliderTimeoutId = null;
  }

  // Konténer létrehozása
  const container = document.createElement('div');
  container.id = 'uniqueSliderContainer';
  Object.assign(container.style, {
    position: 'fixed',
    top: '50%',
    right: '20px',
    transform: 'translateY(-50%)',
    zIndex: 9999,
    userSelect: 'none',
    textAlign: 'center',
    fontFamily: 'Arial, sans-serif',
    color: '#333',
  });

  // Slider létrehozása
  const slider = document.createElement('input');
  slider.type = 'range';
  slider.min = '0.1';
  slider.max = '5';
  slider.step = '0.1';
  slider.value = value.toFixed(1);
  slider.id = 'uniqueVerticalSlider';

  Object.assign(slider.style, {
    width: '300px',   // megnövelt hossz
    height: '40px',   // megnövelt vastagság
    WebkitAppearance: 'none',
    appearance: 'none',
    background: '#ddd',
    borderRadius: '5px',
    outline: 'none',
    cursor: 'pointer',
    position: 'relative',
    transform: 'rotate(-90deg)',
    marginBottom: '10px',
  });

  // Értékkijelző létrehozása
  const valueDisplay = document.createElement('div');
  valueDisplay.id = 'uniqueSliderValue';
  valueDisplay.textContent = value.toFixed(1);
  Object.assign(valueDisplay.style, {
    fontWeight: 'bold',
    fontSize: '1.4em',
    background: 'rgba(255, 255, 255, 0.9)',
    padding: '6px 12px',
    borderRadius: '6px',
    boxShadow: '0 2px 6px rgba(0,0,0,0.2)',
    userSelect: 'none',
  });

  container.appendChild(slider);
  container.appendChild(valueDisplay);
  document.body.appendChild(container);

  // Slider mozgatásakor frissül az érték, olvassebesseg és localStorage
  slider.addEventListener('input', () => {
    // Kerekítsük az értéket egy tizedesre
    olvassebesseg = Math.round(parseFloat(slider.value) * 10) / 10;

    // Slider értékét is frissítjük, hogy pontos legyen
    slider.value = olvassebesseg.toFixed(1);

    valueDisplay.textContent = olvassebesseg.toFixed(1);

    // Frissítés localStorage-ban
    localStorage.setItem('olvassebesseg', olvassebesseg.toFixed(1));

    console.log("Olvasási sebesség módosítva sliderrel: " + olvassebesseg.toFixed(1));

    // Itt frissítheted a beszédszintetizátort vagy olvasó funkciót, ha kell
  });

  // Ha van ilyen változó és függvény, frissítsd őket is
  if (typeof readany !== 'undefined') {
    readany = olvassebesseg;
  }
  if (typeof readanytexthun === 'function') {
    readanytexthun();
  }

  // 10 másodperc múlva eltávolítjuk a konténert
  sliderTimeoutId = setTimeout(() => {
    const el = document.getElementById('uniqueSliderContainer');
    if (el) el.remove();
    sliderTimeoutId = null;
  }, 10000);
}











// Lassabb funkció: csökkenti 0.1-gyel
function lassabb() {
  // Csökkentjük 0.1-gyel, kerekítjük egy tizedesre, minimum 0.1
  olvassebesseg = Math.round((olvassebesseg - 0.1) * 10) / 10;
  olvassebesseg = Math.max(olvassebesseg, 0.1);

  console.log("Olvasási sebesség lassabb: " + olvassebesseg.toFixed(1));

  // Frissítés localStorage-ban
  localStorage.setItem('olvassebesseg', olvassebesseg.toFixed(1));

  showVerticalSliderWithValue(olvassebesseg);
}



//////////

function inditKetto() {
    optionsApopupButtonFunction();
    showCommands();
}


//////////


// Globális commands objektum már adott 

function showCommands() {
	
	showBubble('Egéb parancsok: ÚJSÁG ', 'rgb(151,71,151)', [40, 300]);


  // Ha már létezik a lista, ne hozzunk létre újat
  if (document.getElementById('commandListContainer')) return;

  // Konténer létrehozása
  const container = document.createElement('div');
  container.id = 'commandListContainer';
  container.style.position = 'fixed';
  container.style.bottom = '0';
  container.style.left = '0';
  container.style.width = '100%';
  container.style.height = '650px';               // fix magasság
  container.style.overflowY = 'auto';
  container.style.backgroundColor = 'rgba(0, 123, 255, 0.5)'; // áttetsző kék RGB
  container.style.color = 'white';
  container.style.fontFamily = 'Arial, sans-serif';
  container.style.fontSize = '16px';
  container.style.padding = '10px 15px';
  container.style.boxSizing = 'border-box';
  container.style.zIndex = '10000';
  container.style.borderTop = '3px solid #0056b3';
  container.style.textAlign = 'center'; // középre igazítás

  // Lista létrehozása
  const ul = document.createElement('ul');
  ul.style.listStyle = 'none';
  ul.style.margin = '0 auto';  // középre igazítás
  ul.style.padding = '0';
  ul.style.width = '100%';     // teljes szélesség, hogy a textAlign működjön

  // Parancsok hozzáadása listához
  for (const cmd in commands) {
    const li = document.createElement('li');
    li.textContent = cmd;
    li.style.padding = '8px 12px';
    li.style.borderBottom = '1px solid rgba(255,255,255,0.3)';
    li.style.cursor = 'pointer';
    li.style.userSelect = 'none';
    li.style.textAlign = 'center'; // középre igazítás

    // Hover effekt (érintésen is jól látszik)
    li.addEventListener('mouseenter', () => {
      li.style.backgroundColor = 'rgba(255,255,255,0.2)';
    });
    li.addEventListener('mouseleave', () => {
      li.style.backgroundColor = 'transparent';
    });

    // Kattintás/érintés esemény
    li.addEventListener('click', () => {
      // Felolvasás megszakítása
      if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel();
      }

      const funcName = commands[cmd];
      if (typeof window[funcName] === 'function') {
        window[funcName]();
      } else {
        alert(`Funkció nem található: ${funcName}`);
      }
      // Lista eltávolítása a kiválasztás után
      container.remove();
    });

    ul.appendChild(li);
  }

  // Extra info alul
  const extra = document.createElement('div');
  extra.style.marginTop = '10px';
  extra.style.fontSize = '14px';
  extra.style.whiteSpace = 'pre-wrap';
  extra.style.textAlign = 'center';  // középre igazítás
  extra.textContent = "További parancsok:\nIdőjárás plusz település\nWeather plusz település\nNews plus akármi\nÚjság (ez random)";

  container.appendChild(ul);
  container.appendChild(extra);

  // Bezáró gomb a jobb felső sarokban
  const closeBtn = document.createElement('button');
  closeBtn.textContent = 'Bezárás ✖';
  closeBtn.style.position = 'absolute';
  closeBtn.style.top = '5px';
  closeBtn.style.right = '10px';
  closeBtn.style.background = 'transparent';
  closeBtn.style.border = 'none';
  closeBtn.style.color = 'white';
  closeBtn.style.fontSize = '18px';
  closeBtn.style.cursor = 'pointer';
  closeBtn.addEventListener('click', () => {
    // Felolvasás megszakítása bezáráskor is
    if ('speechSynthesis' in window) {
      window.speechSynthesis.cancel();
    }
    container.remove();
  });
  container.appendChild(closeBtn);

  document.body.appendChild(container);

  // Automatikus eltűnés 60 mp után
  setTimeout(() => {
    if (document.body.contains(container)) {
      // Felolvasás megszakítása eltűnéskor is
      if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel();
      }
      container.remove();
    }
  }, 60000);

  // Hangos felolvasás (opcionális)
  if ('speechSynthesis' in window) {
    let commandList = Object.keys(commands).join('\n') + "\n\nTovábbi parancsok:\nIdőjárás plusz település\nWeather plusz település\nNews plus akármi\nÚjság (ez random)";
    let utterance = new SpeechSynthesisUtterance(commandList);
    utterance.lang = 'hu-HU';
    utterance.rate = 0.4;
    window.speechSynthesis.speak(utterance);
  }
}






          // type best

//A program a text.length -et ossza el 40-nel, kerekítse egész számra, és
//ennyiszer játssza le az audio-t egymás után. ( amíg tart a kiírás folyamatosan szóljon a hang is).


var animationStarted = false;

function startTypingAnimation(paragraphId, divId, text) {
  if (!animationStarted) {
    animationStarted = true;

    var i = 0;
    var speed = 25; // The speed of the typing animation in milliseconds

    document.getElementById(divId).style.display = "block";
    document.getElementById(paragraphId).style.display = "block";

     	   if (firstdomloadforTyping === 0) {  // a weboldalhangtiltás miatt
    
// többszörihang 

var textLength = text.length; // A szöveg hossza
var divided = textLength / 100; // Osztás 100-nel
var rounded = Math.round(divided); // Kerekítés a legközelebbi egész számra
if (rounded < 1) {
  rounded = 1;
}

var playCount = rounded; // A lejátszások száma

function playAudio() {
  var audio = document.getElementById('background_audio');
  var count = 0;

  // A lejátszás funkciója
  function play() {
    if (count < playCount) {
      audio.play();
      count++;
      // Véletlenszerű késleltetés beállítása minden lejátszásnál
     // var delay = Math.floor(Math.random() * (1200 - 600 + 1)) + 600; // 600 - 1200
      
     var delay = Math.floor(Math.random() * (1800 - 1300 + 1)) + 1300;  //1300 és 1800 között

      setTimeout(play, audio.duration * 1000 + delay); // Várakozás az audio hosszára és a késleltetésre
    }
  }

  play(); // Első lejátszás indítása
}

playAudio(); // Az audio lejátszásának indítása



// többszörihang vége

            }
            
    function typeWriter() {
    	
   // alert("Karakterek száma: " + text.length);
    
      if (i < text.length) {
        document.getElementById(paragraphId).innerHTML += text.charAt(i);
        i++;
        setTimeout(typeWriter, speed);
      } else {
        setTimeout(function() {
          // Reverse typing animation
          function deleteText() {
            if (i >= 0) {
              var partialText = text.substring(0, i);
              document.getElementById(paragraphId).innerHTML = partialText;
              i--;
              setTimeout(deleteText, 8); // Növelt törlési sebesség 8 milliszekundumra
            }
          }
          deleteText();
          // Itt állítjuk vissza az animationStarted változót false-ra
          animationStarted = false;
        }, 4500); // Wait for 2 seconds before deleting
      }
    }

    typeWriter();
  }
}

/*
 Meghívhatja a függvényt a szöveggel, amit ki szeretne íratni
 
startTypingAnimation('paragraphId', 'divId', 'Hello World');

startTypingAnimation('paragraphId', 'divId', 'Hel666lo World');
*/


        // type best end
        






// a GYÖNYÖRŰ FADE OUT HUD

function fadeOut(element) {
  var op = 1;  // kezdeti opacity
  var timer = setInterval(function () {
    if (op <= 0.01){
      clearInterval(timer);
      element.style.display = 'none';
    }
    element.style.opacity = op;
    element.style.filter = 'alpha(opacity=' + op * 100 + ")";
    op -= op * 0.1;
  }, 250);
}

// A funkció meghívása a .hud elemen
var hudElement = document.querySelector('.hud');
//fadeOut(hudElement); eznemjóó
//de ez alatta igen!!!
/*
var hudElement = document.querySelector('.hud');
  if (hudElement) {
    fadeOut(hudElement);
  } else {
    console.error('A .hud elem nem található.');
  }
*/


function fadeIn(element) {
  var op = 0;  // kezdeti opacity
  element.style.display = 'block'; // Biztosítja, hogy az elem látható legyen
  var timer = setInterval(function () {
    if (op >= 1){
      clearInterval(timer);
    }
    element.style.opacity = op;
    element.style.filter = 'alpha(opacity=' + op * 100 + ")";
    op += op * 0.1 || 0.1; // Ha az op értéke 0, akkor adjunk hozzá 0.1-et
  }, 250);
}

// A funkció meghívása a .hud elemen
/*
var hudElement = document.querySelector('.hud');
if (hudElement) {
  fadeIn(hudElement);
} else {
  console.error('A .hud elem nem található.');
}
*/

// ez simán beállítja a hud opacity, nem fade, és ne azonnali betöltéskor, hanem gombbal.
function setOpacity(value) {
  var hudElement = document.querySelector('.hud');
  hudElement.style.opacity = value;
}

// Például, ha az átlátszóságot 0.5-re szeretnéd állítani:
//setOpacity(0.5);


 
 
    </script>
</body>
</html>







<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">

  <link rel="stylesheet" href="./style/styleosd1.css">

</head>
<body>
<!--   CodePen - 3D HUD in space - Pure CSS partial:index.partial.html -->


<div class="target top left"></div>
<div class="target top right"></div>
<div class="target bottom left"></div>
<div class="target bottom right"></div>

<div class="hud">
  <div class="orange">
    <div class="notches">
      <div class="notch notch1"></div>
      <div class="notch notch2"></div>
      <div class="notch notch3"></div>
      <div class="notch notch4"></div>
      <div class="notch notch5"></div>
      <div class="notch notch6"></div>
      <div class="notch notch7"></div>
      <div class="notch notch8"></div>
      <div class="notch notch9"></div>
      <div class="notch notch10"></div>
      <div class="notch notch11"></div>
      <div class="notch notch12"></div>
    </div>
    <div class="circle outer1"></div>
    <div class="circle outer2"></div>
    <div class="circle outer3"></div>
    <div class="circle inner1"></div>
    <div class="circle inner2"></div>
    <div class="topnotches">
      <div class="notch notch1"></div>
      <div class="notch notch2"></div>
      <div class="notch notch3"></div>
      <div class="notch notch4"></div>
      <div class="notch notch5"></div>
      <div class="notch notch6"></div>
      <div class="notch notch7"></div>
      <div class="notch notch8"></div>
      <div class="notch notch9"></div>
      <div class="notch notch10"></div>
      <div class="notch notch11"></div>
      <div class="notch notch12"></div>
    </div>
    <div class="bottomnotches">
      <div class="notch notch1"></div>
      <div class="notch notch2"></div>
      <div class="notch notch3"></div>
      <div class="notch notch4"></div>
      <div class="notch notch5"></div>
      <div class="notch notch6"></div>
      <div class="notch notch7"></div>
      <div class="notch notch8"></div>
      <div class="notch notch9"></div>
      <div class="notch notch10"></div>
      <div class="notch notch11"></div>
      <div class="notch notch12"></div>
    </div>
    <div class="circle inner3"></div>
    <div class="center">
      <div class="top left"></div>
      <div class="top right"></div>
      <div class="bottom left"></div>
      <div class="bottom right"></div>
    </div>
  </div>
  <div class="blue">
    <div class="circle inner1"></div>
    <div class="notches">
      <div class="notch notch1"></div>
      <div class="notch notch2"></div>
      <div class="notch notch3"></div>
      <div class="notch notch4"></div>
      <div class="notch notch5"></div>
      <div class="notch notch6"></div>
      <div class="notch notch7"></div>
      <div class="notch notch8"></div>
      <div class="notch notch9"></div>
      <div class="notch notch10"></div>
      <div class="notch notch11"></div>
      <div class="notch notch12"></div>
    </div>
    <div class="circle inner2"></div>
  </div>
  <div class="callout left">
    <div class="title">AH-64E</div>
    <div class="body">N606SP</div>
    <div class="body2">N606SP</div>
  </div>
  <div class="callout right">
    <div class="title">9999999999 m</div>
    <div class="body">275 km/h</div>
  </div>
</div>
<!-- partial -->
  <script  src="./script.js"></script>

</body>
</html>







<!--csak akkor legyen ez az egész animáció és kép, ha meghívok egy funkciót. Különben ne legyen semmi! -->

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Animáció</title>
  <style>
    #image {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      display: none; /* Kezdetben elrejtjük a képet */
    }

    @keyframes animation {
  0% {
    width: 250px;
    height: 250px;
    left: 0px;
    top: 0px;
  }
  5% {
    width: 55px;
    height: 55px;
    left: 500px;
    top: 1000px;
  }
  10% {
    width: 360px;
    height: 360px;
    left: 40px;
    top: 100px;
  }
  15% {
    width: 265px;
    height: 265px;
    left: 400px;
    top: 300px;
  }
  20% {
    width: 170px;
    height: 170px;
    left: 300px;
    top: 500px;
  }
  25% {
    width: 75px;
    height: 75px;
    left: 400px;
    top: 700px;
  }
  30% {
    width: 480px;
    height: 480px;
    left: 100px;
    top: 500px;
  }
  35% {
    width: 285px;
    height: 285px;
    left: 300px;
    top: 1000px;
  }
  40% {
    width: 90px;
    height: 90px;
    left: 70px;
    top: 600px;
  }
  45% {
    width: 95px;
    height: 95px;
    left: 300px;
    top: 800px;
  }
  50% {
    width: 300px;
    height: 300px;
    left: 200px;
    top: 600px;
  }
  55% {
    width: 95px;
    height: 95px;
    left: 300px;
    top: 400px;
  }
  60% {
    width: 290px;
    height: 290px;
    left: 300px;
    top: 200px;
  }
  65% {
    width: 85px;
    height: 85px;
    left: 100px;
    top: 0px;
  }
  70% {
    width: 380px;
    height: 380px;
    left: 200px;
    top: 0px;
  }
  75% {
    width: 175px;
    height: 175px;
    left: 300px;
    top: 0px;
  }
  80% {
    width: 70px;
    height: 70px;
    left: 100px;
    top: 0px;
  }
  85% {
    width: 265px;
    height: 265px;
    left: 100px;
    top: 300px;
  }
  90% {
    width: 60px;
    height: 60px;
    left: 330px;
    top: 330px;
  }
  95% {
    width: 355px;
    height: 355px;
    left: 30px;
    top: 100px;
  }
  100% {
    width: 250px;
    height: 250px;
    left: 0px;
    top: 0px;
  }
}

    #image {
      animation: animation 70s infinite;
    }
  </style>
</head>
<body>
  <img id="image" src="" alt="Random Image">
  
  <script>

    
    


    // Kód, ami csak akkor fut le, ha meghívod a funkciót
  //  showAnimation();
    
    
    function showAnimation() {
      // Kép listája
      var images = ['./picture/kjk/young-blackbeard-the-pirate-with-crew-close-up-view-on-queen-annes-revenge-dark-storm-clouds-as-ima-394931904.jpg', './picture/kjk/white-eagle-adorned-with-a-pirate-hat-perched-on-a-weathered-wooden-ships-mast-black-and-white-omb-99299695.jpg', './picture/kjk/sharkfolk-pirate-black-scales-dominant-eye-patch-wearing-long-black-leather-overcoat-adorned-with-666951601.jpg', './picture/kjk/sharkfolk-pirate-black-scales-dominant-eye-patch-wearing-long-black-leather-overcoat-adorned-with-611176713.jpg', './picture/kjk/profile-picture-for-github-profile-with-the-name-of-piratetechy-with-the-look-of-pirate-and-with-t-878074407.jpg', './picture/kjk/pirate-draped-in-ragged-earth-toned-attire-disembarks-from-a-weather-beaten-boat-onto-a-sun-kissed--161309561.jpg', './picture/kjk/pirate-captain-billy-bones-stands-imposingly-on-the-deck-of-his-weathered-ship-his-silhouette-defin-851230391.jpg', './picture/kjk/logo-for-a-casual-computer-game-about-pirates-61775959.jpg', './picture/kjk/logo-featuring-thepiratenerd-text-nestled-between-a-nerdy-pirate-character-donning-a-lab-coat-tr-276076616.jpg', './picture/kjk/logo-design-featuring-a-tricorne-hat-crossed-cutlasses-and-a-classic-jolly-roger-flag-insignia-inc-218161866.jpg', './picture/kjk/hurricane-at-night-girl-pirate-on-the-deck-of-a-pirate-ship-anime-style-soft-lighting-foreboding--121194120.jpg', './picture/kjk/generate-an-image-of-a-manta-ray-pirate-sailing-the-digital-seas-the-manta-ray-should-be-depicted--316420994.jpg', './picture/kjk/big-boat-pirate-navigating-a-river-in-the-loose-oil-painting-style-of-david-schmid-using-tridimen-65764517.jpg'];

      // Random kép kiválasztása
      var randomIndex = Math.floor(Math.random() * images.length);
      var randomImage = images[randomIndex];

      // Kép forrásának beállítása
      document.getElementById('image').src = randomImage;

      // Kép megjelenítése
      document.getElementById('image').style.display = 'block';
    }
  







// sounds random

// Sound files
var sounds = ['snd/kjk/background/Medieval tavern ambience - easy going - plates and glasses clanking, light voices, light music, and some happy voices.mp3', 'snd/kjk/background/Warfare and battlefields - medieval battlefield - weapons and horses - close perspective.mp3', 'snd/kjk/background/Seagulls - in a beach port - with activity and distant voices - Africa.mp3', 'snd/kjk/background/Seagulls and various birds - ambience on Lake Superior - some surf - loud birds.mp3', 'snd/kjk/background/Birds - various seagull flying by with intense screams in background.mp3', 'snd/kjk/background/Beach ambience - morning sunrise - seagull birds and ocean waves - Turks and Caicos - Zoom H6.mp3', 'snd/kjk/background/Pirate tavern ambience 2.mp3', 'snd/kjk/background/Crowd - clapping and talking together - inside a bar - Valparaiso, Chile.mp3', 'snd/kjk/background/Y2meta.app - Alan Silvestri - Romancing the Stone Theme [Extended by Gilles Nuytens] (192 kbps).mp3', 'snd/kjk/background/Y2meta.app - Pirates of the Caribbean PC Game Music 28 (128 kbps).mp3', 'snd/kjk/background/Y2meta.app - Pirates of the Caribbean PC Game Music 25 (128 kbps).mp3', 'snd/kjk/background/Y2meta.app - Pirates of the Caribbean PC Game Music 19 (128 kbps).mp3', 'snd/kjk/background/Y2meta.app - Pirates of the Caribbean PC Game Music 15 (128 kbps).mp3', 'snd/kjk/background/Y2meta.app - Pirates of the Caribbean PC Game Music 14 (128 kbps).mp3', 'snd/kjk/background/Y2meta.app - Pirates of the Caribbean PC Game Music 10 (128 kbps).mp3', 'snd/kjk/background/Y2meta.app - Pirates of the Caribbean PC Game Music 8 (128 kbps).mp3', 'snd/kjk/background/Y2meta.app - Pirates of the Caribbean PC Game Music 7 (128 kbps).mp3', 'snd/kjk/background/Y2meta.app - Pirates of the Caribbean PC Game Music 6 (128 kbps).mp3', 'snd/kjk/background/uuu.mp3', 'snd/kjk/background/uuu.mp3', 'snd/kjk/background/uuu.mp3', 'snd/kjk/background/uuu.mp3', 'snd/kjk/background/Seagulls and various birds - ambience on Lake Superior - some surf - loud birds.mp3'];

// Ambiance function

//Változtass.
//Csak akkor töltsön be új hangot, ha végetért az előző.

var ambiance;
var isPlaying = false;

function playAmbiance() {
 // startTypingAnimation('paragraphId', 'divId', 'playAmbiance');
  
  fadeInOutText('playAmbiance', 40, 'rgba(120, 110, 200, 1)', 15);
  
  if (!isPlaying) {
    isPlaying = true;
    ambiance = new Audio('path_to_your_sound_file.mp3'); // inicializáljuk az ambiance változót
    var randomSound = sounds[Math.floor(Math.random() * sounds.length)];
    var randomVolume = Math.random() * (0.1 - 0.05) + 0.05;
    ambiance.src = randomSound;
    ambiance.volume = randomVolume;
    ambiance.play();
    ambiance.onended = function() {
      isPlaying = false;
      var randomPause = Math.floor(Math.random() * (6000 - 5000)) + 5000; // generáljuk a szünet időtartamát
      setTimeout(function() {
        playAmbiance();
      }, randomPause);
    };
  }
}

function stopAmbiance() {
  stopMusic();
  stopPlayany();
  ambiance.pause();
  ambiance.onended = function() {
    startTypingAnimation('paragraphId', 'divId', 'stopAmbiance');
  };
  isPlaying = false;
  startTypingAnimation('paragraphId', 'divId', 'stopAmbiance');
}

// Start the ambiance
//playAmbiance();





// random könyv újraindítás nélkül


async function randomBooknew() {
	
	stopSpeaking(); 
	
	let existingEntries = localStorage.getItem('favoritstorage');
  if (existingEntries) {
    let txtEntries = existingEntries.split('\n').filter(line => line.endsWith('.txt'));
    
    //A randomEntry lesz ugye a kiválasztott sor. Ennek a sornak a száma kellene és kiírni egy alert-ba.
    if (txtEntries.length > 0) {
    let randomEntry = txtEntries[Math.floor(Math.random() * txtEntries.length)];
    await readTextFile(randomEntry);
    // Az alert hívás itt történik, miután a fájl beolvasása sikeres volt
    //alert(`Random entry: ${txtEntries.indexOf(randomEntry) + 1}`);
    
    randombooknumber = (`${txtEntries.indexOf(randomEntry) + 1}`);
    
    fadeInOutText(randombooknumber, 64, 'rgba(70, 40, 231, 1)', 47);
    bookfavoritindex = randombooknumber;
    
      // Az alert hívás itt történik, miután a fájl beolvasása sikeres volt
      //alert(origcontent);


// A localStorage-ban tároljuk a randomEntry értékét a 'readpathstorage' kulcs alatt ha kitörölnénk manuálisan
      localStorage.setItem('readpathstorage', randomEntry);



  bookname = randomEntry.substring(randomEntry.lastIndexOf("/") + 1);

  
// A bookname faszságai
// Nemkívánatos speciális karakterek
const undesiredSpecialChars = ['+', '-', '_', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];

// Tisztítás
let filteredContent = bookname.split('').map(char => undesiredSpecialChars.includes(char) ? ' ' : char).join('');

// Visszahelyezés a kiszedett karakterek helyére egy space-szel
bookname = filteredContent;
        
//alert(bookname);



      legorigabbcontent = origcontent;
            
                analysis();   // már itt lefut
            
                replaceSt();
                removeQuotes();  // idézőjel
                replaceMr();
                linebreakreplacement(); //savefilenak formázás
                
                let result = AIrecognizelanguage(origcontent);
                supervision();
                //console.log(result);
                
                
                // funkción belüli funkció következik
                
                
                
           //     bookname = (randomEntry + " clipboard");
      
      
      
  //    
      
      
           // minden nyitó és záró zárójel kiszedése a bookmark localstorage miatt, ez nem csere 
            bookname = bookname.replace(/[()]/g, '');
            
            
            console.log('File loaded successfully.');

            if (bookname) {
            	fadebookname(); // fadetext
                console.log('Book name:', bookname); // Ha létezik a bookname, kiírjuk a konzolba
            }
            countSentences();
            
      // idáig a core betöltése, és flawless!!! yeah
      
      
      titletranslate();
         //  bookpercent();
        //   four();
    
           //alert(randombooknumber);
console.log('BookIndex: ' + randombooknumber);
var textToRead3 = (randombooknumber + ' ');
var audio3 = new SpeechSynthesisUtterance(textToRead3);
    speechSynthesis.speak(audio3);

    setTimeout(percentread, 3000);
 
 
 
 


// Példa winner változó (állítsd be a saját logikád szerint)
//let winner = "en";

setTimeout(function() {
    if (magyart === 0) {
        // kép megjelenítése magyart=0 esetén

/*
        displayImage(
            ['1753351676082.jpg'],
            'shrink',
            50,
            30,
            50,
            50,
            2,
            '',
            24,
            'rgba(255, 0, 0, 1)'
        );
*/        
        
    } else if (magyart === 1) {
        if (winner === "en") {
            // csak magyart, kép megjelenítése ha magyart=1 és winner="en"
            displayImage(
                ['1753348460347.jpg'],
                'shrink',
                50,
                30,
                50,
                50,
                4,
                '',
                24,
                'rgba(255, 0, 0, 1)'
            );
            randomBooknew();
        } else {
            // ha magyart=1 és a winner nincs "en", ide jöhet másik logika vagy üzenet
            console.log("A nyertes nem 'en', más ág fut");
            // példa: createSimplePanel vagy más művelet ide
        }
    } else {
        // ha magyart más érték, vagy nem definiált
        console.log("Érvénytelen magyart érték:", magyart);
        // itt kezelheted az egyéb eseteket (hibakezelés, alapértelmezett művelet)
    }
}, 3000);


}
 
  }
  
}







// Globális változó a keresett mondat tárolására
let keresettMondat = null;

// Példa origcontent szöveg (ezt cseréld a saját szövegedre)
//let origcontent = `Ez az első mondat. Ez a második mondat, amely tartalmazza a keresett szót. Harmadik mondat itt.`;



// Fő funkció: hangalapú szókeresés az origcontentben
async function hangalapuszokereses() {
    if (!origcontent || typeof origcontent !== 'string') {
        alert('Az origcontent változó nincs definiálva vagy nem szöveg.');
        return;
    }

    if (!('SpeechRecognition' in window) && !('webkitSpeechRecognition' in window)) {
        alert('A böngésző nem támogatja a hangfelismerést.');
        return;
    }

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognition = new SpeechRecognition();
    recognition.lang = 'hu-HU';
    recognition.interimResults = false;
    recognition.maxAlternatives = 1;

    recognition.onresult = async (event) => {
        let searchText = event.results[0][0].transcript.toLowerCase().trim();
        if (!searchText) {
            await felolvasoSoronkent('Nem hallottam kereső szót, kérlek próbáld újra.');
            return;
        }

        // Pontosabb mondatfelbontás: mondatvégi írásjelek figyelembe vétele
        let mondatok = origcontent.match(/[^.!?]+(?:[.!?])(?=\s|$)/g) || [origcontent];

        // Keresés szóhatárokkal, kis/nagybetűtől függetlenül
        let talalatok = [];
        const regex = new RegExp(`\\b${escapeRegExp(searchText)}\\b`, 'i');

        mondatok.forEach((mondat, index) => {
            if (regex.test(mondat)) {
                talalatok.push({ mondatSzam: index + 1, szoveg: mondat.trim() });
            }
        });

        if (talalatok.length === 0) {
        	
        showBubble('Találatok száma: 0', 'rgb(201,91,51)', [40, 300]);
        
            let uzenet = 'Nem találtam találatot a keresett kifejezésre.';
            megjelenitBubble(uzenet);
            await felolvasoSoronkent(uzenet);
            keresettMondat = null;
        } else {
            let talalatSzoveg = talalatok.map(talalat => {
                return `Találat a ${talalat.mondatSzam}. mondatban: ${talalat.szoveg}`;
            }).join('\n');

showBubble(`Találatok száma: ${talalatok.length}`, 'rgb(101,221,51)', [40, 300]);

            megjelenitBubble(talalatSzoveg);
            await felolvasoSoronkent(talalatSzoveg);



            if (talalatok.length === 1) {
                keresettMondat = talalatok[0].szoveg;
            } else {
                keresettMondat = null;
            }
        }
    };

    recognition.onerror = (event) => {
        console.error('Hiba a hangfelismerésben:', event.error);
        megjelenitBubble('Hiba történt a hangfelismerés során.');
        felolvasoSoronkent('Hiba történt a hangfelismerés során, kérlek próbáld újra.');
    };

    // Felolvasás után indul a hangfelismerés
    await felolvasoSoronkent('Kérlek, mondd be a kereső szót.');
    showBubble("Kérlek, mondd be a kereső szót.", "rgb(201,91,51)");
    recognition.start();

    // --- Segédfüggvények ---

    // Szóközöket és speciális karaktereket escape-el a reguláris kifejezéshez
    function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    async function felolvasoSoronkent(szoveg, maxHossz = 200) {
        let reszek = [];
        let mondatok = szoveg.match(/[^\.!\?]+[\.!\?]+/g);
        if (mondatok) {
            let aktualis = '';
            mondatok.forEach(mondat => {
                if ((aktualis + mondat).length > maxHossz) {
                    if (aktualis) reszek.push(aktualis.trim());
                    aktualis = mondat;
                } else {
                    aktualis += mondat;
                }
            });
            if (aktualis) reszek.push(aktualis.trim());
        } else {
            for (let i = 0; i < szoveg.length; i += maxHossz) {
                reszek.push(szoveg.substring(i, i + maxHossz));
            }
        }

        for (const resz of reszek) {
            await beszelesAsync(resz);
        }
    }

    function beszelesAsync(szoveg) {
        return new Promise((resolve) => {
            let utterance = new SpeechSynthesisUtterance(szoveg);
            utterance.lang = 'hu-HU';
        utterance.volume = 0.6;  // Max hangerő
        utterance.rate = 1.4;    // Beszéd sebessége (szükség szerint növelhető/csökkenthető)
        utterance.pitch = 1;   // Hangmagasság (szükség szerint módosítható)
            utterance.onend = () => resolve();
            speechSynthesis.speak(utterance);
        });
    }




    function megjelenitBubble(szoveg) {
        let existingBubble = document.getElementById('talalat-bubble');
        if (existingBubble) {
            existingBubble.remove();
            console.log('Régi buborék eltávolítva');
        }

        let bubble = document.createElement('div');
        bubble.id = 'talalat-bubble';
        bubble.style.position = 'fixed';
        bubble.style.bottom = '220px';
        bubble.style.right = '20px';
        bubble.style.maxWidth = '300px';
        bubble.style.maxHeight = '800px';  // Maximális magasság
bubble.style.overflowY = 'auto';   // Függőleges görgetés, ha szükséges

        bubble.style.padding = '15px 20px';
        bubble.style.backgroundColor = randomRGBA(0.5);
        bubble.style.color = 'white';
        bubble.style.fontFamily = 'Arial, sans-serif';
        bubble.style.fontSize = '14px';
        bubble.style.borderRadius = '12px';
        bubble.style.boxShadow = '0 4px 10px rgba(0,0,0,0.3)';
        bubble.style.zIndex = 10100;
        bubble.style.whiteSpace = 'pre-wrap';
        bubble.style.cursor = 'pointer';
        bubble.textContent = szoveg;

        // Klikkre eltűnik
        bubble.addEventListener('click', () => {
            bubble.remove();
            console.log('Buborék kattintásra eltávolítva');
        });

        document.body.appendChild(bubble);
        console.log('Buborék megjelenítve');

        // 30 másodperc után automatikusan eltűnik
        setTimeout(() => {
            if (bubble.parentNode) {
                bubble.remove();
                console.log('Buborék időzítővel eltávolítva');
            }
        }, 30000);
    }

    function randomRGBA(opacity = 0.5) {
        const r = Math.floor(Math.random() * 256);
        const g = Math.floor(Math.random() * 256);
        const b = Math.floor(Math.random() * 256);
        return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    }
}










//könyvkeresés favoritban

let keresettKonyv = null;

function hangalapuKereses() {
    let favoritContent = localStorage.getItem('favoritstorage');
    let favoritLines = favoritContent ? favoritContent.split('\n') : [];

    if (!('SpeechRecognition' in window) && !('webkitSpeechRecognition' in window)) {
        alert('A böngésző nem támogatja a hangfelismerést.');
        return;
    }

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognition = new SpeechRecognition();
    recognition.lang = 'hu-HU';
    recognition.interimResults = false;
    recognition.maxAlternatives = 1;

    recognition.onresult = (event) => {
        let searchText = event.results[0][0].transcript.toLowerCase().trim();
        if (!searchText) {
            beszeles('Nem hallottam kereső szót, kérlek próbáld újra.');
            return;
        }
        let talalatok = [];
        favoritLines.forEach((line, index) => {
            if (line.toLowerCase().includes(searchText)) {
                talalatok.push({ sor: index + 1, utvonal: line });
            }
        });

        if (talalatok.length === 0) {
            let uzenet = 'Nem találtam találatot a keresett kifejezésre.';
            beszeles(uzenet);
            keresettKonyv = null;
            megjelenitBubble(uzenet);
        } else {
            let talalatSzoveg = talalatok.map(talalat => {
                let fajlNev = talalat.utvonal.split('/').pop();
                return `Találat a ${talalat.sor}. sorban: ${fajlNev}`;
            }).join('\n');

            beszeles(talalatSzoveg);
            megjelenitBubble(talalatSzoveg);

            if (talalatok.length === 1) {
                keresettKonyv = talalatok[0].utvonal;
            } else {
                keresettKonyv = null;
            }
        }
    };

    recognition.onerror = (event) => {
        console.error('Hiba a hangfelismerésben:', event.error);
        beszeles('Hiba történt a hangfelismerés során, kérlek próbáld újra.');
        megjelenitBubble('Hiba történt a hangfelismerés során.');
    };

    // Itt várjuk meg, hogy a felolvasás teljesen befejeződjön, majd indul a felismerés
    beszeles('Kérlek, mondd be a kereső szót.', () => {
    	showBubble("Kérlek, mondd be a kereső szót.", "rgb(201,91,51)");
        recognition.start();
    });

    function beszeles(szoveg, callback) {
        let utterance = new SpeechSynthesisUtterance(szoveg);
        utterance.lang = 'hu-HU';
        utterance.onend = () => {
            if (callback) callback();
        };
        speechSynthesis.speak(utterance);
    }

    function megjelenitBubble(szoveg) {
        let existingBubble = document.getElementById('talalat-bubble');
        if (existingBubble) existingBubble.remove();

        let bubble = document.createElement('div');
        bubble.id = 'talalat-bubble';
        bubble.style.position = 'fixed';
        bubble.style.bottom = '220px';
        bubble.style.right = '20px';
        bubble.style.maxWidth = '300px';
        bubble.style.padding = '15px 20px';
        bubble.style.backgroundColor = randomRGBA(0.5);
        bubble.style.color = 'white';
        bubble.style.fontFamily = 'Arial, sans-serif';
        bubble.style.fontSize = '14px';
        bubble.style.borderRadius = '12px';
        bubble.style.boxShadow = '0 4px 10px rgba(0,0,0,0.3)';
        bubble.style.zIndex = 10100;
        bubble.style.whiteSpace = 'pre-wrap';
        bubble.style.cursor = 'pointer';
        bubble.textContent = szoveg;

        bubble.addEventListener('click', () => bubble.remove());

        document.body.appendChild(bubble);

        setTimeout(() => bubble.remove(), 40000);
    }

    function randomRGBA(opacity = 0.5) {
        const r = Math.floor(Math.random() * 256);
        const g = Math.floor(Math.random() * 256);
        const b = Math.floor(Math.random() * 256);
        return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    }
}








// Toggle függvény, ami menti az állapotot
function toggleMagyart() {
    // Feltételezem, hogy magyart változó globálisan vagy előzőleg definiálva van
    magyart = magyart === 1 ? 0 : 1;
    localStorage.setItem('magyart', magyart);
    
    // Ha szeretnéd kiírni az értéket, használhatsz alert-et vagy konzol logot
    // alert("magyart értéke most: " + magyart);
     console.log("magyart értéke most: " + magyart);

    if (magyart === 1) {
        playany(['snd/magyar a 4 speechgen.mp3', 'snd/magyart3.mp3', 'snd/magyart2.mp3', 'snd/magyar könyvek1.mp3'], 1);
    } else if (magyart === 0) {
     playany(['snd/internationalGenny Untitled1.wav', 'snd/interGenny Untitled2.wav', 'snd/interryanGenny Untitled3.wav', 'snd/inter Genny Untitled 3.wav', 'snd/inter ryan Genny Untitled 5.wav'], 1);
    }
}


 // Betöltjük a magyart értékét localStorage-ból vagy alapból 1
let magyart = localStorage.getItem('magyart');
magyart = magyart !== null ? parseInt(magyart, 10) : 1;
//toggleMagyart();

async function randomBooknewAndrandomsentence() {
	
	let existingEntries = localStorage.getItem('favoritstorage');
  if (existingEntries) {
    let txtEntries = existingEntries.split('\n').filter(line => line.endsWith('.txt'));
    
    //A randomEntry lesz ugye a kiválasztott sor. Ennek a sornak a száma kellene és kiírni egy alert-ba.
    if (txtEntries.length > 0) {
    let randomEntry = txtEntries[Math.floor(Math.random() * txtEntries.length)];
    await readTextFile(randomEntry);
    // Az alert hívás itt történik, miután a fájl beolvasása sikeres volt
    //alert(`Random entry: ${txtEntries.indexOf(randomEntry) + 1}`);
    
    randombooknumber = (`${txtEntries.indexOf(randomEntry) + 1}`);
    
    fadeInOutText(randombooknumber, 64, 'rgba(70, 40, 231, 1)', 47);
    bookfavoritindex = randombooknumber;
    
      // Az alert hívás itt történik, miután a fájl beolvasása sikeres volt
      //alert(origcontent);


// A localStorage-ban tároljuk a randomEntry értékét a 'readpathstorage' kulcs alatt ha kitörölnénk manuálisan
      localStorage.setItem('readpathstorage', randomEntry);



  bookname = randomEntry.substring(randomEntry.lastIndexOf("/") + 1);

  
// A bookname faszságai
// Nemkívánatos speciális karakterek
const undesiredSpecialChars = ['+', '-', '_', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];

// Tisztítás
let filteredContent = bookname.split('').map(char => undesiredSpecialChars.includes(char) ? ' ' : char).join('');

// Visszahelyezés a kiszedett karakterek helyére egy space-szel
bookname = filteredContent;
        
//alert(bookname);



      legorigabbcontent = origcontent;
            
                analysis();   // már itt lefut
            
                replaceSt();
                removeQuotes();  // idézőjel
                replaceMr();
                linebreakreplacement(); //savefilenak formázás
                
                let result = AIrecognizelanguage(origcontent);
                supervision();
                //console.log(result);
                
                
                // funkción belüli funkció következik
                
                
                
           //     bookname = (randomEntry + " clipboard");
      
      
      
  //    
      
      
           // minden nyitó és záró zárójel kiszedése a bookmark localstorage miatt, ez nem csere 
            bookname = bookname.replace(/[()]/g, '');
            
            
            console.log('File loaded successfully.');

            if (bookname) {
            	fadebookname(); // fadetext
                console.log('Book name:', bookname); // Ha létezik a bookname, kiírjuk a konzolba
            }
            countSentences();
            
      // idáig a core betöltése, és flawless!!! yeah
      
      
      titletranslate();
         //  bookpercent();
        //   four();
    
           //alert(randombooknumber);
console.log('BookIndex: ' + randombooknumber);
var textToRead3 = (randombooknumber + ' ');
var audio3 = new SpeechSynthesisUtterance(textToRead3);
    speechSynthesis.speak(audio3);

    setTimeout(percentread, 3000);
 
    playany(['snd/You searched for notify Page 2 of 14 ZapSplat - Download free sound effects_1744032397551.mp3', 'snd/You searched for notify Page 2 of 14 ZapSplat - Download free sound effects_1744032448138.mp3'], 1);
	
      setTimeout(randomSentence, 3000);
      
    }
  }
  
}


/////google old


async function searchAndRead(query) {
  try {
    const url = `https://www.googleapis.com/customsearch/v1?key=${apiKey}&cx=${cx}&q=${encodeURIComponent(query)}&gl=hu&lr=lang_hu`;
    const response = await fetch(url);
    const data = await response.json();

    if (!data.items || data.items.length === 0) {
      speak('Nincs találat.');
      alert('Nincs találat.');
      return;
    }

    // Új ablak nyitása, méret és görgetősáv engedélyezése
    const popup = window.open('', 'searchResults', 'width=600,height=400,scrollbars=yes,resizable=yes');
    popup.document.title = 'Keresési eredmények';
    popup.document.body.style.fontFamily = 'Arial, sans-serif';
    popup.document.body.style.margin = '10px';

    let html = '<h2>Keresési eredmények</h2>';
    let summary = '';

    data.items.forEach(item => {
      html += `<div style="margin-bottom:15px;">
        <a href="${item.link}" target="_blank" style="font-weight:bold; font-size:1.1em; color:blue; text-decoration:none;">${item.title}</a>
        <p>${item.snippet}</p>
      </div>`;
      summary += item.title + '. ' + item.snippet + ' ';
    });

    popup.document.body.innerHTML = html;

    speak(summary);
  } catch (e) {
    speak('Hiba történt a keresés során.');
    alert('Hiba történt a keresés során.');
  }
}



/////
// random x db szó


let globalRandomWords = [];
let speechRecognizerInstance = null; // A hangfelismerő példánya

async function RandomWordsFromRandomBooks(numberOfWords) {
	stopMonitoring();
  let existingEntries = localStorage.getItem('favoritstorage');
  if (existingEntries) {
    let txtEntries = existingEntries.split('\n').filter(line => line.endsWith('.txt'));
    globalRandomWords = [];

    if (txtEntries.length > 0) {
      for (let i = 0; i < numberOfWords; i++) {
        let randomIndex = Math.floor(Math.random() * txtEntries.length);
        let randomEntry = txtEntries[randomIndex];
        try {
          await readTextFile(randomEntry);
          if (origcontent) {
            let words = origcontent.split(' ').filter(
              (word) =>
                !['the', 'and', 'of', 'a', 'in', 'to', 'you', 'are', 'that', 'is'].includes(word.toLowerCase())
            );
            if (words.length > 0) {
              let rndIndex = Math.floor(Math.random() * words.length);
              let rndWord = words[rndIndex].replace(/[.,!?]/g, '');
              globalRandomWords.push(rndWord);
            } else {
              console.warn(`No suitable words found in book: ${randomEntry}`);
            }
          } else {
            console.warn(`Could not read file: ${randomEntry}`);
          }
        } catch (error) {
          console.error(`Error reading file ${randomEntry}:`, error);
        }
      }

      const prefix = "rajzot"; // Alapértelmezett prefix
      const textarea = document.getElementById('felismerInput');
      if (textarea) {
        textarea.style.display = 'block'; // Textarea láthatóvá tétele
        textarea.value = `"${globalRandomWords.join(' ')}"\n${prefix}`;

        // Hangfelismerő indítása (ha még nem fut)
        if (window.myUniqueSpeechRecognizer && !window.myUniqueSpeechRecognizer.isRecognizing) {
          window.myUniqueSpeechRecognizer.start();
        } else if (!window.myUniqueSpeechRecognizer) {
          console.warn('A hangfelismerő objektum nem található.');
        }
      } else {
        console.warn('A "felismerInput" textarea elem nem található.');
        const clipboardText = `${prefix}\n"${globalRandomWords.join(' ')}"`;
        copyToClipboard(clipboardText); // Ha nincs textarea, másolás a vágólapra
      }

    } else {
      console.warn('No .txt files found in localStorage.');
      const prefix = "rajz";
      const clipboardText = `${prefix}\n""`;
      copyToClipboard(clipboardText);
    }
  } else {
    console.warn('No entries found in localStorage.');
    const prefix = "rajz";
    const clipboardText = `${prefix}\n""`;
    copyToClipboard(clipboardText);
  }
}

function copyToClipboard(text) {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(text)
      .then(() => {
        console.log('Text copied to clipboard successfully!');
        alert(`Result copied to clipboard:\n${text}`);
      })
      .catch(err => {
        console.error('Failed to copy text to clipboard: ', err);
        alert('Failed to copy text to clipboard. Please try again.');
      });
  } else {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    document.body.appendChild(textArea);
    textArea.select();
    try {
      document.execCommand('copy');
      console.log('Text copied to clipboard using fallback!');
      alert(`Result copied to clipboard:\n${text}`);
    } catch (err) {
      console.error('Failed to copy text to clipboard (fallback): ', err);
      alert('Failed to copy text to clipboard. Please try again.');
    } finally {
      document.body.removeChild(textArea);
    }
  }
}

// Egyszerűsített meghívás:
async function getRandomWordsAndStartSpeech(numberOfWords) {
  await RandomWordsFromRandomBooks(numberOfWords);
}

// Használat:
// A következő sor meghívja a függvényt, 3 véletlenszerű szót tesz a textarea-ba és elindítja a hangfelismerőt.
//getRandomWordsAndStartSpeech(3);
  
  



// Használat:
// A következő sor meghívja a függvényt, és 3 véletlenszerű szót kérdez le prefixszel, majd másolja a vágólapra.
//getRandomWordsWithCustomPrefix(3);

function randomszavak() {

getRandomWordsAndStartSpeech(8)
}


/*


*/





////////////  Options popup megjelenítése
function openOptionsPopup() {
    // Ha már van ilyen elem, töröljük
    let existing = document.getElementById("optionsPopup");
    if (existing) existing.remove();

    // Létrehozzuk a popupot
    const popup = document.createElement("div");
    popup.id = "optionsPopup";
    Object.assign(popup.style, {
        position: "fixed",
        top: "100px",
        right: "40px",
        background: "#333",
        color: "#fff",
        padding: "20px",
        borderRadius: "10px",
        boxShadow: "0 2px 10px rgba(0,0,0,0.4)",
        zIndex: 11000,
        maxWidth: "300px",
        fontSize: "16px",
    });

    // Checkbox elem
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.id = "muteCheckbox";

    // Betöltjük az állapotot localStorage-ból
     muteSounds = JSON.parse(localStorage.getItem("muteSounds")) || false;
    checkbox.checked = muteSounds;

    // Label a checkboxhoz
    const label = document.createElement("label");
    label.htmlFor = "muteCheckbox";
    label.style.marginLeft = "10px";
    label.innerText = "Zene némítása";


    // Checkbox változás eseménykezelője
    checkbox.addEventListener("change", function() {
        const isChecked = checkbox.checked;
        localStorage.setItem("muteSounds", JSON.stringify(isChecked));
        if(isChecked) {
            // Ha bepipálva, végrehajtjuk a némító funkciókat
            stopMusic();
            stopPlayany();
            muteRadio();
        }
        else {
            // Ha nincs bepipálva, itt lehet visszaállítani a hangokat, ha kell
            // (Pl. playMusic() vagy más)
        }
    });

    // Bezáró gomb az ablakhoz
    const closeButton = document.createElement("button");
    closeButton.innerText = "Bezárás";
    closeButton.style.marginTop = "15px";
    closeButton.style.padding = "8px 15px";
    closeButton.style.cursor = "pointer";

    closeButton.addEventListener("click", () => {
        popup.remove();
    });

    // Elemenként hozzáadjuk a popuphoz
    popup.appendChild(checkbox);
    popup.appendChild(label);
    popup.appendChild(document.createElement("br"));
    popup.appendChild(closeButton);

    document.body.appendChild(popup);
}

////////////////////
/// random SZÓ music suno-nak///
/////////


//var rndWord = '';

async function randomWordFunction() {
	
	
	let existingEntries = localStorage.getItem('favoritstorage');
  if (existingEntries) {
    let txtEntries = existingEntries.split('\n').filter(line => line.endsWith('.txt'));
    
    //A randomEntry lesz ugye a kiválasztott sor. Ennek a sornak a száma kellene és kiírni egy alert-ba.
    if (txtEntries.length > 0) {
    let randomEntry = txtEntries[Math.floor(Math.random() * txtEntries.length)];
    await readTextFile(randomEntry);
    // Az alert hívás itt történik, miután a fájl beolvasása sikeres volt
    //alert(`Random entry: ${txtEntries.indexOf(randomEntry) + 1}`);
    
    randombooknumber = (`${txtEntries.indexOf(randomEntry) + 1}`);
    
    
    
    
      // Az alert hívás itt történik, miután a fájl beolvasása sikeres volt
      //alert(origcontent);


// A localStorage-ban tároljuk a randomEntry értékét a 'readpathstorage' kulcs alatt ha kitörölnénk manuálisan
      localStorage.setItem('readpathstorage', randomEntry);



  bookname = randomEntry.substring(randomEntry.lastIndexOf("/") + 1);

  
// A bookname faszságai
// Nemkívánatos speciális karakterek
const undesiredSpecialChars = ['+', '-', '_', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];

// Tisztítás
let filteredContent = bookname.split('').map(char => undesiredSpecialChars.includes(char) ? ' ' : char).join('');

// Visszahelyezés a kiszedett karakterek helyére egy space-szel
bookname = filteredContent;
        
//alert(bookname);



      legorigabbcontent = origcontent;
            
                analysis();   // már itt lefut
            
                replaceSt();
                removeQuotes();  // idézőjel
                replaceMr();
                linebreakreplacement(); //savefilenak formázás
                
                let result = AIrecognizelanguage(origcontent);
                supervision();
                //console.log(result);
                
                
                // funkción belüli funkció következik
                
                
                
           //     bookname = (randomEntry + " clipboard");
      
      
      
  //    
      
      
           // minden nyitó és záró zárójel kiszedése a bookmark localstorage miatt, ez nem csere 
            bookname = bookname.replace(/[()]/g, '');
            
            
            console.log('File loaded successfully.');

            if (bookname) {
            	fadebookname(); // fadetext
                console.log('Book name:', bookname); // Ha létezik a bookname, kiírjuk a konzolba
            }
            countSentences();
            
      // idáig a core betöltése, és flawless!!! yeah
      
      
      
      
      //alert(origcontent);
      
      // Ha az rndWord változóban volna pont, vessző, felkiáltójel, kérdőjel, akkor ezektől tisztítsuk meg.
      
      
   // Assuming 'origcontent' is the original content
  let words = origcontent.split(' ');

  // Filter out the specified words
  
  // IDE A KIVÉTELEKET!
  words = words.filter(
    (word) =>
      word !== 'the' &&
      word !== 'and' &&
      word !== 'of' &&
      word !== 'a' &&
      word !== 'in' &&
      word !== 'to' &&
      word !== 'you' &&
      word !== 'are' &&
      word !== 'that' &&
      word !== 'is'
  );

  let rndIndex = Math.floor(Math.random() * words.length);
  rndWord = words[rndIndex];

  // Remove any punctuation from the random word
  //rndWord = rndWord.replace(/[.,!?]/g, '');

rndWord = words[rndIndex].replace(/[.,!?]/g, '');

  console.log(rndWord);

if (newsflag === 1) {
            fadeInOutTextBlink(rndWord, 64, 'rgba(220, 10, 20, 1)', 70, 15); // 5-ször villog 
            newsflag = 0;
            
            readany = (rndWord);
    readanytexthun();
           readanytext();
        }
        


	//alert(rndWord);
	



// EZEK NEM OLYAN FONTOSAK

  if (
    rndWord === 'the' ||
    rndWord === 'and' ||
    rndWord === 'of' ||
    rndWord === 'a' ||
    rndWord === 'in' ||
    rndWord === 'to' ||
    rndWord === 'that'
  ) {
    alert('The random word matches one of the specified words!');
    await randomWordFunction(); // Call randomWordFunction again to get a new random word
  }
  
  
  
  //idáig a core meg izé
    }
  }
  
  
}

	
	
	function sunoSearch() {
		console.log('Executing sunoSearch');
    var content = document.getElementById('current-letter').textContent;
    if (content.trim() === '') {
        content = document.getElementById('selectedtextblock').textContent;
    }
    if (content.trim() !== '') {
        window.open('https://suno.com/search?type=song&q=' + rndWord, '_blank');
    }
}

async function mainAsySuno() {
  await randomWordFunction();
  sunoSearch();
}

/*
használat:
 a sunoSearch akkor legyen meghívva, ha a randomWordFunction teljes egészében lefutott (a randomWordFunction egy async funkció, és lassabban kerül végrehajtásra mint a sunoSearch)
    
      main();  // ez a randomWordFunction majd a sunoSearch és async
  */    




////////











/////////////
/// csak random szó

function randomwordotbutton() {
	
//	randomwordot = 1;
	
	popup.style.display = 'none'; // Ha látható, akkor elrejtjük
	
	// Szerezd be a selectedtextblock elemet
const selectedTextBlock = document.getElementById('selectedtextblock');

// Változtasd meg a megjelenítést
selectedTextBlock.style.fontSize = '18px'; // Betűméret megváltoztatása
selectedTextBlock.style.color = 'rgba(155, 150, 150, 0.5)'; // Szövegszín megváltoztatása RGBA formátumban
selectedTextBlock.style.opacity = '0.5'; // Átlátszóság megváltoztatása 50%-ra
	
	// Szerezd be a contextblock elemet
const contextBlock = document.getElementById('contextblock');

// Változtasd meg a megjelenítést
contextBlock.style.fontSize = '16px'; // Betűméret megváltoztatása
contextBlock.style.zIndex = '10'; // z-index beállítása
contextBlock.style.position = 'fixed';
contextBlock.style.bottom = '10%'; // Pozíció beállítása a képernyő aljától
contextBlock.style.left = '50%'; // Pozíció beállítása a képernyő közepére vízszintesen
contextBlock.style.transform = 'translateX(-50%)'; // Középre igazítás vízszintesen
contextBlock.style.color = 'rgba(128, 128, 128, 0.2)'; // Szürke szín 80%-os átlátszósággal
	
	
// Szerezd be a translated elemet
const translatedBlock = document.getElementById('translated');

// Változtasd meg a megjelenítést
translatedBlock.style.zIndex = '10'; // z-index beállítása
translatedBlock.style.fontSize = '12px'; // Betűméret megváltoztatása
translatedBlock.style.position = 'fixed'; // Pozíció beállítása
translatedBlock.style.bottom = '61%'; // Pozíció beállítása a képernyő aljától
translatedBlock.style.left = '50%'; // Pozíció beállítása a képernyő közepére vízszintesen
translatedBlock.style.transform = 'translateX(-50%)'; // Középre igazítás vízszintesen
translatedBlock.style.color = 'rgba(128, 128, 128, 0.3)'; // Szürke szín 80%-os átlátszósággal
	
	
	
	
	let existingEntries = localStorage.getItem('favoritstorage');
  if (existingEntries) {
    let txtEntries = existingEntries.split('\n').filter(line => line.endsWith('.txt'));
    
    //A randomEntry lesz ugye a kiválasztott sor. Ennek a sornak a száma kellene és kiírni egy alert-ba.
    if (txtEntries.length > 0) {
    let randomEntry = txtEntries[Math.floor(Math.random() * txtEntries.length)];
    readTextFile(randomEntry);
    // Az alert hívás itt történik, miután a fájl beolvasása sikeres volt
    //alert(`Random entry: ${txtEntries.indexOf(randomEntry) + 1}`);
    
    randombooknumber = (`${txtEntries.indexOf(randomEntry) + 1}`);
    
    
    
    
      // Az alert hívás itt történik, miután a fájl beolvasása sikeres volt
      //alert(origcontent);


// A localStorage-ban tároljuk a randomEntry értékét a 'readpathstorage' kulcs alatt ha kitörölnénk manuálisan
      localStorage.setItem('readpathstorage', randomEntry);



  bookname = randomEntry.substring(randomEntry.lastIndexOf("/") + 1);

  
// A bookname faszságai
// Nemkívánatos speciális karakterek
const undesiredSpecialChars = ['+', '-', '_', '|', '=', '#', '*', '<', '(', ')', '[', ']', '{', '}', '\\', '/', '&', '^', '%', '$', '@', '`', '~'];

// Tisztítás
let filteredContent = bookname.split('').map(char => undesiredSpecialChars.includes(char) ? ' ' : char).join('');

// Visszahelyezés a kiszedett karakterek helyére egy space-szel
bookname = filteredContent;
        
//alert(bookname);



      legorigabbcontent = origcontent;
            
                analysis();   // már itt lefut
            
                replaceSt();
                removeQuotes();  // idézőjel
                replaceMr();
                linebreakreplacement(); //savefilenak formázás
                
                let result = AIrecognizelanguage(origcontent);
                supervision();
                //console.log(result);
                
                
                // funkción belüli funkció következik
                
                
                
           //     bookname = (randomEntry + " clipboard");
      
      
      
  //    
      
      
           // minden nyitó és záró zárójel kiszedése a bookmark localstorage miatt, ez nem csere 
            bookname = bookname.replace(/[()]/g, '');
            
            
            console.log('File loaded successfully.');

            if (bookname) {
            	fadebookname(); // fadetext
                console.log('Book name:', bookname); // Ha létezik a bookname, kiírjuk a konzolba
            }
            countSentences();
            
      // idáig a core betöltése, és flawless!!! yeah
      
      
      
      
      //alert(origcontent);
      
      // Ha az rndWord változóban volna pont, vessző, felkiáltójel, kérdőjel, akkor ezektől tisztítsuk meg.
      
      
   // Assuming 'origcontent' is the original content
  let words = origcontent.split(' ');

  // Filter out the specified words
  
  // IDE A KIVÉTELEKET!
  words = words.filter(
    (word) =>
      word !== 'the' &&
      word !== 'The' &&
      word !== 'and' &&
      word !== 'of' &&
      word !== 'a' &&
      word !== 'in' &&
      word !== 'to' &&
      word !== 'you' &&
      word !== 'are' &&
      word !== 'that' &&
      word !== 'is'
  );

let rndIndex;


do {
  rndIndex = Math.floor(Math.random() * words.length);
  rndWord = words[rndIndex];

  // Remove any punctuation from the random word
  rndWord = rndWord.replace(/[.,!?]/g, '');
} while (rndWord.length < 4);

//navigator.clipboard.writeText(rndWord);
console.log(rndWord);

startTypingAnimation('paragraphId', 'divId', rndWord);

//fadeInOutTextInfinite(rndWord, 46, 'rgba(220, 100, 0, 1)', 50);

//fadeInOutText(rndWord, 34, 'rgba(220, 100, 0, 1)', 40);
	
	fadeInOutTextBlink(rndWord, 54, 'rgba(0, 100, 230, 1)', 6, 80);



stopMonitoring();

navigator.clipboard.writeText(rndWord);



//	alert(rndWord);
	
universaltranslate(rndWord);
	
	localStorage.setItem('rndWordstorage', String(rndWord)); // String-ként mentés
	

	
	
	
	
	
	
	
	
	
	
	createButton('ANOTHER Word', 'absolute', 320, 620, 'rgba(230,13,1,0.89)', 10101, function() {
    randomwordsearch++;
    if (randomwordsearch !== 0) {
deleteAllButtons();
//stopClearInfiniteFadeinoutText();
stopClearFadeinoutText();
randomwordotbutton();
     }
    
}, false);
	
	createButton('restart', 'absolute', 460, 620, 'rgba(255,255,0,0.1)', 10101, function() {
    playrefreshSound();
}, false);
	
	
	
	

	
	createButton('modarchive', 'absolute', 0, 200, 'rgba(175,205,86,0.64)', 10100, function() {
    if (winner === "hu") {
        // Várjon 3 másodpercet, majd induljon a keresés
        setTimeout(() => {
            const query = encodeURIComponent(translatedText);
            window.open('https://modarchive.org/index.php?request=search&query=' + query + '&submit=Find&search_type=filename_or_songtitle', '_blank');
        }, 3000);
        return; // ezzel megakadályozzuk a későbbi, azonnali ablaknyitást
    }

    // Ha nem "hu", azonnal nyisson új ablakot
    const query = encodeURIComponent(rndWord);
    window.open('https://modarchive.org/index.php?request=search&query=' + query + '&submit=Find&search_type=filename_or_songtitle', '_blank');
    
}, false);


createButton('c64 CSDB', 'absolute', 160, 200, 'rgba(63,150,149,0.54)', 10100, function() {
    window.open('https://csdb.dk/search/?seinsel=all&search=' + rndWord + '&Go.x=0&Go.y=0', '_blank');
}, false);

createButton('internet-radio', 'absolute', 160, 240, 'rgba(182, 74, 209, 0.67)', 10100, function() {
    window.open('https://www.internet-radio.com/search/?radio=' + rndWord, '_blank');
}, false);




createButton('www.zophar.net', 'absolute', 320, 200, 'rgba(163,10,149,0.54)', 10100, function() {
    window.open('https://www.zophar.net/random-music', '_blank');
}, false);

createButton('Youtube', 'absolute', 480, 200, 'rgba(63,150,149,0.54)', 10100, function() {
	
	localStorage.setItem('rndWordstorage', String(rndWord)); // String-ként mentés
	
//	youtubewatcher();
      
       youtubeRandomwatcher();

	// Mentés localStorage-ba
//	localStorage.setItem('rndWordstorage', rndWord);
	
	
  

	
   // window.open('https://m.youtube.com/results?sp=mAEA&search_query=' + rndWord, '_blank');
}, false);



createButton('ApkPure', 'absolute', 0, 320, 'rgba(236,28,162,0.58)', 10100, function() {
    window.open('https://apkpure.com/search?q=' + rndWord + '&t=', '_blank');
}, false);

createButton('gamefaqs', 'absolute', 160, 320, 'rgba(236,28,162,0.58)', 10100, function() {
    window.open('https://gamefaqs.gamespot.com/search?game=' + rndWord, '_blank');
}, false);


createButton('Soundsnap', 'absolute', 320, 320, 'rgba(105,84,116,0.88)', 10100, function() {
    window.open('https://www.soundsnap.com/search/audio?query=' + rndWord, '_blank');
}, false);

createButton('Zapsplat', 'absolute', 480, 320, 'rgba(236,166,75,0.39)', 10100, function() {
    window.open('https://www.zapsplat.com/?s=' + rndWord, '_blank');
}, false);

createButton('Freesound', 'absolute', 0, 440, 'rgba(236,166,75,0.39)', 10100, function() {
    window.open('https://freesound.org/search/?q=' + rndWord, '_blank');
}, false);

createButton('Happymod', 'absolute', 160, 440, 'rgba(2,68,232,0.14)', 10100, function() {
    window.open('https://download.happymod.com/search.html?q=' + rndWord + '&submit=Find&search_type=filename_or_songtitle', '_blank');
}, false);

createButton('Mobigames', 'absolute', 320, 440, 'rgba(35,89,159,0.70)', 10100, function() {
    window.open('https://www.mobygames.com/search/?q=' + rndWord + '&submit=Find&search_type=filename_or_songtitle', '_blank');
}, false);

createButton('Mobigames native random', 'absolute', 480, 440, 'rgba(35,229,159,0.70)', 10100, function() {
    window.open('https://www.mobygames.com/random/', '_blank');
}, false);

createButton('Vicc', 'absolute', 0, 560, 'rgba(149,184,95,0.25)', 10100, function() {
    randomviccNumber = rndmaker(1, 5040);
    window.open('https://www.viccesviccek.hu/vicces_viccek&honnan=' + randomviccNumber, '_blank');
}, false);

createButton('Suno', 'absolute', 160, 560, 'rgba(225,12,192,0.91)', 10100, function() {
    window.open('https://suno.com/search?type=song&q=' + rndWord, '_blank');
}, false);

createButton('khinsider', 'absolute', 320, 560, 'rgba(25,172,192,0.01)', 10100, function() {
    window.open('https://downloads.khinsider.com/search?search=' + rndWord, '_blank');
}, false);

createButton('Libgen nonfiction', 'absolute', 480, 560, 'rgba(148,29,127,0.17)', 10100, function() {
    window.open('https://libgen.rs/search.php?req=' + rndWord + '&lg_topic=libgen&open=0&view=simple&res=25&phrase=1&column=def', '_blank');
}, false);

createButton('Libgen fiction', 'absolute', 0, 680, 'rgba(120,18,200,0.86)', 10100, function() {
    window.open('https://libgen.rs/fiction/?q=' + rndWord, '_blank');
    
    

window.open('https://document.online-convert.com/convert/epub-to-txt/', '_blank');
window.open('https://convertio.co/pdf-txt/', '_blank');
}, false);


createButton('libgen all fiction hun Random', 'absolute', 260, 680, 'rgba(120,118,200,0.96)', 10100, function() {
openRandomLibgenPage();

}, false);

createButton('fanfiction', 'absolute', 390, 680, 'rgba(175,105,86,0.64)', 10100, function() {
    window.open('https://www.fanfiction.net/search/?keywords=' + rndWord + '&ready=1&type=story', '_blank');
}, false);

createButton('Libgen fiction hun', 'absolute', 140, 680, 'rgba(190,18,200,0.86)', 10100, function() {
    var libgenLink = 'https://libgen.rs/fiction/?q=' + rndWord + '&criteria=&language=Hungarian&format=';
    var otherLinks = [
        'https://convertio.co/pdf-txt/',
        'https://document.online-convert.com/convert/epub-to-txt/'
    ];

    // Libgen link másolása a vágólapra
    if (navigator.clipboard) {
        navigator.clipboard.writeText(libgenLink).then(function() {
            alert('A Libgen keresési link a vágólapra került!');
        }, function() {
            alert('Nem sikerült a vágólapra másolni a linket.');
        });
    } else {
        var tempInput = document.createElement("input");
        tempInput.value = libgenLink;
        document.body.appendChild(tempInput);
        tempInput.select();
        try {
            document.execCommand("copy");
            alert('A Libgen keresési link a vágólapra került!');
        } catch (err) {
            alert('Nem sikerült a vágólapra másolni a linket.');
        }
        document.body.removeChild(tempInput);
    }

    // Linkek megnyitása késleltetve, Libgen legutoljára
    otherLinks.forEach(function(link, index) {
        setTimeout(function() {
            window.open(link, '_blank');
        }, index * 1000); // 1 másodpercenként nyitja meg őket
    });

    // Libgen link megnyitása a végén (2 másodperc késleltetés)
    setTimeout(function() {
        window.open(libgenLink, '_blank');
    }, otherLinks.length * 1000);

}, false);




	
	
	
	
	
	// random letter hun libgen
	
	
	
	const magyarBetuk = 'aábcdeéfghiíjklmnoóöőpqrstuúüűvwxyz';

function generateRandomMagyarBetu() {
    return magyarBetuk.charAt(Math.floor(Math.random() * magyarBetuk.length));
}

createButton('LIBGEN HUN RANDOM', 'absolute', 100, 100, 'rgba(25,172,192,0.81)', 10100, function() {
    const randomBetu = generateRandomMagyarBetu();
    const libgenUrl = `https://libgen.rs/fiction/?q=${randomBetu}%2A&criteria=&language=Hungarian&format=&page=1`;

    const otherUrl = 'https://document.online-convert.com/convert/epub-to-txt/';

    // Először a másik link megnyitása késleltetéssel
    setTimeout(function() {
        window.open(otherUrl, '_blank');
    }, 0);

    // Libgen link megnyitása 1 másodperccel később
    setTimeout(function() {
        window.open(libgenUrl, '_blank');
    }, 1000);

}, true);

	
	
	//window.open('https://libgen.rs/fiction/?q=a%2A&criteria=&language=Hungarian&format=&page=14' + rndWord, '_blank');
	
	
	
	
	
	createButton('gyakorikerdesek', 'absolute', 100, 100, 'rgba(135,199,177,0.15)', 10100, function() {
	
	window.open('https://www.gyakorikerdesek.hu/kereses.php?keres=' + szoforditas, '_blank');
	
}, true);


createButton('C64 rnd', 'absolute', 100, 100, 'rgba(156,71,202,0.04)', 10100, function() {
	
	window.open('https://csdb.dk/navigate.php?type=release&action=rand&id=236129', '_blank');
	
}, true);


createButton('C64 ftp', 'absolute', 100, 100, 'rgba(79,202,169,0.44)', 10100, function() {
	
	window.open('http://ftp.pokefinder.org/index.php?s=' + rndWord + '&m=0&h=100', '_blank');
	
}, true);


createButton('Freepik', 'absolute', 100, 100, 'rgba(79,202,169,0.44)', 10100, function() {
	
	window.open('https://www.freepik.com/search?format=search&last_filter=query&last_value=' + rndWord + '&query=' + rndWord, '_blank');
	
}, true);




	

// EZEK NEM OLYAN FONTOSAK

  if (
    rndWord === 'the' ||
    rndWord === 'and' ||
    rndWord === 'of' ||
    rndWord === 'a' ||
    rndWord === 'in' ||
    rndWord === 'to' ||
    rndWord === 'that'
  ) {
    alert('The random word matches one of the specified words!');
    randomwordotbutton(); // Call randomWordFunction again to get a new random word
  }
  
  
  
  //idáig a core meg izé
    }
  }
  
  
}
	
	
	//////// random szín popup ablaknak

// Div elem kiválasztása
const popup = document.getElementById('popup');

// Véletlenszerű RGBA szín generálása
function getRandomRGBAColor() {
  const r = Math.floor(Math.random() * 256);
  const g = Math.floor(Math.random() * 256);
  const b = Math.floor(Math.random() * 256);
  const a = Math.random().toFixed(2); // 0.00 és 1.00 közötti véletlen szám
  return `rgba(${r}, ${g}, ${b}, ${a})`;
}

// Div elem háttérszínének és box-shadow színének beállítása
function setRandomColors() {
  const backgroundColor = getRandomRGBAColor();
  const boxShadowColor = getRandomRGBAColor();
  popup.style.backgroundColor = backgroundColor;
  popup.style.boxShadow = `0 0 50px ${boxShadowColor}`;
  console.log(`Háttérszín: ${backgroundColor}, Box-shadow szín: ${boxShadowColor}`);
}

// Véletlenszerű színek beállítása
setRandomColors();

//////////////////
//// hány óra funkció

function hanyora() {
	
	     // hány óra
        let date = new Date();
        let options = {
           // year: 'numeric',
          //  month: 'numeric',
         //   day: 'numeric',
            hour: 'numeric',
            minute: 'numeric',
            timeZone: 'Europe/Budapest'
        };
        
        let options2 = {
            year: 'numeric',
           month: 'numeric',
           day: 'numeric',
           // hour: 'numeric',
          //  minute: 'numeric',
          //  timeZone: 'Europe/Budapest'
        };
        
        let formattedDate = new Intl.DateTimeFormat('hu-HU', options).format(date);
        
        let formattedDate2 = new Intl.DateTimeFormat('hu-HU', options2).format(date);
        
        console.log(formattedDate);
        var textToRead2 = formattedDate;
        var lang = 'hu-HUN';
        if (winner === "hu") {
            var lang = 'hu-HUN';
        }
        var lang2 = lang;
        var audio2 = new SpeechSynthesisUtterance(textToRead2);
        audio2.lang = lang2;
        audio2.rate = 0.8;
        audio2.volume = 1; // Hangerő beállítása (0.1 - 1 közötti érték)
        audio2.pitch = 1.0;
        speechSynthesis.speak(audio2)
	
	//feliratot is
	fadeInOutText(formattedDate, 64, 'rgba(220, 200, 200, 1)', 66);
	
	}
	
	
	
	let PictureBackground;
	
	// Háttér kép elérési útvonala
PictureBackground = './picture/kjk/dark-dungeon-with-an-eerie-atmosphere-featuring-three-diverging-paths-out-of-the-room-surrounded-by-708701402.webp';

// Várakozás, amíg az oldal betöltődik
window.addEventListener('load', function() {
  // Háttér elem lekérése
  xyz();
  
  
  const backgroundImage = document.getElementById('background-image');

  // Háttér kép beállítása
  backgroundImage.style.backgroundImage = `url(${PictureBackground})`;

  // Háttér elem méretének beállítása az ablak méretéhez
  function resizeBackground() {
    backgroundImage.style.width = window.innerWidth + 'px';
    backgroundImage.style.height = window.innerHeight + 'px';
  }
  resizeBackground();

  // Ablak átméretezésekor a háttér frissítése
  window.addEventListener('resize', resizeBackground);
});










function xyz() {
	

	

	// GetItem
 PictureBackground = localStorage.getItem('extractedPathstorage');
//alert(PictureBackground);

		// Háttér kép elérési útvonala
//PictureBackground = './picture/background8.jpg';





  // Háttér elem lekérése
  const backgroundImage = document.getElementById('background-image');

  // Háttér kép beállítása
  backgroundImage.style.backgroundImage = `url(${PictureBackground})`;

  // Háttér elem méretének beállítása az ablak méretéhez
  function resizeBackground() {
    backgroundImage.style.width = window.innerWidth + 'px';
    backgroundImage.style.height = window.innerHeight + 'px';
  }
  resizeBackground();

  // Ablak átméretezésekor a háttér frissítése
  window.addEventListener('resize', resizeBackground);
  
  
  
}





let isMonochrome = false; // Állapotváltozó a színes és fekete-fehér között


// Fekete-fehér konvertáló funkció
function monochrome() {
    const PictureBackground = localStorage.getItem('extractedPathstorage');
    const img = new Image();
    img.src = PictureBackground;

    img.onload = function() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = img.width;
        canvas.height = img.height;

        // Kép rajzolása a canvas-ra
        ctx.drawImage(img, 0, 0);

        // Kép adatainak lekérése
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;

        // Fekete-fehér konvertálás
        for (let i = 0; i < data.length; i += 4) {
            const avg = (data[i] + data[i + 1] + data[i + 2]) / 3; // Szürkeárnyalat számítása
            data[i] = avg;     // R
            data[i + 1] = avg; // G
            data[i + 2] = avg; // B
        }

        // Módosított kép visszaírása a canvas-ra
        ctx.putImageData(imageData, 0, 0);

        // Fekete-fehér háttérkép beállítása
        const monochromeImage = canvas.toDataURL();
        const backgroundImage = document.getElementById('background-image');
        backgroundImage.style.backgroundImage = `url(${monochromeImage})`;
    };
}

// Színes konvertáló funkció
function colorful() {
    const PictureBackground = localStorage.getItem('extractedPathstorage');
    const backgroundImage = document.getElementById('background-image');
    backgroundImage.style.backgroundImage = `url(${PictureBackground})`;
}

// Toggle funkció a színes és fekete-fehér között
function toggleColor() {
    if (isMonochrome) {
        colorful();
    } else {
        monochrome();
    }
    isMonochrome = !isMonochrome; // Állapotváltás
}

// Példa a funkciók hívására
//xyz();
// Toggle funkció hívása
//toggleColor(); // Először fekete-fehérre vált

// háttér vége


/////// libgen all fiction hun Random

function openRandomLibgenPage() {
    const maxPages = 1994;
    const randomPage = Math.floor(Math.random() * maxPages) + 1; // 1-től 1994-ig
    const url = `https://libgen.is/fiction/?q=&criteria=&language=Hungarian&format=&page=${randomPage}`;

    // 1. Bubble létrehozása és megjelenítése
    const bubble = document.createElement('div');
    bubble.textContent = `Random oldal: ${randomPage}`;
    Object.assign(bubble.style, {
        position: 'fixed',
        top: '20px',
        right: '20px',
        backgroundColor: 'rgba(0,0,0,0.8)',
        color: 'white',
        padding: '10px 20px',
        borderRadius: '8px',
        fontSize: '16px',
        zIndex: 9999,
        boxShadow: '0 0 10px rgba(0,0,0,0.5)',
        userSelect: 'none',
    });
    document.body.appendChild(bubble);

    // 2. URL kimásolása a vágólapra
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(url).catch(() => {
            // Ha nem sikerül, fallback megoldás lehet
            console.warn('Nem sikerült a vágólapra másolás.');
        });
    } else {
        // Fallback: textarea + execCommand
        const textarea = document.createElement('textarea');
        textarea.value = url;
        document.body.appendChild(textarea);
        textarea.select();
        try {
            document.execCommand('copy');
        } catch (e) {
            console.warn('Nem sikerült a vágólapra másolás.');
        }
        document.body.removeChild(textarea);
    }

    // 3. 5 másodperc várakozás után megnyitja az oldalt és eltávolítja a buborékot
    setTimeout(() => {
        window.open(url, '_blank');
        bubble.remove();
    }, 5000);
}



////// weather cross 2025



const API_KEY = 'RXHG2GB3LUDG3T7CQ4NPZ6RKZ';
const BASE_URL = 'https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/';

async function fetchAndReadWeather(location) {
  try {
    const url = `${BASE_URL}${encodeURIComponent(location)}?unitGroup=metric&key=${API_KEY}&contentType=json`;
    const response = await fetch(url);
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();

    if (!data.days || !Array.isArray(data.days)) {
      console.error('Érvénytelen adat formátum az API-tól.');
      return;
    }

    const forecast = data.days.slice(0, 5);
    for (let i = 0; i < forecast.length; i++) {
      const day = forecast[i];
      const text = `${i + 1}. nap, ${day.datetime}. Várható hőmérséklet minimum ${day.tempmin} és maximum ${day.tempmax} Celsius fok között. ${day.description}. Csapadék esélye ${day.precipprob} százalék. UV index: ${day.uvindex}. Felhőzet: ${day.cloudcover} százalék.`;
      console.log(text);
      speakText(text);
      // Várjunk 5 másodpercet, hogy a beszéd ne fedje át egymást
      await new Promise(res => setTimeout(res, 5000));
    }
  } catch (error) {
    console.error('Hiba az időjárás lekérésekor:', error);
  }
}

function speakText(text) {
  if ('speechSynthesis' in window) {
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = 'hu-HU';
    window.speechSynthesis.speak(utterance);
  } else {
    console.log('A böngésződ nem támogatja a szövegfelolvasást.');
  }
}

// Példa hívás:
//fetchAndReadWeather('Nagykáta');


      
      
      
      
      async function fetchRSS(url) {
  try {
    const response = await fetch(url);
    const text = await response.text();
    const parser = new DOMParser();
    const xml = parser.parseFromString(text, "application/xml");
    const items = xml.querySelectorAll("item");
    items.forEach(item => {
      const title = item.querySelector("title")?.textContent;
      const link = item.querySelector("link")?.textContent;
      console.log(title, link);
    });
  } catch (e) {
    console.error("Hiba az RSS beolvasásakor:", e);
  }
}

// Példa hívás:
//fetchRSS("http://origo.hu/contentpartner/rss/hircentrum/origo.rss");






////// big mp3 player

async function initMp3SplitterPlayer({
    container = document.body,
    darabszam = 10,
    autoLoadFilePath = '/storage/emulated/0/Alarms/The Journey To Baldur_s Gate _ Orchestral Fantasy Music and Ambience _ Original Baldur_s Gate Music.mp3',
  } = {}) {

    // --- Stílus ---
    const style = document.createElement('style');
    style.textContent = `
      body {
        font-family: Arial, sans-serif;
        margin: 2em;
        background: #f9f9f9;
        color: #333;
      }
      label, input, button {
        font-size: 1rem;
        margin: 0.5em 0;
        display: block;
      }
      input[type="file"] {
        width: 100%;
        max-width: 400px;
        padding: 0.5em;
        box-sizing: border-box;
      }
      button {
        padding: 0.5em 1em;
        background-color: #0078d7;
        color: white;
        border: none;
        cursor: pointer;
        border-radius: 4px;
        transition: background-color 0.3s ease;
        margin-top: 0.5em;
      }
      button:hover {
        background-color: #005ea3;
      }
      #status {
        margin-top: 1em;
        font-style: italic;
        min-height: 1.2em;
        max-width: 400px;
      }
      #player {
        margin-top: 1em;
        width: 100%;
        max-width: 400px;
        outline: none;
      }
    `;
    document.head.appendChild(style);

    // --- UI elemek ---
    const title = document.createElement('h1');
    title.textContent = 'Dinamikus MP3 Daraboló és Automatikus Betöltő';
    container.appendChild(title);

    const labelFile = document.createElement('label');
    labelFile.htmlFor = 'mp3file';
    labelFile.textContent = 'Válaszd ki az MP3 fájlt:';
    container.appendChild(labelFile);

    const inputFile = document.createElement('input');
    inputFile.type = 'file';
    inputFile.id = 'mp3file';
    inputFile.accept = 'audio/mp3,audio/mpeg';
    container.appendChild(inputFile);

    const btnStart = document.createElement('button');
    btnStart.textContent = 'Darabolás és lejátszás indítása';
    container.appendChild(btnStart);

    const status = document.createElement('div');
    status.id = 'status';
    container.appendChild(status);

    const audioPlayer = document.createElement('audio');
    audioPlayer.id = 'player';
    audioPlayer.controls = true;
    container.appendChild(audioPlayer);

    // --- WAV kódoló ---
    function encodeWAV(audioBuffer) {
      const numChannels = audioBuffer.numberOfChannels;
      const sampleRate = audioBuffer.sampleRate;
      const format = 1;
      const bitsPerSample = 16;

      const samplesLength = audioBuffer.length * numChannels;
      const buffer = new ArrayBuffer(44 + samplesLength * 2);
      const view = new DataView(buffer);

      function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }

      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + samplesLength * 2, true);
      writeString(view, 8, 'WAVE');

      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, format, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * numChannels * bitsPerSample / 8, true);
      view.setUint16(32, numChannels * bitsPerSample / 8, true);
      view.setUint16(34, bitsPerSample, true);

      writeString(view, 36, 'data');
      view.setUint32(40, samplesLength * 2, true);

      let offset = 44;
      const channelData = [];
      for (let ch = 0; ch < numChannels; ch++) {
        channelData.push(audioBuffer.getChannelData(ch));
      }

      for (let i = 0; i < audioBuffer.length; i++) {
        for (let ch = 0; ch < numChannels; ch++) {
          let sample = channelData[ch][i];
          sample = Math.max(-1, Math.min(1, sample));
          sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
          view.setInt16(offset, sample, true);
          offset += 2;
        }
      }

      return new Blob([buffer], { type: 'audio/wav' });
    }

    // --- Darabolás és lejátszás ---
    async function darabolEsLejatsz(file) {
      status.textContent = 'Fájl beolvasása...';
      audioPlayer.src = '';

      try {
        const arrayBuffer = await file.arrayBuffer();
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

        status.textContent = `Fájl betöltve, hossz: ${audioBuffer.duration.toFixed(2)} mp`;

        const darabHossz = audioBuffer.duration / darabszam;
        const segments = [];

        for (let i = 0; i < darabszam; i++) {
          status.textContent = `Darabolás: ${i + 1} / ${darabszam}`;

          const startSample = Math.floor(i * darabHossz * audioBuffer.sampleRate);
          const endSample = (i === darabszam - 1) ? audioBuffer.length : Math.floor((i + 1) * darabHossz * audioBuffer.sampleRate);
          const frameCount = endSample - startSample;

          const segmentBuffer = audioCtx.createBuffer(
            audioBuffer.numberOfChannels,
            frameCount,
            audioBuffer.sampleRate
          );

          for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) {
            const channelData = audioBuffer.getChannelData(ch).slice(startSample, endSample);
            segmentBuffer.copyToChannel(channelData, ch, 0);
          }

          segments.push(segmentBuffer);
        }

        const randomIndex = Math.floor(Math.random() * darabszam);
        status.textContent = `Lejátszásra kerül a(z) ${randomIndex + 1}. rész`;

        const wavBlob = encodeWAV(segments[randomIndex]);
        const url = URL.createObjectURL(wavBlob);

        audioPlayer.src = url;
        audioPlayer.currentTime = 0;

        await audioPlayer.play();

      } catch (e) {
        alert("Hiba a fájl feldolgozása közben: " + e.message);
        status.textContent = '';
      }
    }

    // --- Automatikus fájl betöltése és lejátszása azonnal ---
    async function autoLoadAndPlay() {
      status.textContent = 'Automatikusan fájl betöltése folyamatban...';

      try {
        const headResp = await fetch(autoLoadFilePath, { method: 'HEAD' });
        if (!headResp.ok) throw new Error('Nem elérhető az automatikus fájl');

        const resp = await fetch(autoLoadFilePath);
        if (!resp.ok) throw new Error('Hiba a fájl letöltésekor');

        const blob = await resp.blob();
        const file = new File([blob], autoLoadFilePath.split('/').pop(), { type: 'audio/mpeg' });

        status.textContent = 'Fájl betöltve, darabolás és lejátszás indul...';

        await darabolEsLejatsz(file);

      } catch (err) {
        status.textContent = '';
        alert('Nem található az automatikusan betöltendő mp3 fájl: ' + autoLoadFilePath);
      }
    }

    // --- Gomb esemény kézi fájlfeltöltéshez ---
    btnStart.addEventListener('click', () => {
      if (!inputFile.files || inputFile.files.length === 0) {
        alert('Kérlek, válassz ki egy MP3 fájlt!');
        return;
      }
      const file = inputFile.files[0];
      if (!file.type.match('audio/mpeg') && !file.name.toLowerCase().endsWith('.mp3')) {
        alert('Kérlek, válassz ki egy MP3 fájlt!');
        return;
      }
      darabolEsLejatsz(file);
    });

    // --- Automatikus indítás ---
    autoLoadAndPlay();

  }

  // Globálisan elérhetővé tesszük:
  window.initMp3SplitterPlayer = initMp3SplitterPlayer;


/*

használat

initMp3SplitterPlayer({
    container: document.body,
    darabszam: 10,
    autoLoadFilePath: '/storage/emulated/0/Alarms/The Journey To Baldur_s Gate _ Orchestral Fantasy Music and Ambience _ Original Baldur_s Gate Music.mp3'
  });
*/





  













///////////////////////////////////
/////   playgroundPrompt

function playgroundPrompt() {

stopMonitoring();
	startTypingAnimation('paragraphId', 'divId', 'successfull');
	
	
    // Textarea szövegének lekérése
    
    
    var textareaText = document.getElementById('selectedtextblock').innerText;
    
    // a fordítandó variable
    word = textareaText;
    
    const inputText = word;
    let inputLanguage = "hu"; // Alapértelmezett érték
    let outputLanguage = "en"; // Alapértelmezett érték



    const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=${inputLanguage}&tl=${outputLanguage}&dt=t&q=${encodeURI(inputText)}`;

    fetch(url)
        .then((response) => response.json())
        .then((json) => {
            szoforditas = json[0].map((item) => item[0]).join("");
            
            // Töröljük a felismerInput textarea tartalmát
            //document.getElementById('felismerInput').value = "";
            
            // A lefordított szöveg legyen a felismerInput textarea értéke
            //document.getElementById('selectedtextblock').value = szoforditas;

            // clipboardba
            navigator.clipboard.writeText("" + szoforditas + "\n Rhythmic, complex, hopeful, captured through a Nikon D850, 35mm lens, cinematic lighting, extreme realism, stunning Ultra HD, aperture F 2.5, raw style, aspect ratio 2:3, shutter speed 1/250, high-resolution violent, staged photo, spectacular night lighting glow, clarity, fine brushwork, 32k, trending on Artstation, UHD, XHD, unrealistic engine - backlit, very attractive appearance, impeccable facial expressions, beauty dynamics, play of light, masterpiece of photography, award-winning photography, model, full frame, symmetrical, hyper-realistic, dynamic lighting.").then(function() {
                console.log('A szöveg sikeresen másolva lett a vágólapra: ' + szoforditas + "\n Rhythmic, complex, hopeful, captured through a Nikon D850, 35mm lens, cinematic lighting, extreme realism, stunning Ultra HD, aperture F 2.5, raw style, aspect ratio 2:3, shutter speed 1/250, high-resolution violent, staged photo, spectacular night lighting glow, clarity, fine brushwork, 32k, trending on Artstation, UHD, XHD, unrealistic engine - backlit, very attractive appearance, impeccable facial expressions, beauty dynamics, play of light, masterpiece of photography, award-winning photography, model, full frame, symmetrical, hyper-realistic, dynamic lighting.");
                
                
                    // playground weboldal open
        
        window.open('https://playground.com/create', '_blank');
        
                
            }, function(err) {
                console.error('Hiba történt a vágólapra másolás közben: ', err);
            });

            // fel is olvassa
            var speech = new SpeechSynthesisUtterance();
            speech.text =  szoforditas;
            speech.lang = "en-ENG";
            speechSynthesis.speak(speech);
        });
        
        //button a lehagyandó promptnak
        
        createScriptButton("Exclude From Image", function() {
        
 console.log("Exclude From Image");
  navigator.clipboard.writeText('5 fingers, disfigured, poorly drawn face, mutation, extra limb, ugly, disgusting, poorly drawn hands, missing limb, floating limbs, detached limbs, deformed hands, blurred, (mutated hands and fingers), watermark, oversaturated, black and white, worst quality, low quality, large head, bad anatomy, bad hands, text, error, missing fingers, jpeg artifacts, signature, (watermark), user name, logo, body out of frame, ((deformed)), (squint), (closed eyes), blurry, (bad anatomy), ugly, disfigured, ((poorly drawn)), (extra limbs), (extra feet), (bad body), too many limbs, fused fingers, too many fingers, text, logos, signature, words, clean face, (overexposure), (oversaturation), cartoon, spots on skin, acne, skin defects, age spots, glans, extra fingers, fewer fingers, strange fingers, advertising hand, ((mole)), ((tattoos)), extra nipples, slight negativity, African, bad hands-5, ugly, deformed, noisy, blurry, distorted, out of focus, bad anatomy, extra limbs, poorly drawn face, poorly drawn hands, missing fingers');
  
  startTypingAnimation('paragraphId', 'divId', 'Copied to Clipboard');
  
  
  
  removeScriptButton("Exclude From Image");
  
}, {
  position: "absolute",
    top: "34%",
    left: "60%",
    transform: "translate(-50%, -50%)",
    fontSize: "16px",
    padding: "10px 20px",
    backgroundColor: "rgba(0, 75, 255, 0.5)",
    color: "rgba(255, 255, 255, 0.8)",
    border: "none",
    borderRadius: "4px",
    zIndex: '9999' // Beállítjuk a z-index értékét
}); 
        
    }


function smallprompt() {
	
    stopMonitoring();
  

  // Kiolvassuk a contextblock elem szövegét
  var currentreadText = document.getElementById('contextblock').textContent;
//var currentreadText = document.getElementById('selectedtextblock').textContent;

  // bookname változó definiálása (példa értékkel)
  //var bookname = "A fantasy könyv címe"; // Ezt cseréld le a tényleges könyv nevére vagy változóra

  // Új szöveg összeállítása
  currentreadText = "Mondj képötleteket. És csinálj ilyen témájú képet magas minőségben: " + "\n" + "\n" + currentreadText + bookname;

  // Szöveg másolása a vágólapra
  navigator.clipboard.writeText(currentreadText).then(function() {
   // console.log('A context szöveg sikeresen másolva lett a vágólapra: ' + currentreadText);
  }).catch(function(err) {
    console.error('Hiba történt a vágólapra másolás közben: ', err);
  });

  // Fókusz visszaállítása a dokumentumra
  document.body.focus();

  

}



  </script>
</body>
</html>






<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STATIC SPEEDOMETER</title>
    <style>
        canvas {
            border: 1px solid #000;
            opacity: 0; /* Start fully transparent */
            transition: opacity 0.5s; /* Smooth transition for opacity */
        }
        #canvasContainer {
            position: absolute; /* Use absolute positioning for flexibility */
            opacity: 0.8; /* Set the container opacity */
        }
    </style>
</head>
<body>
    <div id="canvasContainer">
        <canvas id="canvas"></canvas>
    </div>
    
    <script>
        'use strict';

        var c = document.getElementById("canvas");
        var ctx = c.getContext("2d");
        
        var sizePercent = 60; // Set the initial size percentage
        var maxSpeed = 140; // Set the maximum speed for the speedometer
        var speed = 0; // Initialize speed to 0
        var gear = 3;   // Set a fixed gear
        var rpm = 1;    // Set a fixed RPM

        function updateCanvasSize() {
            c.width = 500 * (sizePercent / 100);
            c.height = 500 * (sizePercent / 100);
            drawSpeedo(speed, gear, rpm); // Redraw the speedometer with new size
        }

        var speedGradient = ctx.createLinearGradient(0, 500, 0, 0);
        speedGradient.addColorStop(0, '#00b8fe');
        speedGradient.addColorStop(1, '#41dcf4');

        var rpmGradient = ctx.createLinearGradient(0, 500, 0, 0);
        rpmGradient.addColorStop(0, '#f7b733');
        rpmGradient.addColorStop(1, '#fc4a1a');

        function speedNeedle(rotation) {
            ctx.lineWidth = 2;
            ctx.save();
            ctx.translate(c.width / 2, c.height / 2);
            ctx.rotate(rotation);
            ctx.strokeRect(-130 / 2 + 170 * (sizePercent / 100), -1 / 2, 135 * (sizePercent / 100), 1);
            ctx.restore();
        }

        function rpmNeedle(rotation) {
            ctx.lineWidth = 2;
            ctx.save();
            ctx.translate(c.width / 2, c.height / 2);
            ctx.rotate(rotation);
            ctx.strokeRect(-130 / 2 + 170 * (sizePercent / 100), -1 / 2, 135 * (sizePercent / 100), 1);
            ctx.restore();
        }

        function drawMiniNeedle(rotation, width, speed) {
            ctx.lineWidth = width;
            ctx.save();
            ctx.translate(c.width / 2, c.height / 2);
            ctx.rotate(rotation);
            ctx.strokeStyle = "#333";
            ctx.fillStyle = "#333";
            ctx.strokeRect(-20 / 2 + 220 * (sizePercent / 100), -1 / 2, 20 * (sizePercent / 100), 1);
            ctx.restore();

            let x = (c.width / 2 + 180 * (sizePercent / 100) * Math.cos(rotation));
            let y = (c.height / 2 + 180 * (sizePercent / 100) * Math.sin(rotation));

            ctx.font = "700 " + (20 * (sizePercent / 100)) + "px Open Sans";
            ctx.fillText(speed, x, y);
        }

        function calculateSpeedAngle(x, a, b) {
            let degree = (a - b) * (x) + b;
            let radian = (degree * Math.PI) / 180;
            return radian <= 1.45 ? radian : 1.45;
        }

        function calculateRPMAngel(x, a, b) {
            let degree = (a - b) * (x) + b;
            let radian = (degree * Math.PI) / 180;
            return radian >= -0.46153862656807704 ? radian : -0.46153862656807704;
        }

        function drawSpeedo(speed, gear, rpm) {
            ctx.clearRect(0, 0, c.width, c.height);

            ctx.beginPath();
            ctx.fillStyle = 'rgba(0, 0, 0, .9)';
            ctx.arc(c.width / 2, c.height / 2, c.width * 0.48, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = "#FFF";
            ctx.stroke();

            ctx.beginPath();
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 10;
            ctx.arc(c.width / 2, c.height / 2, c.width * 0.2, 0, 2 * Math.PI);
            ctx.stroke();

            ctx.beginPath();
            ctx.lineWidth = 1;
            ctx.arc(c.width / 2, c.height / 2, c.width * 0.48, 0, 2 * Math.PI);
            ctx.stroke();

            ctx.font = "700 " + (70 * (sizePercent / 100)) + "px Open Sans";
            ctx.textAlign = "center";
            ctx.fillText(speed, c.width / 2, c.height / 2 - 30 * (sizePercent / 100));

            ctx.font = "700 " + (15 * (sizePercent / 100)) + "px Open Sans";
            ctx.fillText("USD", c.width / 2, c.height / 2 - 15 * (sizePercent / 100));

            ctx.fillStyle = "#FFF";
            for (var i = 10; i <= maxSpeed; i += 10) {
                drawMiniNeedle(calculateSpeedAngle(i / maxSpeed, 83.07888, 34.3775) * Math.PI, i % 20 == 0 ? 3 * (sizePercent / 100) : 1 * (sizePercent / 100), i % 20 == 0 ? i : '');
            }

            ctx.beginPath();
            ctx.strokeStyle = speedGradient;
            ctx.lineWidth = 25 * (sizePercent / 100);
            ctx.arc(c.width / 2, c.height / 2, c.width * 0.45, .6 * Math.PI, calculateSpeedAngle(speed / maxSpeed, 83.07888, 34.3775) * Math.PI);
            ctx.stroke();

            ctx.beginPath();
            ctx.lineWidth = 25 * (sizePercent / 100);
            ctx.strokeStyle = rpmGradient;
            ctx.arc(c.width / 2, c.height / 2, c.width * 0.45, .4 * Math.PI, calculateRPMAngel(rpm / 4.7, 0, 22.9183) * Math.PI, true);
            ctx.stroke();

            ctx.strokeStyle = '#41dcf4';
            speedNeedle(calculateSpeedAngle(speed / maxSpeed, 83.07888, 34.3775) * Math.PI);

            ctx.strokeStyle = rpmGradient;
            rpmNeedle(calculateRPMAngel(rpm / 4.7, 0, 22.9183) * Math.PI);
        }

        function showSpeedometer() {
            // Fetch Bitcoin price and update speed
            fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd')
                .then(response => response.json())
                .then(data => {
                    speed = data.bitcoin.usd / 1000; // Divide by 1000 for speedometer
                    updateCanvasSize(); // Set initial size and redraw
                    // Fade in
                    c.style.display = "block";
                    c.style.opacity = 0;

                    // Use requestAnimationFrame for smoother animations
                    let fadeIn = () => {
                        c.style.opacity = parseFloat(c.style.opacity) + 0.05;
                        if (parseFloat(c.style.opacity) < 1) {
                            requestAnimationFrame(fadeIn);
                        } else {
                            drawSpeedo(speed, gear, rpm); // Draw the speedometer

                            // Show for 5 seconds
                            setTimeout(() => {
                                // Fade out
                                let fadeOut = () => {
                                    c.style.opacity = parseFloat(c.style.opacity) - 0.05;
                                    if (parseFloat(c.style.opacity) > 0) {
                                        requestAnimationFrame(fadeOut);
                                    } else {
                                        c.style.display = "none"; // Hide after fade out
                                    }
                                };
                                fadeOut();
                            }, 5000); // Display for 5 seconds
                        }
                    };
                    fadeIn();
                })
                .catch(error => console.error('Error fetching Bitcoin price:', error));
        }

/*
        document.addEventListener('DOMContentLoaded', function() {
            updateCanvasSize(); // Set initial size
            showSpeedometer(); // Call the function to show the speedometer
        }, false);
*/

    </script>
</body>
</html>












  

  <script>
  	
  
  
  
  // HARC KJK
  
  
  
  /*
  
  ezen kód alapján :
  
  function newpagekjkgame() {
    // Létrehozunk egy új ablakot
    let win = window.open('', '_blank', 'width=600,height=450');
    
    // Ablak tartalmának létrehozása
    win.document.write('<html><head><title>Könyvjelzők</title><style>body { font-family: Arial, sans-serif; }</style></head><body>');
    ...
  
  Ezt módosítani, az új lapon legyen:
  
*/


  function newpagekjkgame() {
  fetch('kjk1.html')
    .then(response => response.text())
    .then(htmlContent => {
      let win = window.open('', '_blank', 'width=600,height=450');
      win.document.write(htmlContent);
      win.document.close();
    })
    .catch(err => alert('Nem sikerült betölteni a fájlt: ' + err));
}


  //// youtube watcher
  
  function youtubewatcher() {
  fetch('youtube watcher 1.html')
    .then(response => response.text())
    .then(htmlContent => {
      let win = window.open('', '_blank', 'width=600,height=450');
      win.document.write(htmlContent);
      win.document.close();
    })
    .catch(err => alert('Nem sikerült betölteni a fájlt: ' + err));
}
  
  
  //// youtube random watcher
  
  function youtubeRandomwatcher() {
  fetch('youtube random watcher 1.html')
    .then(response => response.arrayBuffer())
    .then(buffer => {
      const decoder = new TextDecoder('utf-8');
      const htmlContent = decoder.decode(buffer);
      const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      window.open(url, '_blank', 'width=600,height=450');
    })
    .catch(err => alert('Nem sikerült betölteni a fájlt: ' + err));
}


function btz2D() {
  fetch('btzchart 1.html')
    .then(response => response.text())
    .then(htmlContent => {
      let win = window.open('', '_blank', 'width=600,height=450');
      win.document.write(htmlContent);
      win.document.close();
    })
    .catch(err => alert('Nem sikerült betölteni a fájlt: ' + err));
}



  function btzread3D() {
  fetch('btzchart 1.html')
    .then(response => response.arrayBuffer())
    .then(buffer => {
      const decoder = new TextDecoder('utf-8');
      const htmlContent = decoder.decode(buffer);
      const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      window.open(url, '_blank', 'width=600,height=450');
    })
    .catch(err => alert('Nem sikerült betölteni a fájlt: ' + err));
}





function commandselectjoypad() {
  gamePlaySound(['snd/button/commands ryan Gennylovo_1748535525768.wav', 'snd/button/commands keyra Genny_1748535409999.wav', 'snd/button/commands Elise_1748535366224.wav', 'snd/button/Page 7 Search Switch Soundsnap.mp3'], 1);
  
  disableKeydownListener();
  stopSpeaking();

  const commandKeys = Object.keys(commands);
  let currentIndex = 0;

  // Felolvasás és megjelenítés magyarul az aktuális parancsról és funkciójáról
  function readCurrentCommand() {
    stopSpeaking();
    const commandName = commandKeys[currentIndex];
    const funcName = commands[commandName];
    
    // Felolvasás
    readUniversal(commandName, "hu-HU");
    
    // Buborék megjelenítése: parancs és funkció neve
    const message = `Parancs: ${commandName}\nFunkció: ${funcName}`;
    showBubble(message, "rgba(33,150,243,0.9)", [40, 150]);
  }

  // Kezdeti felolvasás és buborék megjelenítés
  console.log(`Kiválasztott parancs: ${commandKeys[currentIndex]}`);
  readCurrentCommand();

  function runCommand(commandName) {
    const funcName = commands[commandName];
    if (typeof window[funcName] === "function") {
      window[funcName]();
    } else {
      console.warn(`A '${funcName}' nevű funkció nem található.`);
    }
  }

  function joypadHandler(event) {
    switch (event.key) {
      case '3': // Fel (eredetileg 1)
        currentIndex--;
        if (currentIndex < 0) currentIndex = commandKeys.length - 1;
        console.log(`Kiválasztott parancs: ${commandKeys[currentIndex]}`);
        readCurrentCommand();
        break;

      case '1': // Le (eredetileg 3)
        currentIndex++;
        if (currentIndex >= commandKeys.length) currentIndex = 0;
        console.log(`Kiválasztott parancs: ${commandKeys[currentIndex]}`);
        readCurrentCommand();
        break;

      case '2': // Kiválasztás
        const selectedCommand = commandKeys[currentIndex];
        console.log(`Futtatás: ${selectedCommand}`);
        runCommand(selectedCommand);
        document.removeEventListener('keydown', joypadHandler);
        enableKeydownListener();
        break;

      case '4': // Kilépés
        console.log('Kilépés a parancs választóból.');
        showBubble("Kilépés", "rgba(114,67,54,0.9)", [40, 150]);
        gamePlaySound(['snd/exit menu Miso korea Genny Untitled.wav', 'snd/exit command catherine Genny Untitled.wav', 'snd/exit annie Genny Untitled.wav'], 1);
        document.removeEventListener('keydown', joypadHandler);
        enableKeydownListener();
        break;

      default:
        break;
    }
  }

  document.addEventListener('keydown', joypadHandler);
}


  </script>
  
  
  
  
  
  
  <!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hangfelismerő parancsokkal és teljes felolvasással</title>
</head>
<body>

<textarea
  id="felismerInput"
  placeholder="Ide jön a felismerés eredménye..."
  rows="10"
  cols="50"
  style="
    width:100%;
    height: 100px;
    display: none;
    position: fixed;
    bottom: 500px;
    left: 0;
    z-index: 19999;
    padding: 10px;
    box-sizing: border-box;
  "
></textarea>

<script>
  (function(){
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      alert('A böngésződ nem támogatja a Web Speech API-t.');
      return;
    }

    function playOscillatorSound(freq = 440, duration = 300) {
      try {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        oscillator.type = 'sine';
        oscillator.frequency.value = freq;
        gainNode.gain.value = 0.02;

        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        oscillator.start();

        setTimeout(() => {
          oscillator.stop();
          audioCtx.close();
        }, duration);
      } catch(e) {}

    }

    function copyTextareaToClipboard(textarea) {
      const text = textarea.value;
      if (!navigator.clipboard) {
        textarea.select();
        document.execCommand('copy');
        return;
      }
      navigator.clipboard.writeText(text).catch(err => {
        console.error('Vágólapra másolás sikertelen:', err);
      });
    }

    function modifyLastWordToCapital(textarea) {
      let text = textarea.value.trim();
      if (!text) return;
      let words = text.split(/\s+/);
      let lastWord = words.pop();
      if (!lastWord) return;
      lastWord = lastWord.charAt(0).toUpperCase() + lastWord.slice(1);
      words.push(lastWord);
      textarea.value = words.join(' ') + ' ';
      playOscillatorSound(140, 400);
      copyTextareaToClipboard(textarea);
    }

    function removeLastWord(textarea) {
      let text = textarea.value.trim();
      if (!text) return;
      let words = text.split(/\s+/);
      words.pop();
      textarea.value = words.join(' ') + ' ';
      playOscillatorSound(140, 400);
      copyTextareaToClipboard(textarea);
    }

    function clearTextarea(textarea) {
      textarea.value = '';
      playOscillatorSound(140, 400);
      copyTextareaToClipboard(textarea);
    }


    function gptFordit(textarea, recognizer) {
      const text = textarea.value.trim();
      if (!text) return;
      const promptText = `Translate to English.\n- Keep the informal tone of my original message\n- Use British English spelling\n- Rephrase some sentences to make them flow more naturally in English\n- Add a few details to make the text more engaging for English readers.\n"${text}"`;
      navigator.clipboard.writeText(promptText).then(() => {
        console.log('GPT fordítás prompt másolva a vágólapra.');
        window.open("https://gemini.google.com/app", "_blank");
        playOscillatorSound(440, 300);
        if (recognizer && recognizer.isRecognizing) {
          recognizer.stop();
        }
        if (textarea) {
          textarea.style.display = 'none';
        }
      }).catch(err => {
        console.error('Hiba a vágólapra másoláskor:', err);
      });
    }



    function gptpicture(textarea, recognizer) {
      const text = textarea.value.trim();
      if (!text) return;
      const promptText = `Make a picture.\n"${text}"`;
      navigator.clipboard.writeText(promptText).then(() => {
        console.log('GPT kép prompt másolva a vágólapra.');
        window.open("https://gemini.google.com/app", "_blank");
        playOscillatorSound(440, 300);
        if (recognizer && recognizer.isRecognizing) {
          recognizer.stop();
          if (typeof playany === 'function') {
             playany(['snd/button/Digital high tech beep 1.mp3', 'snd/button/mixkit-game-ball-tap-2073.wav', 'snd/button/mixkit-quick-jump-arcade-game-239.wav'], 1);
          }
        }
        if (textarea) {
          textarea.style.display = 'none';
        }
      }).catch(err => {
        console.error('Hiba a vágólapra másoláskor:', err);
      });
    }

    
    function googlekereses(textarea, recognizer) {
      const text = textarea.value.trim();
      if (!text) return;
      
      const query = encodeURIComponent(text);
      const googleUrl = `https://www.google.com/search?q=${query}`;

      navigator.clipboard.writeText(text).then(() => {
        console.log('Google keresési szöveg másolva a vágólapra.');
        window.open(googleUrl, "_blank");
        playOscillatorSound(440, 300);
        
        if (recognizer && recognizer.isRecognizing) {
          recognizer.stop();
        }
        if (textarea) {
          textarea.style.display = 'none';
        }
      }).catch(err => {
        console.error('Hiba a vágólapra másoláskor:', err);
      });
    }


    function gpt(textarea, recognizer) {
      const text = textarea.value.trim();
      if (!text) return;
      const promptText = `${text}?`;

      navigator.clipboard.writeText(promptText).then(() => {
        console.log('GPT prompt másolva a vágólapra.');
        window.open("https://gemini.google.com/app", "_blank");
        playOscillatorSound(440, 300);
        if (recognizer && recognizer.isRecognizing) {
          if (typeof playany === 'function') {
            playany(['snd/button/Digital high tech beep 1.mp3', 'snd/button/mixkit-game-ball-tap-2073.wav', 'snd/button/mixkit-quick-jump-arcade-game-239.wav'], 1);
          }
          recognizer.stop();
        }
        if (textarea) {
          textarea.style.display = 'none';
        }
      }).catch(err => {
        console.error('Hiba a vágólapra másoláskor:', err);
      });
    }
    
    
    /**
     * Felolvassa a szövegmező utolsó tíz szavát, szüneteltetve a hangfelismerést.
     * @param {HTMLTextAreaElement} textarea A szövegmező DOM eleme.
     * @param {object} recognizer A hangfelismerő objektum.
     */
    function readLastTenWords(textarea, recognizer) {
      const text = textarea.value.trim();
      if (!text || !('speechSynthesis' in window)) return;

      const words = text.split(/\s+/);
      const lastTen = words.slice(-10).join(' ');
      
      // Szüneteltetési/újraindítási logika
      const wasRecognizing = recognizer.isRecognizing;
      if (wasRecognizing) {
        recognizer.stopWithoutHiding(); 
      }
      window.speechSynthesis.cancel(); 

      const utterance = new SpeechSynthesisUtterance(lastTen);
      utterance.lang = 'hu-HU';

      utterance.onend = () => {
        if (wasRecognizing) {
          recognizer.start();
        }
      };

      window.speechSynthesis.speak(utterance);
    }

    
    function felolvastextarea(textarea, recognizer) {
      const text = textarea.value.trim();
      if (!text || !('speechSynthesis' in window)) return;

      const wasRecognizing = recognizer.isRecognizing;
      if (wasRecognizing) {
        recognizer.stopWithoutHiding(); 
      }
      window.speechSynthesis.cancel(); 

      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = 'hu-HU';

      utterance.onend = () => {
        if (wasRecognizing) {
          recognizer.start();
        }
      };

      window.speechSynthesis.speak(utterance);
    }

    function processCommand(text, textarea, recognizer) {
      let currentText = textarea.value;
      text = text.toLowerCase();

      if (text.includes('pont') || text.includes('mondatvége')) {
        textarea.value = currentText.trim().replace(/\s+$/, '') + '. ';
        playOscillatorSound();
      } else if (text.includes('vessző')) {
        textarea.value = currentText.trim().replace(/\s+$/, '') + ', ';
        playOscillatorSound();
      } else if (text.includes('kérdőjel')) {
        textarea.value = currentText.trim().replace(/\s+$/, '') + '? ';
        playOscillatorSound();
      } else if (text.includes('felkiáltójel')) {
        textarea.value = currentText.trim().replace(/\s+$/, '') + '! ';
        playOscillatorSound();
      } else if (text.includes('idézőjel')) {
        textarea.value = currentText.trim().replace(/\s+$/, '') + '" ';
        playOscillatorSound();
      } else if (text.includes('kettős')) {
        textarea.value = currentText.trim().replace(/\s+$/, '') + ': ';
        playOscillatorSound();
      } else if (text.includes('zárójel egyes')) {
        textarea.value = currentText.trim().replace(/\s+$/, '') + '( ';
        playOscillatorSound();
      } else if (text.includes('zárójel kettes')) {
        textarea.value = currentText.trim().replace(/\s+$/, '') + ') ';
        playOscillatorSound();
      } else if (text.includes('szóköz')) {
        textarea.value = currentText + '  ';
        playOscillatorSound();
      } else if (text.includes('nagybetűre') || text.includes('nagybetű')) {
        modifyLastWordToCapital(textarea);
        return;
      } else if (text.includes('clear') || text.includes('töröl') || text.includes('white')) {
        clearTextarea(textarea);
        return;
      } else if (text.includes('dell') || text.includes('törlés') ) {
        removeLastWord(textarea);
        readLastTenWords(textarea, recognizer); // Átadva a recognizer objektum
        return;
      } else if (text.includes('red')) {
        removeLastWord(textarea);
        readLastTenWords(textarea, recognizer); // Átadva a recognizer objektum
        return;
      } else if (text.includes('blue')) {
        removeLastWord(textarea);
        removeLastWord(textarea);
        removeLastWord(textarea);
        readLastTenWords(textarea, recognizer); // Átadva a recognizer objektum
        return;
      } else if (text.includes('katica') || text.includes('katica bogár')) {
        felolvastextarea(textarea, recognizer); 
        return;
      } else if (text.includes('restart') || text.includes('újraindít')) {
        clearTextarea(textarea);
        return;
      } else if (text.includes('picture')) {
        gptpicture(textarea, recognizer);
        return;
      } else if (text.includes('google')) {
        googlekereses(textarea, recognizer); 
        return;
      } else if (text.includes('gpt')) {
        gpt(textarea, recognizer);
        return;
      } else if (text.includes('nyelvész')) {
        gptFordit(textarea, recognizer);
        return;
      } else if (text.includes('stop')) {
        if (recognizer && recognizer.isRecognizing) {
          recognizer.stop();
        }
        if (textarea) {
          textarea.style.display = 'none';
        }
        return;
      } else {
        textarea.value += text + ' ';
        playOscillatorSound(600, 150);
      }
      copyTextareaToClipboard(textarea);
    }

    window.myUniqueSpeechRecognizer = {
      recognition: null,
      isRecognizing: false,
      init: function() {
        if (this.recognition) return;
        this.recognition = new SpeechRecognition();
        this.recognition.lang = 'hu-HU';
        this.recognition.continuous = false;
        this.recognition.interimResults = false;

        this.textarea = document.getElementById('felismerInput');

        this.recognition.onresult = (event) => {
          const transcript = event.results[0][0].transcript.trim();
          processCommand(transcript, this.textarea, this);
        };
        
        // színes textarea
        function getRandomRGBA() {
          const r = Math.floor(Math.random() * 256);
          const g = Math.floor(Math.random() * 256);
          const b = Math.floor(Math.random() * 256);
          const a = (Math.random()).toFixed(2);
          return `rgba(${r}, ${g}, ${b}, ${a})`;
        }

        this.recognition.onstart = () => {
          if (this.textarea) {
            const originalColor = this.textarea.style.backgroundColor;
            this.textarea.style.backgroundColor = getRandomRGBA();
            setTimeout(() => {
              this.textarea.style.backgroundColor = originalColor;
            }, 500);
          }
        };

        this.recognition.onerror = (event) => {
          console.error('Hangfelismerés hiba:', event.error);
        };

        this.recognition.onend = () => {
          if (this.isRecognizing) {
            this.recognition.start();
            playOscillatorSound(440, 200);
          }
        };
      },
      start: function() {
        if (!this.recognition) this.init();
        if (!this.isRecognizing) {
          this.isRecognizing = true;
          if (this.textarea) this.textarea.style.display = 'block';
          this.recognition.start();
          playOscillatorSound(440, 200);
        }
      },
      stop: function() {
        if (this.isRecognizing) {
          this.isRecognizing = false;
          this.recognition.stop();
          playOscillatorSound(140, 400);
          if (this.textarea) this.textarea.style.display = 'none';
        }
      },
      stopWithoutHiding: function() {
        if (this.isRecognizing) {
          this.isRecognizing = false;
          this.recognition.stop();
          playOscillatorSound(140, 400);
        }
      }
    };

    window.startBeszed = function() {
      if (typeof stopMonitoring === 'function') {
        stopMonitoring();
      
      if (typeof displayImage === 'function') {
        displayImage(
          '0531b32d-904b-4000-b583-a5e17b37a34f.jpg',
          'vízesés', 20, 20, 50, 50, 5, 'Mozaik effekt', 18, 'rgba(255,255,255,1)'
        );
      }

      }
      window.myUniqueSpeechRecognizer.start();
    };

  })();
</script>

</body>
</html>

  
  
  

  
  
<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bitcoin Árfolyam - Utolsó 12 óra (percenkénti adat)</title>

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet" />

  <style>
    html {
      font-size: 20px;
    }

    

    /* Árfolyam sáv a chart felett */
    #price-bar {
  z-index: 10;
  width: 75%;
  margin: 1rem auto 0 auto;
  background-color: rgba(33, 48, 67, 0.3);
  color: rgba(248, 204, 205, 0.31); /* hex helyett rgba */
  font-size: 28px;
  font-weight: bold;
  padding: 0.5rem 1rem;
  border-radius: 35px;
  text-align: center;
  box-shadow: 0 0 10px rgba(248, 204, 205, 0.2);
  user-select: none;
  position: relative;
}


    @media screen and (max-width: 768px) {
      #price-bar {
        width: 90%;
        font-size: 24px;
      }
    }

    #chart {
      width: 75%;
      margin: 1rem auto 1rem auto;
      /* Háttérszín és pozíció a JS-ben lesz beállítva */
      padding: 2rem;
      border-radius: 5px;
      position: relative;
      box-shadow: 0 0 1rem 0 rgba(0, 0, 0, 0.1);
    }

    @media screen and (max-width: 768px) {
      #chart {
        width: 90%;
      }
    }

    #timeline-chart {
      margin: 0 auto;
      opacity: 0;
      transform: scale(0.95);
      transition: 0.5s ease;
      transition-delay: 0.15s;
      background: linear-gradient(to right, rgb(50, 50, 50), rgb(180, 180, 180));
      border-radius: 5px;
      padding: 1rem;
      position: relative; /* szükséges a belső abszolút pozícionáláshoz */
    }

    #timeline-chart.loaded {
      opacity: 1;
      transform: scale(1);
    }

    /* Aktuális ár megjelenítése a chart jobb felső sarkában */
    #current-price-label {
      position: absolute;
      top: 10px;
      right: 15px;
      color: #F8CCCD;
      font-size: 24px;
      font-weight: bold;
      background: rgba(33, 48, 67, 0.8);
      padding: 4px 10px;
      border-radius: 5px;
      pointer-events: none;
      user-select: none;
      z-index: 10;
      white-space: nowrap;
    }

    /* Szélesebb konténer és magasabb pozíció a képnek */
    #price-change-indicator {
      width: 320px;
      height: 60px;
      margin: -40px auto 1rem auto;
      position: relative;
      overflow: visible;
      text-align: center;
    }

    #price-change-indicator img {
      position: absolute;
      max-width: 60px;
      max-height: 60px;
      opacity: 1;
      display: block;
      margin: 0 auto;
      border-radius: 12px;
      bottom: 0;
      transition: opacity 1s ease;
      transform-origin: center center;
      /* Animációt JS-ben állítjuk */
    }

    .apexcharts-toolbar {
      display: none !important;
    }

    /* Módosított loader - kisebb, áttetsző doboz középen, nem zavaró */
    .loader {
      display: block;
      position: fixed;
      top: 50%;
      left: 50%;
      width: 120px;
      height: 120px;
      background-color: rgba(255, 255, 255, 0.6);
      border-radius: 12px;
      transform: translate(-50%, -50%);
      z-index: 2019;
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
      pointer-events: none; /* ne akadályozza a kattintásokat */
    }

    .loader span {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 5rem;
      height: 5rem;
    }

    .loader span:after,
    .loader span:before {
      content: "";
      display: block;
      width: 1.5rem;
      height: 1.5rem;
      background-color: #f8cccd;
      border-radius: 50%;
      animation: loader 1s ease infinite;
      transform-origin: center center;
    }

    .loader span:after {
      margin-left: -0.25rem;
    }

    .loader span:before {
      background-color: #213043;
      margin-right: -0.25rem;
    }

    @keyframes loader {
      0% {
        transform: skewY(0) translate(0);
      }
      33% {
        transform: skewY(10deg) translate(4rem);
      }
      66% {
        transform: skewY(-10deg) translate(-4rem);
      }
      100% {
        transform: skewY(0) translate(0);
      }
    }

    @keyframes scaleDownUp {
      0% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(0.3);
        opacity: 0.5;
      }
      100% {
        transform: scale(1);
        opacity: 1;
      }
    }
  </style>
</head>
<body>
  <div id="price-bar">--</div>
  <div id="chart">
    <div id="timeline-chart">
      <div id="current-price-label">--</div>
    </div>
  </div>

  <div id="price-change-indicator">
    <img id="change-img" src="picture/grey.jpeg" alt="Árfolyam változás jelző" />
  </div>

  <div class="loader">
    <span></span>
  </div>

  <!-- jQuery CDN -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <!-- ApexCharts CDN -->
  <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>

  <script>
    // BEÁLLÍTÁSOK - itt állíthatod be a chart hátterét, pozícióját és az árfolyam sáv pozícióját
    const chartBackgroundColor = '#000000'; // pl. fekete
    const chartBackgroundOpacity = 0.15;    // 0 és 1 között
    const chartPosition = {
      x: 20,  // vízszintes eltolás px-ben
      y: 200   // függőleges eltolás px-ben
    };
    const priceBarPosition = {
      x: 3,   // vízszintes eltolás px-ben
      y: -70    // függőleges eltolás px-ben
    };

    // Globális frissítési idő (ms-ben)
    const refreshIntervalMs = 60000; // 6 másodperc

    const ajaxUrl = "https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=1";
    let chart;
    let dataSet = [];
    let lastPrice = null;

    const changeImg = document.getElementById('change-img');

    // Segédfüggvény hex szín RGBA-vá alakításához
    function hexToRGBA(hex, opacity) {
      let r = 0, g = 0, b = 0;

      if (hex.length === 4) {
        r = parseInt(hex[1] + hex[1], 16);
        g = parseInt(hex[2] + hex[2], 16);
        b = parseInt(hex[3] + hex[3], 16);
      } else if (hex.length === 7) {
        r = parseInt(hex[1] + hex[2], 16);
        g = parseInt(hex[3] + hex[4], 16);
        b = parseInt(hex[5] + hex[6], 16);
      }

      return `rgba(${r},${g},${b},${opacity})`;
    }

    let firstRequestDone = false;

    function ajax_request(url) {
      const xhttp = new XMLHttpRequest();
      xhttp.onreadystatechange = function () {
        if (this.readyState === 4) {
          if (this.status === 200) {
            handle_chart(this);
          }
          if (!firstRequestDone) {
            firstRequestDone = true;
            $(".loader").fadeOut();
          }
        }
      };
      xhttp.open("GET", url, true);
      xhttp.send();
    }

    function handle_chart(data) {
      const parsed_data = JSON.parse(data.responseText);
      let prices = parsed_data.prices;

      const twelveHoursAgo = Date.now() - 12 * 60 * 60 * 1000;
      prices = prices.filter(p => p[0] >= twelveHoursAgo);

      dataSet = [];
      prices.forEach(value => {
        dataSet.push([value[0], value[1]]);
      });

      const currentPrice = dataSet.length > 0 ? dataSet[dataSet.length - 1][1] : null;

      let imgSrc = "picture/grey.jpeg";
      if (lastPrice !== null && currentPrice !== null) {
        if (currentPrice > lastPrice) {
          imgSrc = "picture/green.jpeg";
        } else if (currentPrice < lastPrice) {
          imgSrc = "picture/red.jpeg";
        }
      }
      lastPrice = currentPrice;

      fadeImage(imgSrc);

      // Frissítjük az ár sávot a chart felett
      const priceBar = document.getElementById('price-bar');
      if (priceBar) {
        priceBar.textContent = currentPrice !== null ? currentPrice.toFixed(2) : "--";
      }

      // Frissítjük a chart jobb felső sarkában lévő címkét is
      const priceLabel = document.getElementById('current-price-label');
      if (priceLabel) {
        priceLabel.textContent = currentPrice !== null ? currentPrice.toFixed(2) : "--";
      }

      const options = {
        chart: {
          type: "area",
          height: 350,
          background: 'transparent',
        },
        yaxis: {
          labels: {
            formatter: val => val.toFixed(0),
            style: {
              colors: 'rgb(180, 180, 180)'
            }
          }
        },
        toolbar: {
          show: false,
          tools: {
            download: false,
            selection: false,
            zoom: false,
            zoomin: false,
            zoomout: false,
            pan: false,
            reset: false,
          },
        },
        dataLabels: {
          enabled: false,
        },
        tooltip: {
          x: {
            format: "dd MMM yyyy HH:mm",
          },
          fixed: {
            enabled: false,
            position: "topRight",
          },
        },
        fill: {
          opacity: 1,
          type: "gradient",
        },
        colors: ["#F8CCCD"],
        series: [
          {
            name: "BTC (USD)",
            data: dataSet,
          },
        ],
        xaxis: {
          type: "datetime",
          axisBorder: {
            show: false,
          },
          axisTicks: {
            show: false,
          },
        },
      };

      if (!chart) {
        chart = new ApexCharts(document.querySelector("#timeline-chart"), options);
        chart.render().then(() => {
          // Loader eltűnik itt is, ha valamiért később töltődik be
          $(".loader").fadeOut();
          $("#timeline-chart").addClass('loaded');
        });
      } else {
        chart.updateOptions(options);
      }
    }

    function fadeImage(newSrc) {
      if (changeImg.src.endsWith(newSrc)) {
        fadeOutIn();
        return;
      }
      changeImg.style.opacity = 0;
      changeImg.style.animation = 'none';
      setTimeout(() => {
        changeImg.src = newSrc;
        changeImg.style.opacity = 1;
        changeImg.style.animation = `scaleDownUp ${refreshIntervalMs}ms ease-in-out infinite`;
      }, 500);
    }

    function fadeOutIn() {
      changeImg.style.opacity = 0;
      changeImg.style.animation = 'none';
      setTimeout(() => {
        changeImg.style.opacity = 1;
        changeImg.style.animation = `scaleDownUp ${refreshIntervalMs}ms ease-in-out infinite`;
      }, 500);
    }

    $(function () {
      // Chart háttér és pozíció beállítása
      const chartEl = document.getElementById('chart');
      const bgColorRGBA = hexToRGBA(chartBackgroundColor, chartBackgroundOpacity);
      chartEl.style.backgroundColor = bgColorRGBA;
      chartEl.style.position = 'relative';
      chartEl.style.left = chartPosition.x + 'px';
      chartEl.style.top = chartPosition.y + 'px';

      // Árfolyam sáv pozíciójának beállítása
      const priceBarEl = document.getElementById('price-bar');
      if (priceBarEl) {
        priceBarEl.style.position = 'relative'; // vagy 'absolute', ha szeretnéd
        priceBarEl.style.left = priceBarPosition.x + 'px';
        priceBarEl.style.top = priceBarPosition.y + 'px';
      }

      ajax_request(ajaxUrl);
      setInterval(() => {
        ajax_request(ajaxUrl);
      }, refreshIntervalMs);
    });
  </script>
</body>
</html>

